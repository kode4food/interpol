(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

// This module is used to collect the requirements for a compiler-included
// Browserify build.  It's of no interest to node.js

require('./standard');
require('../lib/compiler');

},{"../lib/compiler":6,"./standard":2}],2:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

// This module is used to collect the requirements for a minimal
// Browserify build.  It's of no interest to node.js

// Set the Interpol browser global
var interpol = window.interpol = require('../lib/interpol');

// Register the Writers for easier access
var writers = require('../lib/writers');
interpol.createDOMWriter = writers.createDOMWriter;
interpol.createNullWriter = writers.createNullWriter;
interpol.createStringWriter = writers.createStringWriter;

},{"../lib/interpol":12,"../lib/writers":26}],3:[function(require,module,exports){
module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleIndices = { start: 0 },
        peg$startRuleIndex   = 0,

        peg$consts = [
          peg$FAILED,
          "for",
          { type: "literal", value: "for", description: "\"for\"" },
          void 0,
          function() { return 'fr'; },
          "def",
          { type: "literal", value: "def", description: "\"def\"" },
          function() { return 'de'; },
          "from",
          { type: "literal", value: "from", description: "\"from\"" },
          function() { return 'im'; },
          "import",
          { type: "literal", value: "import", description: "\"import\"" },
          "export",
          { type: "literal", value: "export", description: "\"export\"" },
          function() { return 'ex'; },
          "let",
          { type: "literal", value: "let", description: "\"let\"" },
          function() { return 'as'; },
          "and",
          { type: "literal", value: "and", description: "\"and\"" },
          function() { return 'an'; },
          "or",
          { type: "literal", value: "or", description: "\"or\"" },
          function() { return 'or'; },
          "like",
          { type: "literal", value: "like", description: "\"like\"" },
          function() { return 'ma'; },
          "lt",
          { type: "literal", value: "lt", description: "\"lt\"" },
          function() { return 'lt'; },
          "gt",
          { type: "literal", value: "gt", description: "\"gt\"" },
          function() { return 'gt'; },
          "mod",
          { type: "literal", value: "mod", description: "\"mod\"" },
          function() { return 'mo'; },
          "self",
          { type: "literal", value: "self", description: "\"self\"" },
          function() { return 'se'; },
          "not",
          { type: "literal", value: "not", description: "\"not\"" },
          function() { return 'no'; },
          "nil",
          { type: "literal", value: "nil", description: "\"nil\"" },
          function() { return undefined; },
          "if",
          { type: "literal", value: "if", description: "\"if\"" },
          function() { return true; },
          "unless",
          { type: "literal", value: "unless", description: "\"unless\"" },
          function() { return false; },
          "true",
          { type: "literal", value: "true", description: "\"true\"" },
          "false",
          { type: "literal", value: "false", description: "\"false\"" },
          "as",
          { type: "literal", value: "as", description: "\"as\"" },
          "in",
          { type: "literal", value: "in", description: "\"in\"" },
          "else",
          { type: "literal", value: "else", description: "\"else\"" },
          "end",
          { type: "literal", value: "end", description: "\"end\"" },
          "le",
          { type: "literal", value: "le", description: "\"le\"" },
          "lte",
          { type: "literal", value: "lte", description: "\"lte\"" },
          function() { return 'le'; },
          "ge",
          { type: "literal", value: "ge", description: "\"ge\"" },
          "gte",
          { type: "literal", value: "gte", description: "\"gte\"" },
          function() { return 'ge'; },
          "when",
          { type: "literal", value: "when", description: "\"when\"" },
          "where",
          { type: "literal", value: "where", description: "\"where\"" },
          function(id) {
                return sym(id, 'id');
              },
          [],
          function(start, cont) {
                return start + cont.join('');
              },
          /^[$_a-zA-Z]/,
          { type: "class", value: "[$_a-zA-Z]", description: "[$_a-zA-Z]" },
          /^[$_a-zA-Z0-9]/,
          { type: "class", value: "[$_a-zA-Z0-9]", description: "[$_a-zA-Z0-9]" },
          function(start, cont) {
                return sym(start + cont.join(''), 'id');
              },
          /^[a-zA-Z]/,
          { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
          /^[0-9]/,
          { type: "class", value: "[0-9]", description: "[0-9]" },
          function(chars) {
                return sym(chars.join(''), 'id');
              },
          /^[^\0-\x1F'"> \/=]/,
          { type: "class", value: "[^\\0-\\x1F'\"> \\/=]", description: "[^\\0-\\x1F'\"> \\/=]" },
          /^[dD]/,
          { type: "class", value: "[dD]", description: "[dD]" },
          /^[oO]/,
          { type: "class", value: "[oO]", description: "[oO]" },
          /^[cC]/,
          { type: "class", value: "[cC]", description: "[cC]" },
          /^[tT]/,
          { type: "class", value: "[tT]", description: "[tT]" },
          /^[yY]/,
          { type: "class", value: "[yY]", description: "[yY]" },
          /^[pP]/,
          { type: "class", value: "[pP]", description: "[pP]" },
          /^[eE]/,
          { type: "class", value: "[eE]", description: "[eE]" },
          function() { return "DOCTYPE"; },
          /^[1-9]/,
          { type: "class", value: "[1-9]", description: "[1-9]" },
          function(h, t) {
                return h + t.join('');
              },
          null,
          /^[\-+]/,
          { type: "class", value: "[\\-+]", description: "[\\-+]" },
          function(s, d) {
                return 'e' + (s ? s : '+') + d.join('');
              },
          ".",
          { type: "literal", value: ".", description: "\".\"" },
          function(d) {
                return '.' + d.join('');
              },
          function(c, f, e) {
                return sym(parseFloat(c + (f ? f : '') + (e ? e : '')), 'lit');
              },
          { type: "any", description: "any character" },
          /^[ \t\x0B\f]/,
          { type: "class", value: "[ \\t\\x0B\\f]", description: "[ \\t\\x0B\\f]" },
          /^[\n\r]/,
          { type: "class", value: "[\\n\\r]", description: "[\\n\\r]" },
          "#",
          { type: "literal", value: "#", description: "\"#\"" },
          "\"\"\"",
          { type: "literal", value: "\"\"\"", description: "\"\\\"\\\"\\\"\"" },
          function(c) { return c; },
          function(chars) {
                return symInterpolate(chars.join(''), true);
              },
          "'''",
          { type: "literal", value: "'''", description: "\"'''\"" },
          function(chars) {
                return symInterpolate(chars.join(''));
              },
          "\"",
          { type: "literal", value: "\"", description: "\"\\\"\"" },
          function() { return sym('', 'lit'); },
          "'",
          { type: "literal", value: "'", description: "\"'\"" },
          function(c) { return symInterpolate(c.join(''), true); },
          function(c) { return symInterpolate(c.join('')); },
          /^[^"\\]/,
          { type: "class", value: "[^\"\\\\]", description: "[^\"\\\\]" },
          /^[^'\\]/,
          { type: "class", value: "[^'\\\\]", description: "[^'\\\\]" },
          "\\\\",
          { type: "literal", value: "\\\\", description: "\"\\\\\\\\\"" },
          function() { return "\\"; },
          "\\\"",
          { type: "literal", value: "\\\"", description: "\"\\\\\\\"\"" },
          function() { return '"'; },
          "\\'",
          { type: "literal", value: "\\'", description: "\"\\\\'\"" },
          function() { return "'"; },
          "\\b",
          { type: "literal", value: "\\b", description: "\"\\\\b\"" },
          function() { return "\b"; },
          "\\f",
          { type: "literal", value: "\\f", description: "\"\\\\f\"" },
          function() { return "\f"; },
          "\\n",
          { type: "literal", value: "\\n", description: "\"\\\\n\"" },
          function() { return "\n"; },
          "\\r",
          { type: "literal", value: "\\r", description: "\"\\\\r\"" },
          function() { return "\r"; },
          "\\t",
          { type: "literal", value: "\\t", description: "\"\\\\t\"" },
          function() { return "\t"; },
          "==",
          { type: "literal", value: "==", description: "\"==\"" },
          function() { return 'eq'; },
          "!=",
          { type: "literal", value: "!=", description: "\"!=\"" },
          function() { return 'nq'; },
          "+",
          { type: "literal", value: "+", description: "\"+\"" },
          function() { return 'ad'; },
          "-",
          { type: "literal", value: "-", description: "\"-\"" },
          function() { return 'su'; },
          "*",
          { type: "literal", value: "*", description: "\"*\"" },
          function() { return 'mu'; },
          "/",
          { type: "literal", value: "/", description: "\"/\"" },
          function() { return 'di'; },
          function() { return 'ne'; },
          function() { return 'po'; },
          "@",
          { type: "literal", value: "@", description: "\"@\"" },
          function() { return 'bi'; },
          function() { return ' '; },
          function() { return '\n'; },
          function(s) {
                var res = s.join('');
                if ( !res.length ) {
                  return null;
                }
                return res.indexOf('\n') !== -1 ? '\n' : ' ';
             },
          function(s) { return s; },
          function(statements) {
                var results = [];
                for ( var i = 0, len = statements.length; i < len; i++ ) {
                  results.push.apply(results, statements[i][0]);
                  var ws = statements[i][1];
                  if ( ws && ws.length ) {
                    results.push([sym('ou'), sym(ws, 'lit')]);
                  }
                }
                return stmts(results);
              },
          function(s, ws) {
                return [[s], ws];
              },
          function(es) { return es; },
          function() { return null; },
          function(s, t) {
                if ( t ) {
                  return [[s, t], null];
                }
                return [[s], null];
              },
          "<!--",
          { type: "literal", value: "<!--", description: "\"<!--\"" },
          "-->",
          { type: "literal", value: "-->", description: "\"-->\"" },
          function(comment) {
                return [sym('ct'), sym(comment.join(''), 'lit')];
              },
          "<!",
          { type: "literal", value: "<!", description: "\"<!\"" },
          ">",
          { type: "literal", value: ">", description: "\">\"" },
          function(rootElem) {
                return [sym('dt'), rootElem];
              },
          "<",
          { type: "literal", value: "<", description: "\"<\"" },
          function(a) { return a; },
          function(tag, attrs, t) {
                return [sym('op'), tag, attrs, t];
              },
          "(",
          { type: "literal", value: "(", description: "\"(\"" },
          ")",
          { type: "literal", value: ")", description: "\")\"" },
          function(expr) {
                return expr;
              },
          "/>",
          { type: "literal", value: "/>", description: "\"/>\"" },
          function() { return 1; },
          function() { return 0; },
          "=",
          { type: "literal", value: "=", description: "\"=\"" },
          function(e) { return e; },
          function(name, value) {
                return [name, value === null ? sym(true, 'lit') : value];
              },
          "</",
          { type: "literal", value: "</", description: "\"</\"" },
          function(tag) {
                return [sym('cl'), tag];
              },
          function(g) { return g; },
          function(op, id, params, guard, statements) {
                params = params || {};
                var guards = params.guards || [];
                var i;
                var len;
                if ( guards.length ) {
                  if ( guard ) { guards.push(guard); }
                  guard = guards[0];
                  for ( i = 1, len = guards.length; i < len; i++ ) {
                    guard = [sym('an'), guard, guards[i]];
                  }
                }

                if ( guard ) {
                  return [sym(op), id, params.ids || [], statements, guard];
                }
                return [sym(op), id, params.ids || [], statements];
              },
          function(statements) {
                return statements;
              },
          function(params) {
                return params;
              },
          function() {
                return null;
              },
          ",",
          { type: "literal", value: ",", description: "\",\"" },
          function(param) { return param; },
          function(start, cont) {
                var ids = [];
                var guards = [];
                var items = [start].concat(cont);
                for ( var i = 0, len = items.length; i < len; i++ ) {
                  var paramDef = items[i];
                  var item = paramDef[0];
                  if ( isIdentifier(item) ) {
                    ids.push(item);
                    continue;
                  }
                  var idSym = paramDef[1] || sym(i, 'lit');
                  ids.push(idSym);
                  guards.push([sym('ma'), [sym('id'), idSym], item]);
                }
                return { ids: ids, guards: guards };
              },
          function(param) {
                return [param];
              },
          function(id) { return id; },
          function(param, alias) {
                if ( alias ) {
                  return [param, alias];
                }
                return [param];
              },
          function(op, path, imports) {
                return [sym(op), [[path, imports]]];
              },
          function(op, modules) {
                return [sym(op), modules];
              },
          function(item) { return item; },
          function(start, cont) {
                return sym([start].concat(cont).join('/'));
              },
          function(id) {
                return id;
              },
          function(start, cont) {
                return [start].concat(cont);
              },
          function(name, alias) {
                if ( alias ) {
                  return [name, alias];
                }
                return [name];
              },
          function(spec) { return spec; },
          function(path, alias) {
                if ( alias ) {
                  return [path, alias];
                }
                return [path];
              },
          function(op, ranges, statements, tail) {
                return [sym(op), ranges, statements, tail];
              },
          function(r) { return r; },
          function(id, col, guard) {
                if ( guard ) {
                  return [id, col, guard];
                }
                return [id, col];
              },
          function(op, expr, statements, tail) {
                if ( !op ) {
                  return [sym('if'), expr, tail, statements];
                }
                return [sym('if'), expr, statements, tail];
              },
          function(ifStatement) {
                return stmts([ifStatement]);
              },
          function() {
                return stmts([]);
              },
          function(op, a) {
              return [sym(op), a];
            },
          function(id, expr) {
                return [id, expr];
              },
          function(expr) { return [sym('ou'), expr]; },
          "|",
          { type: "literal", value: "|", description: "\"|\"" },
          function(args, calls) {
                if ( calls && calls.length ) {
                  // if it starts with an interpolation, we need to feed it 'self'
                  if ( isInterpolated(args) ) {
                    calls.unshift(args);
                    args = [sym('se', args)];
                  }
                  for ( var i = 0, len = calls.length; i < len; i++ ) {
                    args = [sym('ca'), calls[i], [args]];
                  }
                }
                else {
                  // or if it's an auto interpolation, we also feed it 'self'
                  if ( isInterpolated(args) && args.type === 'auto' ) {
                    args = [ sym('ca'), args, [[sym('se')]] ];
                  }
                }
                return args;
              },
          function(tval, op, cond, fval) {
                if ( !op ) {
                  return [sym('cn'), cond, fval, tval];
                }
                return [sym('cn'), cond, tval, fval];
              },
          function(op, r) { return [sym(op), r]; },
          function(head, tail) {
                return buildBinaryChain(head, tail);
              },
          function(op, expr) {
                if ( op === 'no' || !isInterpolated(expr) || expr.marked ) {
                  return [sym(op), expr];
                }

                if ( op === 'ne' || op === 'po' ) {
                  expr.type = op === 'ne' ? 'int' : 'auto';
                  expr.marked = true;
                  return expr;
                }

                // should not have gotten here
                expected("unary operator of '+' or '-'");
              },
          function(op, listInt) {
                if ( !hasOperator(listInt, 'ca') ) {
                  expected("bind to target a function or partial call");
                }
                return changeOperator(listInt, op);
              },
          function(str, list) {
                return [ sym('ca'), str, [list] ];
              },
          function(sel) { return sel; },
          function(elem) {
                return [sym('mb'), [sym(elem.value, 'lit')]];
              },
          "[",
          { type: "literal", value: "[", description: "\"[\"" },
          "]",
          { type: "literal", value: "]", description: "\"]\"" },
          function(elem) {
                return [sym('mb'), [elem]];
              },
          function(args) {
                return [sym('ca'), args];
              },
          function(elems) {
                return elems;
              },
          function() {
                return [];
              },
          function(comp) {
                return comp;
              },
          function(elems) {
                return [sym('ar'), elems];
              },
          function(elems) {
                return [sym('dc'), elems];
              },
          function() {
                return [sym('ar'), []];
              },
          function(name, value) {
                return [name, value];
              },
          ":",
          { type: "literal", value: ":", description: "\":\"" },
          function(name, value) {
                return [name, value]
              },
          function(expr, op, ranges) {
                return [sym('lc'), ranges, expr];
              },
          function(assign, op, ranges) {
                return [sym('lc'), ranges, assign[1], assign[0]];
              },
          function() { return sym(true, 'lit'); },
          function() { return sym(false, 'lit'); },
          function(id) {
                return [sym('id'), id];
              },
          function(op) {
                return [sym(op)];
              },
          function(op) {
                return sym(op, 'lit');
              }
        ],

        peg$bytecode = [
          peg$decode("7l"),
          peg$decode("!.!\"\"2!3\"+?$!87?9*$$\"\" #\"#  +'%4\"6$\" %$\"#  \"#  "),
          peg$decode("!.%\"\"2%3&+?$!87?9*$$\"\" #\"#  +'%4\"6'\" %$\"#  \"#  "),
          peg$decode("!.(\"\"2(3)+?$!87?9*$$\"\" #\"#  +'%4\"6*\" %$\"#  \"#  "),
          peg$decode("!.+\"\"2+3,+?$!87?9*$$\"\" #\"#  +'%4\"6*\" %$\"#  \"#  "),
          peg$decode("!.-\"\"2-3.+?$!87?9*$$\"\" #\"#  +'%4\"6/\" %$\"#  \"#  "),
          peg$decode("!.0\"\"2031+?$!87?9*$$\"\" #\"#  +'%4\"62\" %$\"#  \"#  "),
          peg$decode("!.3\"\"2334+?$!87?9*$$\"\" #\"#  +'%4\"65\" %$\"#  \"#  "),
          peg$decode("!.6\"\"2637+?$!87?9*$$\"\" #\"#  +'%4\"68\" %$\"#  \"#  "),
          peg$decode("!.9\"\"293:+?$!87?9*$$\"\" #\"#  +'%4\"6;\" %$\"#  \"#  "),
          peg$decode("!.<\"\"2<3=+?$!87?9*$$\"\" #\"#  +'%4\"6>\" %$\"#  \"#  "),
          peg$decode("!.?\"\"2?3@+?$!87?9*$$\"\" #\"#  +'%4\"6A\" %$\"#  \"#  "),
          peg$decode("!.B\"\"2B3C+?$!87?9*$$\"\" #\"#  +'%4\"6D\" %$\"#  \"#  "),
          peg$decode("!.E\"\"2E3F+?$!87?9*$$\"\" #\"#  +'%4\"6G\" %$\"#  \"#  "),
          peg$decode("!.H\"\"2H3I+?$!87?9*$$\"\" #\"#  +'%4\"6J\" %$\"#  \"#  "),
          peg$decode("!.K\"\"2K3L+?$!87?9*$$\"\" #\"#  +'%4\"6M\" %$\"#  \"#  "),
          peg$decode("!.N\"\"2N3O+?$!87?9*$$\"\" #\"#  +'%4\"6P\" %$\"#  \"#  "),
          peg$decode("!.Q\"\"2Q3R+?$!87?9*$$\"\" #\"#  +'%4\"6S\" %$\"#  \"#  "),
          peg$decode("!.T\"\"2T3U+?$!87?9*$$\"\" #\"#  +'%4\"6P\" %$\"#  \"#  "),
          peg$decode("!.V\"\"2V3W+?$!87?9*$$\"\" #\"#  +'%4\"6S\" %$\"#  \"#  "),
          peg$decode("!.X\"\"2X3Y+;$!87?9*$$\"\" #\"#  +#%'\"%$\"#  \"#  "),
          peg$decode("!.Z\"\"2Z3[+;$!87?9*$$\"\" #\"#  +#%'\"%$\"#  \"#  "),
          peg$decode("!.\\\"\"2\\3]+;$!87?9*$$\"\" #\"#  +#%'\"%$\"#  \"#  "),
          peg$decode("!.^\"\"2^3_+;$!87?9*$$\"\" #\"#  +#%'\"%$\"#  \"#  "),
          peg$decode("!.`\"\"2`3a*) \".b\"\"2b3c+?$!87?9*$$\"\" #\"#  +'%4\"6d\" %$\"#  \"#  "),
          peg$decode("!.e\"\"2e3f*) \".g\"\"2g3h+?$!87?9*$$\"\" #\"#  +'%4\"6i\" %$\"#  \"#  "),
          peg$decode("!.j\"\"2j3k*) \".l\"\"2l3m+;$!87?9*$$\"\" #\"#  +#%'\"%$\"#  \"#  "),
          peg$decode("7!*\xB3 \"7\"*\xAD \"7#*\xA7 \"7$*\xA1 \"7%*\x9B \"7&*\x95 \"7'*\x8F \"7(*\x89 \"7)*\x83 \"7**} \"7+*w \"78*q \"79*k \"7,*e \"7-*_ \"7.*Y \"7/*S \"70*M \"71*G \"72*A \"73*; \"74*5 \"75*/ \"76*) \"77*# \"7:"),
          peg$decode("!!87;9*$$\"\" #\"#  +2$7=+(%4\"6n\"! %$\"#  \"#  "),
          peg$decode("!7>+;$ o7?,#&7?\"+)%4\"6p\"\"! %$\"#  \"#  "),
          peg$decode("0q\"\"1!3r"),
          peg$decode("7>*) \"0s\"\"1!3t"),
          peg$decode("!7A+;$ o7B,#&7B\"+)%4\"6u\"\"! %$\"#  \"#  "),
          peg$decode("0v\"\"1!3w"),
          peg$decode("7A*) \"0x\"\"1!3y"),
          peg$decode("! o7D+&$,#&7D\"\"\"  +' 4!6z!! %"),
          peg$decode("0{\"\"1!3|"),
          peg$decode("!0}\"\"1!3~+\x87$0\"\"1!3\x80+w%0\x81\"\"1!3\x82+g%0\x83\"\"1!3\x84+W%0\x85\"\"1!3\x86+G%0\x87\"\"1!3\x88+7%0\x89\"\"1!3\x8A+'%4'6\x8B' %$'#  $&#  $%#  $$#  $##  $\"#  \"#  "),
          peg$decode("0x\"\"1!3y"),
          peg$decode("!0\x8C\"\"1!3\x8D+B$ o7F+&$,#&7F\"\"\"  +)%4\"6\x8E\"\"! %$\"#  \"#  *# \"7F"),
          peg$decode("!0\x89\"\"1!3\x8A+X$0\x90\"\"1!3\x91*# \" \x8F+B% o7F+&$,#&7F\"\"\"  +)%4#6\x92#\"! %$##  $\"#  \"#  "),
          peg$decode("!.\x93\"\"2\x933\x94+A$ o7F+&$,#&7F\"\"\"  +(%4\"6\x95\"! %$\"#  \"#  "),
          peg$decode("!7G+J$7I*# \" \x8F+:%7H*# \" \x8F+*%4#6\x96##\"! %$##  $\"#  \"#  "),
          peg$decode("-\"\"1!3\x97"),
          peg$decode("0\x98\"\"1!3\x99"),
          peg$decode("0\x9A\"\"1!3\x9B"),
          peg$decode("7M*6 \"!8-\"\"1!3\x979*$$\"\" #\"#  "),
          peg$decode("! o7L,#&7L\"+-$7P+#%'\"%$\"#  \"#  *@ \"! o7L,#&7L\"+-$7N+#%'\"%$\"#  \"#  "),
          peg$decode("!.\x9C\"\"2\x9C3\x9D+\x85$ o!!87N9*$$\"\" #\"#  +-$7K+#%'\"%$\"#  \"#  ,F&!!87N9*$$\"\" #\"#  +-$7K+#%'\"%$\"#  \"#  \"+-%7N+#%'#%$##  $\"#  \"#  "),
          peg$decode("7R*# \"7S"),
          peg$decode("!.\x9E\"\"2\x9E3\x9F+\xA4$7T*# \" \x8F+\x94% o!!87U9*$$\"\" #\"#  +2$7K+(%4\"6\xA0\"! %$\"#  \"#  ,K&!!87U9*$$\"\" #\"#  +2$7K+(%4\"6\xA0\"! %$\"#  \"#  \"+2%7U+(%4$6\xA1$!!%$$#  $##  $\"#  \"#  "),
          peg$decode("!.\xA2\"\"2\xA23\xA3+\xA4$7T*# \" \x8F+\x94% o!!87V9*$$\"\" #\"#  +2$7K+(%4\"6\xA0\"! %$\"#  \"#  ,K&!!87V9*$$\"\" #\"#  +2$7K+(%4\"6\xA0\"! %$\"#  \"#  \"+2%7V+(%4$6\xA4$!!%$$#  $##  $\"#  \"#  "),
          peg$decode("! o7L,#&7L\"+-$7M+#%'\"%$\"#  \"#  "),
          peg$decode("!7M*# \" \x8F+3$.\x9E\"\"2\x9E3\x9F+#%'\"%$\"#  \"#  "),
          peg$decode("!7M*# \" \x8F+3$.\xA2\"\"2\xA23\xA3+#%'\"%$\"#  \"#  "),
          peg$decode("!.\xA5\"\"2\xA53\xA6+7$.\xA5\"\"2\xA53\xA6+'%4\"6\xA7\" %$\"#  \"#  *\xD2 \"!.\xA8\"\"2\xA83\xA9+7$.\xA8\"\"2\xA83\xA9+'%4\"6\xA7\" %$\"#  \"#  *\xA7 \"!.\xA5\"\"2\xA53\xA6+Q$ o7X+&$,#&7X\"\"\"  +8%.\xA5\"\"2\xA53\xA6+(%4#6\xAA#!!%$##  $\"#  \"#  *b \"!.\xA8\"\"2\xA83\xA9+Q$ o7Y+&$,#&7Y\"\"\"  +8%.\xA8\"\"2\xA83\xA9+(%4#6\xAB#!!%$##  $\"#  \"#  "),
          peg$decode("0\xAC\"\"1!3\xAD*# \"7Z"),
          peg$decode("0\xAE\"\"1!3\xAF*# \"7Z"),
          peg$decode("!.\xB0\"\"2\xB03\xB1+& 4!6\xB2! %*\xBE \"!.\xB3\"\"2\xB33\xB4+& 4!6\xB5! %*\xA7 \"!.\xB6\"\"2\xB63\xB7+& 4!6\xB8! %*\x90 \"!.\xB9\"\"2\xB93\xBA+& 4!6\xBB! %*y \"!.\xBC\"\"2\xBC3\xBD+& 4!6\xBE! %*b \"!.\xBF\"\"2\xBF3\xC0+& 4!6\xC1! %*K \"!.\xC2\"\"2\xC23\xC3+& 4!6\xC4! %*4 \"!.\xC5\"\"2\xC53\xC6+& 4!6\xC7! %"),
          peg$decode("70*# \"71"),
          peg$decode("!.\xC8\"\"2\xC83\xC9+& 4!6\xCA! %"),
          peg$decode("!.\xCB\"\"2\xCB3\xCC+& 4!6\xCD! %"),
          peg$decode("!.\xCE\"\"2\xCE3\xCF+& 4!6\xD0! %"),
          peg$decode("!.\xD1\"\"2\xD13\xD2+& 4!6\xD3! %"),
          peg$decode("!.\xD4\"\"2\xD43\xD5+& 4!6\xD6! %"),
          peg$decode("!.\xD7\"\"2\xD73\xD8+& 4!6\xD9! %"),
          peg$decode("!.\xD1\"\"2\xD13\xD2+& 4!6\xDA! %"),
          peg$decode("!.\xCE\"\"2\xCE3\xCF+& 4!6\xDB! %"),
          peg$decode("!.\xDC\"\"2\xDC3\xDD+& 4!6\xDE! %"),
          peg$decode("7)*) \"7]*# \"7\\"),
          peg$decode("79*/ \"78*) \"7**# \"7+"),
          peg$decode("7^*# \"7_"),
          peg$decode("7`*) \"7a*# \"7,"),
          peg$decode("7b*) \"7c*# \"7."),
          peg$decode("! o!7L+& 4!6\xDF! %*4 \"!7M*# \"7P+& 4!6\xE0! %,E&!7L+& 4!6\xDF! %*4 \"!7M*# \"7P+& 4!6\xE0! %\"+' 4!6\xE1!! %"),
          peg$decode("! o7L,#&7L\"+& 4!6\xDF! %"),
          peg$decode("!7j+2$7m+(%4\"6\xE2\"! %$\"#  \"#  "),
          peg$decode("! o7n,#&7n\"+' 4!6\xE3!! %"),
          peg$decode("!7p*# \"7\x8F+3$7j+)%4\"6\xE4\"\"! %$\"#  \"#  *s \"!7q+h$!7k+2$7p+(%4\"6\xE5\"! %$\"#  \"#  *. \"!7O+& 4!6\xE6! %+3%7j+)%4#6\xE7#\"\"!%$##  $\"#  \"#  "),
          peg$decode("7p*) \"7q*# \"7\x8F"),
          peg$decode("7r*/ \"7s*) \"7y*# \"7t"),
          peg$decode("7z*5 \"7\x80*/ \"7\x87*) \"7\x8A*# \"7\x8C"),
          peg$decode("!.\xE8\"\"2\xE83\xE9+\xA6$ o!!8.\xEA\"\"2\xEA3\xEB9*$$\"\" #\"#  +2$7K+(%4\"6\xA0\"! %$\"#  \"#  ,Q&!!8.\xEA\"\"2\xEA3\xEB9*$$\"\" #\"#  +2$7K+(%4\"6\xA0\"! %$\"#  \"#  \"+8%.\xEA\"\"2\xEA3\xEB+(%4#6\xEC#!!%$##  $\"#  \"#  "),
          peg$decode("!.\xED\"\"2\xED3\xEE+`$7E+V%7k+L%7@+B%7k+8%.\xEF\"\"2\xEF3\xF0+(%4&6\xF1&!\"%$&#  $%#  $$#  $##  $\"#  \"#  "),
          peg$decode("!.\xF2\"\"2\xF23\xF3+\x98$7j+\x8E%7u+\x84%7j+z% o!7x+2$7j+(%4\"6\xF4\"!!%$\"#  \"#  ,=&!7x+2$7j+(%4\"6\xF4\"!!%$\"#  \"#  \"+4%7w+*%4&6\xF5&##! %$&#  $%#  $$#  $##  $\"#  \"#  "),
          peg$decode("!.\xF6\"\"2\xF63\xF7+V$7j+L%7\x90+B%7j+8%.\xF8\"\"2\xF83\xF9+(%4%6\xFA%!\"%$%#  $$#  $##  $\"#  \"#  *# \"7@"),
          peg$decode("!.\xF6\"\"2\xF63\xF7+V$7j+L%7\x90+B%7j+8%.\xF8\"\"2\xF83\xF9+(%4%6\xFA%!\"%$%#  $$#  $##  $\"#  \"#  *# \"7C"),
          peg$decode("!.\xFB\"\"2\xFB3\xFC+& 4!6\xFD! %*4 \"!.\xEF\"\"2\xEF3\xF0+& 4!6\xFE! %"),
          peg$decode("!7v+m$!7k+L$.\xFF\"\"2\xFF3\u0100+<%7j+2%7\x90+(%4$6\u0101$! %$$#  $##  $\"#  \"#  *# \" \x8F+)%4\"6\u0102\"\"! %$\"#  \"#  "),
          peg$decode("!.\u0103\"\"2\u01033\u0104+V$7j+L%7u+B%7j+8%.\xEF\"\"2\xEF3\xF0+(%4%6\u0105%!\"%$%#  $$#  $##  $\"#  \"#  "),
          peg$decode("!7\"+\x8E$7k+\x84%7<+z%7k+p%7}*# \" \x8F+`%!7j+2$7{+(%4\"6\u0106\"! %$\"#  \"#  *# \" \x8F+6%7|+,%4'6\u0107'%&$\"! %$'#  $&#  $%#  $$#  $##  $\"#  \"#  "),
          peg$decode("!7:+<$7k+2%7\x90+(%4#6\xFA#! %$##  $\"#  \"#  "),
          peg$decode("!7j+<$7m+2%77+(%4#6\u0108#!!%$##  $\"#  \"#  "),
          peg$decode("!.\xF6\"\"2\xF63\xF7+V$7j+L%7~+B%7j+8%.\xF8\"\"2\xF83\xF9+(%4%6\u0109%!\"%$%#  $$#  $##  $\"#  \"#  *R \"!.\xF6\"\"2\xF63\xF7+A$7j+7%.\xF8\"\"2\xF83\xF9+'%4#6\u010A# %$##  $\"#  \"#  "),
          peg$decode("!7+\xA3$ o!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7+(%4$6\u010D$! %$$#  $##  $\"#  \"#  ,W&!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7+(%4$6\u010D$! %$$#  $##  $\"#  \"#  \"+)%4\"6\u010E\"\"! %$\"#  \"#  "),
          peg$decode("!7<+' 4!6\u010F!! %*r \"!7\x90+g$!7k+F$74+<%7k+2%7<+(%4$6\u0110$! %$$#  $##  $\"#  \"#  *# \" \x8F+)%4\"6\u0111\"\"! %$\"#  \"#  "),
          peg$decode("!7#+f$7k+\\%7\x81+R%7j+H%7$+>%7k+4%7\x83+*%4'6\u0112'#&$ %$'#  $&#  $%#  $$#  $##  $\"#  \"#  *H \"!7$+=$7k+3%7\x85+)%4#6\u0113#\"\" %$##  $\"#  \"#  "),
          peg$decode("!7\x82+{$ o!.\x93\"\"2\x933\x94+2$7\x82+(%4\"6\u0114\"! %$\"#  \"#  ,C&!.\x93\"\"2\x933\x94+2$7\x82+(%4\"6\u0114\"! %$\"#  \"#  \"+)%4\"6\u0115\"\"! %$\"#  \"#  "),
          peg$decode("!!87;9*$$\"\" #\"#  +2$7=+(%4\"6\u0116\"! %$\"#  \"#  "),
          peg$decode("!7\x84+\xA3$ o!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7\x84+(%4$6\u0114$! %$$#  $##  $\"#  \"#  ,W&!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7\x84+(%4$6\u0114$! %$$#  $##  $\"#  \"#  \"+)%4\"6\u0117\"\"! %$\"#  \"#  "),
          peg$decode("!7<+g$!7k+F$74+<%7k+2%7<+(%4$6\u0110$! %$$#  $##  $\"#  \"#  *# \" \x8F+)%4\"6\u0118\"\"! %$\"#  \"#  "),
          peg$decode("!7\x86+\xA3$ o!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7\x86+(%4$6\u0119$! %$$#  $##  $\"#  \"#  ,W&!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7\x86+(%4$6\u0119$! %$$#  $##  $\"#  \"#  \"+)%4\"6\u0117\"\"! %$\"#  \"#  "),
          peg$decode("!7\x81+g$!7k+F$74+<%7k+2%7<+(%4$6\u0110$! %$$#  $##  $\"#  \"#  *# \" \x8F+)%4\"6\u011A\"\"! %$\"#  \"#  "),
          peg$decode("!7!+]$7k+S%7\x88+I%7j+?%7m+5%7\x8B++%4&6\u011B&$%#! %$&#  $%#  $$#  $##  $\"#  \"#  "),
          peg$decode("!7\x89+\xA3$ o!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7\x89+(%4$6\u011C$! %$$#  $##  $\"#  \"#  ,W&!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7\x89+(%4$6\u011C$! %$$#  $##  $\"#  \"#  \"+)%4\"6\u0117\"\"! %$\"#  \"#  "),
          peg$decode("!7<+|$7k+r%75+h%7j+^%7\x90+T%!7j+2$7{+(%4\"6\u0106\"! %$\"#  \"#  *# \" \x8F+*%4&6\u011D&#%! %$&#  $%#  $$#  $##  $\"#  \"#  "),
          peg$decode("!7[+]$7k+S%7\x90+I%7j+?%7m+5%7\x8B++%4&6\u011E&$%#! %$&#  $%#  $$#  $##  $\"#  \"#  "),
          peg$decode("!76+<$7k+2%7\x8A+(%4#6\u011F#! %$##  $\"#  \"#  *b \"!76+F$7j+<%7m+2%77+(%4$6\u0108$!!%$$#  $##  $\"#  \"#  *. \"!77+& 4!6\u0120! %"),
          peg$decode("!7&+=$7k+3%7\x8D+)%4#6\u0121#\"\" %$##  $\"#  \"#  "),
          peg$decode("!7\x8E+\xA3$ o!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7\x8E+(%4$6\xF4$! %$$#  $##  $\"#  \"#  ,W&!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7\x8E+(%4$6\xF4$! %$$#  $##  $\"#  \"#  \"+)%4\"6\u0117\"\"! %$\"#  \"#  "),
          peg$decode("!7<+W$7k+M%.\xFF\"\"2\xFF3\u0100+=%7j+3%7\x90+)%4%6\u0122%\"$ %$%#  $$#  $##  $\"#  \"#  "),
          peg$decode("!7\x90+' 4!6\u0123!! %"),
          peg$decode("!7\x91+\xA3$ o!7k+L$.\u0124\"\"2\u01243\u0125+<%7j+2%7\x91+(%4$6\xA0$! %$$#  $##  $\"#  \"#  ,W&!7k+L$.\u0124\"\"2\u01243\u0125+<%7j+2%7\x91+(%4$6\xA0$! %$$#  $##  $\"#  \"#  \"+)%4\"6\u0126\"\"! %$\"#  \"#  "),
          peg$decode("!7\x92+{$7k+q%7[+g%7j+]%7\x92+S%7j+I%76+?%7j+5%7\x91++%4)6\u0127)$(&$ %$)#  $(#  $'#  $&#  $%#  $$#  $##  $\"#  \"#  *# \"7\x92"),
          peg$decode("!7\x93+\x99$ o!7k+G$7(+=%7j+3%7\x93+)%4$6\u0128$\"\" %$$#  $##  $\"#  \"#  ,R&!7k+G$7(+=%7j+3%7\x93+)%4$6\u0128$\"\" %$$#  $##  $\"#  \"#  \"+)%4\"6\u0129\"\"! %$\"#  \"#  "),
          peg$decode("!7\x94+\x99$ o!7k+G$7'+=%7j+3%7\x94+)%4$6\u0128$\"\" %$$#  $##  $\"#  \"#  ,R&!7k+G$7'+=%7j+3%7\x94+)%4$6\u0128$\"\" %$$#  $##  $\"#  \"#  \"+)%4\"6\u0129\"\"! %$\"#  \"#  "),
          peg$decode("!7\x95+\x99$ o!7k+G$7e+=%7j+3%7\x95+)%4$6\u0128$\"\" %$$#  $##  $\"#  \"#  ,R&!7k+G$7e+=%7j+3%7\x95+)%4$6\u0128$\"\" %$$#  $##  $\"#  \"#  \"+)%4\"6\u0129\"\"! %$\"#  \"#  "),
          peg$decode("!7\x96+\x99$ o!7k+G$7f+=%7j+3%7\x96+)%4$6\u0128$\"\" %$$#  $##  $\"#  \"#  ,R&!7k+G$7f+=%7j+3%7\x96+)%4$6\u0128$\"\" %$$#  $##  $\"#  \"#  \"+)%4\"6\u0129\"\"! %$\"#  \"#  "),
          peg$decode("!7\x97+\x99$ o!7k+G$7g+=%7j+3%7\x97+)%4$6\u0128$\"\" %$$#  $##  $\"#  \"#  ,R&!7k+G$7g+=%7j+3%7\x97+)%4$6\u0128$\"\" %$$#  $##  $\"#  \"#  \"+)%4\"6\u0129\"\"! %$\"#  \"#  "),
          peg$decode("!7\x98+\x99$ o!7k+G$7h+=%7j+3%7\x98+)%4$6\u0128$\"\" %$$#  $##  $\"#  \"#  ,R&!7k+G$7h+=%7j+3%7\x98+)%4$6\u0128$\"\" %$$#  $##  $\"#  \"#  \"+)%4\"6\u0129\"\"! %$\"#  \"#  "),
          peg$decode("!7i+=$7k+3%7\x98+)%4#6\u012A#\"\" %$##  $\"#  \"#  *# \"7\x99"),
          peg$decode("!7d+=$7k+3%7\x9A+)%4#6\u012B#\"\" %$##  $\"#  \"#  *# \"7\x9A"),
          peg$decode("!7\xA8+=$7k+3%7\x9F+)%4#6\u012C#\"\" %$##  $\"#  \"#  *# \"7\x9B"),
          peg$decode("!7\x9E+o$ o!7k+2$7\x9C+(%4\"6\u012D\"! %$\"#  \"#  ,=&!7k+2$7\x9C+(%4\"6\u012D\"! %$\"#  \"#  \"+)%4\"6\u0129\"\"! %$\"#  \"#  "),
          peg$decode("!.\x93\"\"2\x933\x94+<$7j+2%7<+(%4#6\u012E#! %$##  $\"#  \"#  *y \"!.\u012F\"\"2\u012F3\u0130+V$7j+L%7\x90+B%7j+8%.\u0131\"\"2\u01313\u0132+(%4%6\u0133%!\"%$%#  $$#  $##  $\"#  \"#  */ \"!7\x9D+' 4!6\u0134!! %"),
          peg$decode("!.\xF6\"\"2\xF63\xF7+V$7j+L%7\xA5+B%7j+8%.\xF8\"\"2\xF83\xF9+(%4%6\u0135%!\"%$%#  $$#  $##  $\"#  \"#  *R \"!.\xF6\"\"2\xF63\xF7+A$7j+7%.\xF8\"\"2\xF83\xF9+'%4#6\u0136# %$##  $\"#  \"#  "),
          peg$decode("7\x9F*# \"7\xA6"),
          peg$decode("!.\u012F\"\"2\u012F3\u0130+V$7j+L%7\xA2+B%7j+8%.\u0131\"\"2\u01313\u0132+(%4%6\u0137%!\"%$%#  $$#  $##  $\"#  \"#  *\xE6 \"!.\u012F\"\"2\u012F3\u0130+V$7j+L%7\xA5+B%7j+8%.\u0131\"\"2\u01313\u0132+(%4%6\u0138%!\"%$%#  $$#  $##  $\"#  \"#  *\x9C \"!.\u012F\"\"2\u012F3\u0130+V$7j+L%7\xA0+B%7j+8%.\u0131\"\"2\u01313\u0132+(%4%6\u0139%!\"%$%#  $$#  $##  $\"#  \"#  *R \"!.\u012F\"\"2\u012F3\u0130+A$7j+7%.\u0131\"\"2\u01313\u0132+'%4#6\u013A# %$##  $\"#  \"#  "),
          peg$decode("!7\xA1+\xA3$ o!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7\xA1+(%4$6\xF4$! %$$#  $##  $\"#  \"#  ,W&!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7\xA1+(%4$6\xF4$! %$$#  $##  $\"#  \"#  \"+)%4\"6\u0117\"\"! %$\"#  \"#  "),
          peg$decode("!7<+W$7k+M%.\xFF\"\"2\xFF3\u0100+=%7j+3%7\x90+)%4%6\u013B%\"$ %$%#  $$#  $##  $\"#  \"#  *b \"!7\x90+W$7k+M%.\u013C\"\"2\u013C3\u013D+=%7j+3%7\x90+)%4%6\u013E%\"$ %$%#  $$#  $##  $\"#  \"#  "),
          peg$decode("7\xA3*# \"7\xA4"),
          peg$decode("!7\x90+R$7j+H%7!+>%7j+4%7\x88+*%4%6\u013F%#$\" %$%#  $$#  $##  $\"#  \"#  "),
          peg$decode("!7\xA1+R$7j+H%7!+>%7j+4%7\x88+*%4%6\u0140%#$\" %$%#  $$#  $##  $\"#  \"#  "),
          peg$decode("!7\x90+\xA3$ o!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7\x90+(%4$6\u0101$! %$$#  $##  $\"#  \"#  ,W&!7k+L$.\u010B\"\"2\u010B3\u010C+<%7j+2%7\x90+(%4$6\u0101$! %$$#  $##  $\"#  \"#  \"+)%4\"6\u0117\"\"! %$\"#  \"#  "),
          peg$decode("!.\xF6\"\"2\xF63\xF7+V$7j+L%7\x90+B%7j+8%.\xF8\"\"2\xF83\xF9+(%4%6\xFA%!\"%$%#  $$#  $##  $\"#  \"#  *# \"7\xA7"),
          peg$decode("7J*; \"7\xA8*5 \"7\xA9*/ \"7\xAA*) \"7\xAB*# \"7\xAC"),
          peg$decode("7Q*# \"7W"),
          peg$decode("!72+& 4!6\u0141! %*. \"!73+& 4!6\u0142! %"),
          peg$decode("!7<+' 4!6\u0143!! %"),
          peg$decode("!7-+' 4!6\u0144!! %"),
          peg$decode("!7/+' 4!6\u0145!! %")
        ],

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleIndices)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$decode(s) {
      var bc = new Array(s.length), i;

      for (i = 0; i < s.length; i++) {
        bc[i] = s.charCodeAt(i) - 32;
      }

      return bc;
    }

    function peg$parseRule(index) {
      var bc    = peg$bytecode[index],
          ip    = 0,
          ips   = [],
          end   = bc.length,
          ends  = [],
          stack = [],
          params, i;

      function protect(object) {
        return Object.prototype.toString.apply(object) === "[object Array]" ? [] : object;
      }

      while (true) {
        while (ip < end) {
          switch (bc[ip]) {
            case 0:
              stack.push(protect(peg$consts[bc[ip + 1]]));
              ip += 2;
              break;

            case 1:
              stack.push(peg$currPos);
              ip++;
              break;

            case 2:
              stack.pop();
              ip++;
              break;

            case 3:
              peg$currPos = stack.pop();
              ip++;
              break;

            case 4:
              stack.length -= bc[ip + 1];
              ip += 2;
              break;

            case 5:
              stack.splice(-2, 1);
              ip++;
              break;

            case 6:
              stack[stack.length - 2].push(stack.pop());
              ip++;
              break;

            case 7:
              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
              ip += 2;
              break;

            case 8:
              stack.pop();
              stack.push(input.substring(stack[stack.length - 1], peg$currPos));
              ip++;
              break;

            case 9:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1]) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 10:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] === peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 11:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] !== peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 12:
              if (stack[stack.length - 1] !== peg$FAILED) {
                ends.push(end);
                ips.push(ip);

                end = ip + 2 + bc[ip + 1];
                ip += 2;
              } else {
                ip += 2 + bc[ip + 1];
              }

              break;

            case 13:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (input.length > peg$currPos) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 14:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 15:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 16:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 17:
              stack.push(input.substr(peg$currPos, bc[ip + 1]));
              peg$currPos += bc[ip + 1];
              ip += 2;
              break;

            case 18:
              stack.push(peg$consts[bc[ip + 1]]);
              peg$currPos += peg$consts[bc[ip + 1]].length;
              ip += 2;
              break;

            case 19:
              stack.push(peg$FAILED);
              if (peg$silentFails === 0) {
                peg$fail(peg$consts[bc[ip + 1]]);
              }
              ip += 2;
              break;

            case 20:
              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];
              ip += 2;
              break;

            case 21:
              peg$reportedPos = peg$currPos;
              ip++;
              break;

            case 22:
              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
              for (i = 0; i < bc[ip + 3]; i++) {
                params[i] = stack[stack.length - 1 - params[i]];
              }

              stack.splice(
                stack.length - bc[ip + 2],
                bc[ip + 2],
                peg$consts[bc[ip + 1]].apply(null, params)
              );

              ip += 4 + bc[ip + 3];
              break;

            case 23:
              stack.push(peg$parseRule(bc[ip + 1]));
              ip += 2;
              break;

            case 24:
              peg$silentFails++;
              ip++;
              break;

            case 25:
              peg$silentFails--;
              ip++;
              break;

            default:
              throw new Error("Invalid opcode: " + bc[ip] + ".");
          }
        }

        if (ends.length > 0) {
          end = ends.pop();
          ip = ips.pop();
        } else {
          break;
        }
      }

      return stack[0];
    }


      var parser = require('../lib/compiler/parser');
      var buildBinaryChain = parser.buildBinaryChain;
      var hasOperator = parser.hasOperator;
      var changeOperator = parser.changeOperator;
      var symInterpolate = parser.symInterpolate;
      var isInterpolated = parser.isInterpolated;
      var isIdentifier = parser.isIdentifier;
      var stmts = parser.stmts;

      function sym(value, type) {
        return {
          value: value,
          type: type || 'op',
          line: line(),
          column: column()
        };
      }


    peg$result = peg$parseRule(peg$startRuleIndex);

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();

},{"../lib/compiler/parser":8}],4:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var util = require('../util');

function isAnnotations(node) {
  return typeof node === 'object' && node !== null && node.__intAnnotations;
}

function createAnnotations() {
  return {
    __intAnnotations: true
  };
}

function getAnnotations(node) {
  if ( isAnnotations(node) ) {
    return node;
  }

  var annotations = node.annotations;
  if ( !annotations ) {
    annotations = node.annotations = createAnnotations();
  }
  return annotations;
}

function annotate(node, group, name) {
  var annotations = getAnnotations(node);
  var groupObject = annotations[group];
  if ( !groupObject ) {
    groupObject = annotations[group] = {};
  }
  groupObject[name] = true;
}

function hasAnnotation(node, group, name) {
  var annotations = getAnnotations(node);
  var groupObject = annotations[group];
  if ( !groupObject ) {
    return false;
  }
  return groupObject[name];
}

// Exported Functions
exports.isAnnotations = isAnnotations;
exports.createAnnotations = createAnnotations;
exports.getAnnotations = getAnnotations;
exports.annotate = annotate;
exports.hasAnnotation = hasAnnotation;

},{"../util":24}],5:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var annotations = require('./annotations');
var util = require('../util');

var getAnnotations = annotations.getAnnotations;
var hasAnnotation = annotations.hasAnnotation;

var isArray = util.isArray;
var objectKeys = util.objectKeys;
var each = util.each;
var map = util.map;

var slice = Array.prototype.slice;

var languages = {
  'javascript': require('./javascript')
};

function resolveTargetLanguage(targetLanguage) {
  var lang = languages[targetLanguage];
  if ( lang ) {
    return lang;
  }
  throw new Error("Unsupported Target Language: " + targetLanguage);
}

/**
 * Converts a parse tree into source code (initially JavaScript) that can
 * be pulled into an Interpol Runtime instance.  Host Language-specific
 * constructs are avoided here and instead produced by JavaScript code
 * generation module.
 *
 * @param {Object} strippedTree the parse tree to use (rewritten & stripped)
 * @param {Mixed[]} literals A table of literal values
 * @param {Object} [options] Options used by Interpol or its CLI
 */
function generateModuleBody(strippedTree, literals, options) {
  options = options || {};
  var sharedGlobals = !!options.globals;
  var functionWrapper = options.functionWrapper || noWrapper;
  var targetLanguage = options.targetLanguage || 'javascript';
  var lang = resolveTargetLanguage(targetLanguage);

  var globals = options.globals || lang.createGlobals();
  var gen = lang.createModule(globals);

  // A lookup table of code generators
  var Evaluators = {
    'im': createImportEvaluator,
    'de': createPartialEvaluator,
    'bi': createBindEvaluator,
    'ca': createCallEvaluator,
    'as': createAssignEvaluator,
    'op': createOpenTagEvaluator,
    'cl': createCloseTagEvaluator,
    'ct': createCommentTagEvaluator,
    'dt': createDocTypeEvaluator,
    'ou': createOutputEvaluator,
    'ra': createRawOutputEvaluator,
    'lc': createListCompEvaluator,
    'fr': createForEvaluator,
    'cn': createTernaryEvaluator,
    'if': createIfEvaluator,
    'or': createOrEvaluator,
    'an': createAndEvaluator,
    'eq': createEqEvaluator,
    'ma': createMatchEvaluator,
    'nq': createNeqEvaluator,
    'gt': createGtEvaluator,
    'lt': createLtEvaluator,
    'ge': createGteEvaluator,
    'le': createLteEvaluator,
    'ad': createAddEvaluator,
    'su': createSubEvaluator,
    'mu': createMulEvaluator,
    'di': createDivEvaluator,
    'mo': createModEvaluator,
    'fm': createFormatEvaluator,
    'no': createNotEvaluator,
    'ne': createNegEvaluator,
    'po': createPosEvaluator,
    'mb': createMemberEvaluator,
    'ar': createArrayEvaluator,
    'dc': createDictionaryEvaluator,
    'id': createIdEvaluator,
    'se': createSelfEvaluator
  };

  // Attach annotation retriever to create functions
  each(objectKeys(Evaluators), function (funcName) {
    var func = Evaluators[funcName];
    func.getAnnotations = function (args) {
      return args[func.length] || {};
    };
  });

  return functionWrapper(function () {
    createModuleFunction(strippedTree);
    var body = gen.toString();

    var buffer = [];
    if ( !sharedGlobals ) {
      buffer.push(globals.toString());
    }
    buffer.push(body);

    return buffer.join('');
  });

  function createModuleFunction(parseTree) {
    var defineModule = globals.runtimeImport('defineModule');

    gen.returnStatement(function () {
      gen.call(defineModule, [
        function () {
          gen.func(['c', 'w'], function () {
            // createStatementsEvaluator will populate globalVars
            createStatementsEvaluator(parseTree);
          }, getAnnotations(parseTree));
        }
      ]);
    });
  }

  function noWrapper(value) {
    return value();
  }

  function defer(func) {
    var args;
    if ( typeof func === 'function' ) {
      args = slice.call(arguments, 1);
    }
    else {
      args = slice.call(arguments, 0);
      func = createEvaluator;
    }

    return function () {
       return func.apply(null, args);
    };
  }

  /**
   * The busiest function in the code generator.  createEvaluator
   * resolves the evaluator generation function to use by taking the
   * first element of the node array.  It then passes the rest of the
   * node's elements as arguments to that generation function.
   *
   * @param {Array|Number} node Either an Array or a Literal Id
   */
  function createEvaluator(node) {
    if ( !isArray(node) ) {
      /* istanbul ignore if: untestable */
      if ( node === null || node === undefined ) {
        throw new Error("Null Node in Parse Tree");
      }
      var literal = globals.literal(literals[node]);
      gen.write(literal);
      return;
    }

    var nodeType = literals[node[0]];
    var createFunction = Evaluators[nodeType];

    /* istanbul ignore if: untestable */
    if ( !createFunction ) {
      throw new Error("Invalid Node in Parse Tree: " + nodeType);
    }

    // attach annotations just beyond the last known argument
    var args = node.slice(1);
    args[createFunction.length] = getAnnotations(node);
    createFunction.apply(node, args);
  }

  function createBinaryEvaluator(operator, leftNode, rightNode) {
    gen.binaryOperator(operator, defer(leftNode), defer(rightNode));
  }

  function createStatementsEvaluator(statementNodes) {
    each(statementNodes, createEvaluator);
  }

  // generate an evaluator to deal with 'from' and 'import' statements
  function createImportEvaluator(fromNodes) {
    var assigns = [];
    each(fromNodes, function (fromNode) {
      var moduleName = literals[fromNode[0]];
      var moduleNameId = globals.literal(moduleName);
      var importer = globals.builder('importer', moduleNameId);

      var aliases = fromNode[1];
      if ( !isArray(aliases) ) {
        var moduleAlias;
        if ( typeof aliases === 'number' ) {
          moduleAlias = literals[aliases];
        }
        else {
          moduleAlias = moduleName.split('/').pop();
        }
        assigns.push([
          moduleAlias,
          function () {
            gen.call(importer, []);
          }
        ]);
        return;
      }

      var toResolve = map(aliases, function (importInfo) {
        var name = literals[importInfo[0]];
        var alias = importInfo[1] ? literals[importInfo[1]] : name;
        return [alias, name];
      });

      var getProperty = globals.runtimeImport('getProperty');
      var anon = gen.anonymous();
      assigns.push([
        anon,
        function () {
          gen.call(importer, []);
        }
      ]);
      each(toResolve, function (aliasMap) {
        assigns.push([
          aliasMap[0],
          function () {
            gen.call(
              getProperty,
              [
                function () { gen.anonymous(anon); },
                globals.literal(aliasMap[1])
              ]
            );
          }
        ]);
      });
    });
    gen.assignments(assigns);
  }

  // generate an evaluator to represent a partial and its associated closure
  function createPartialEvaluator(nameLiteral, paramDefs,
                                  statementNodes, guardNode) {
    var annotations = createPartialEvaluator.getAnnotations(arguments);
    var partialName = literals[nameLiteral];
    var paramNames = map(paramDefs, function (paramDef) {
      return literals[paramDef];
    });
    var create = guardNode ? createGuardedPartial : createUnguardedPartial;
    create();

    function createUnguardedPartial() {
      var definePartial = globals.runtimeImport('definePartial');
      gen.call(definePartial, [
        function () {
          gen.func(
            [gen.writer()],
            paramNames,
            defer(createStatementsEvaluator, statementNodes),
            annotations
          );
        }
      ]);
    }

    function createGuardedPartial() {
      var definePartial = globals.runtimeImport('defineGuardedPartial');
      gen.call(definePartial, [
        gen.code(function () {
          gen.getter(partialName);
        }),
        createWrapper
      ]);

      function createWrapper() {
        gen.func(['o'], function () {
          gen.returnStatement(createFunction);
        }, annotations);
      }

      function createFunction() {
        gen.func(
          [gen.writer()],
          paramNames,
          createProlog,
          defer(createStatementsEvaluator, statementNodes),
          annotations
        );
      }

      function createProlog() {
        gen.ifStatement(
          defer(guardNode),
          null,  // this is an 'else' case
          function () {
            gen.returnStatement(function () {
              gen.call('o');
            });
          }
        );
      }
    }
  }

  // generate a bound call evaluator
  function createBindEvaluator(memberNode, argNodes) {
    var bindPartial = globals.runtimeImport('bindPartial');
    var member = defer(memberNode);
    var args = defer(createArrayEvaluator, argNodes);
    gen.call(bindPartial, [gen.self, member, args]);
  }

  // generate an evaluator to perform a function or partial call
  function createCallEvaluator(memberNode, argNodes) {
    var exec = globals.runtimeImport('exec');
    var member = defer(memberNode);

    var args = [gen.writer()];
    each(argNodes, function (argNode) {
      args.push(defer(argNode));
    });

    gen.call(exec, [gen.self, member, defer(gen.vector, args)]);
  }

  // generate an evaluator to perform local variable assignment
  function createAssignEvaluator(assignmentDefs) {
    var decls = map(assignmentDefs, function (assignmentDef) {
      return [
        literals[assignmentDef[0]],
        defer(assignmentDef[1])
      ];
    });
    gen.assignments(decls);
  }

  // generate an evaluator to write an html opening tag
  function createOpenTagEvaluator(nameNode, attributeDefs, selfClose) {
    var name = defer(nameNode);
    var attributes = defer(createDictionaryEvaluator, attributeDefs, true);
    var methodName = selfClose ? 'selfCloseElement' : 'startElement';
    gen.statement(function () {
      gen.call(gen.writer(methodName), [name, attributes]);
    });
  }

  // generate an evaluator to write an html closing tag
  function createCloseTagEvaluator(nameNode) {
    gen.statement(function () {
      gen.call(gen.writer('endElement'), [defer(nameNode)]);
    });
  }

  // generate an evaluator to write an html comment
  function createCommentTagEvaluator(contentLiteral) {
    gen.statement(function () {
      gen.call(gen.writer('comment'), [defer(contentLiteral)]);
    });
  }

  // generate an evaluator to write an html5 doctype
  function createDocTypeEvaluator(rootElemLiteral) {
    gen.statement(function () {
      gen.call(gen.writer('docType'), [defer(rootElemLiteral)]);
    });
  }

  // generate an evaluator that writes the result of an expression
  function createOutputEvaluator(exprNode) {
    gen.statement(function () {
      gen.call(gen.writer('content'), [defer(exprNode)]);
    });
  }

  // generate an evaluator that writes the result of an
  // expression without escaping
  function createRawOutputEvaluator(exprNode) {
    gen.statement(function () {
      gen.call(gen.writer('raw'), [defer(exprNode)]);
    });
  }

  // generate an evaluator that performs list comprehensions
  function createListCompEvaluator(rangeNodes, valueNode, nameNode) {
    var annotations = createListCompEvaluator.getAnnotations(arguments);
    var isDictionary = !!nameNode;
    var genContainer = isDictionary ? gen.dictionary : gen.vector;
    var createBody = isDictionary ? createNameValueBody: createValueBody;
    var listVar;

    gen.compoundExpression(function () {
      listVar = gen.anonymous();
      gen.assignments([
        [listVar, defer(function () {
          genContainer([]);
        })]
      ]);
      createLoopEvaluator(rangeNodes, createBody);
      gen.returnStatement(listVar);
    }, annotations);

    function createValueBody() {
      gen.vectorAppend(listVar, defer(valueNode));
    }

    function createNameValueBody() {
      gen.dictionarySet(listVar, defer(nameNode), defer(valueNode));
    }
  }

  // generate an evaluator that performs for looping over ranges
  function createForEvaluator(rangeNodes, statementNodes, elseNodes) {
    var annotations = createForEvaluator.getAnnotations(arguments);
    var createSub = hasAnnotation(annotations, 'self', 'read');
    var successVar;

    if ( elseNodes && elseNodes.length ) {
      successVar = gen.anonymous();
      gen.assignments([
        [successVar, globals.literal(false)]
      ]);
      createLoopEvaluator(rangeNodes, createBody, createSub, successVar);
      gen.ifStatement(
        function () { gen.anonymous(successVar); },
        null,
        defer(createStatementsEvaluator, elseNodes)
      );
    }
    else {
      createLoopEvaluator(rangeNodes, createBody, createSub);
    }

    function createBody() {
      createStatementsEvaluator(statementNodes);
    }
  }

  function createLoopEvaluator(rangeNodes, createBody, createSub, successVar) {
    if ( !createSub ) {
      processRange(0);
      return;
    }

    gen.statement(function () {
      gen.subcontext(
        function () {
          processRange(0);
        },
        annotations
      );
    });

    function processRange(i) {
      if ( i === rangeNodes.length ) {
        if ( successVar ) {
          gen.anonymous(successVar, globals.literal(true));
        }
        createBody();
        return;
      }

      var rangeNode = rangeNodes[i];
      var itemName = literals[rangeNode[0]];
      var prolog;

      if ( rangeNode[2] ) {
        // We have a guard
        prolog = function () {
          gen.ifStatement(
            defer(rangeNode[2]),
            null,
            function () {
              gen.returnStatement();
            }
          );
        };
      }

      gen.loopStatement(
        itemName,
        defer(rangeNode[1]),
        prolog,
        function () {
          processRange(i + 1);
        },
        annotations
      );
    }
  }

  // generate a conditional (ternary) evaluator
  function createTernaryEvaluator(conditionNode, trueNode, falseNode) {
    gen.conditionalOperator(
      defer(conditionNode),
      defer(trueNode),
      defer(falseNode)
    );
  }

  // generate an if statement evaluator
  function createIfEvaluator(conditionNode, trueNodes, falseNodes) {
    gen.ifStatement(
      defer(conditionNode),
      trueNodes.length ? defer(createStatementsEvaluator, trueNodes) : null,
      falseNodes.length ? defer(createStatementsEvaluator, falseNodes) : null
    );
  }

  // generate an 'or' evaluator
  function createOrEvaluator(leftNode, rightNode) {
    createTernaryEvaluator(leftNode, leftNode, rightNode);
  }

  // generate an 'and' evaluator
  function createAndEvaluator(leftNode, rightNode) {
    createTernaryEvaluator(leftNode, rightNode, leftNode);
  }

  // generate a match evaluator
  function createMatchEvaluator(leftNode, rightNode) {
    var left = defer(leftNode);
    var right = defer(rightNode);
    if ( !isArray(rightNode) ) {
      var matcher = globals.builder('matcher', gen.code(right));
      gen.call(matcher, [left]);
      return;
    }

    var isMatchingObject = globals.runtimeImport('matches');
    gen.call(isMatchingObject, [right, left]);
  }

  // generate an equality evaluator
  function createEqEvaluator(leftNode, rightNode) {
    createBinaryEvaluator('eq', leftNode, rightNode);
  }

  // generate an inequality evaluator
  function createNeqEvaluator(leftNode, rightNode) {
    createBinaryEvaluator('neq', leftNode, rightNode);
  }

  // generate a greater-than evaluator
  function createGtEvaluator(leftNode, rightNode) {
    createBinaryEvaluator('gt', leftNode, rightNode);
  }

  // generate a greater-than or equal to evaluator
  function createGteEvaluator(leftNode, rightNode) {
    createBinaryEvaluator('ge', leftNode, rightNode);
  }

  // generate a less-than evaluator
  function createLtEvaluator(leftNode, rightNode) {
    createBinaryEvaluator('lt', leftNode, rightNode);
  }

  // generate a less-than or equal to evaluator
  function createLteEvaluator(leftNode, rightNode) {
    createBinaryEvaluator('le', leftNode, rightNode);
  }

  // generate an addition evaluator
  function createAddEvaluator(leftNode, rightNode) {
    createBinaryEvaluator('add', leftNode, rightNode);
  }

  // generate a subtraction evaluator
  function createSubEvaluator(leftNode, rightNode) {
    createBinaryEvaluator('sub', leftNode, rightNode);
  }

  // generate a multiplication evaluator
  function createMulEvaluator(leftNode, rightNode) {
    createBinaryEvaluator('mul', leftNode, rightNode);
  }

  // generate a division evaluator
  function createDivEvaluator(leftNode, rightNode) {
    createBinaryEvaluator('div', leftNode, rightNode);
  }

  // generate a remainder evaluator
  function createModEvaluator(leftNode, rightNode) {
    createBinaryEvaluator('mod', leftNode, rightNode);
  }

  // generate an interpolation evaluator
  function createFormatEvaluator(formatLit, supportDictNode, exprNode) {
    var formatStr = gen.code(defer(formatLit));
    var supportDict = gen.code(defer(supportDictNode));

    var deferred = !exprNode;
    var funcName = deferred ? 'deferredFormatter' : 'immediateFormatter';
    var formatter;
    var args = [];

    if ( !isArray(supportDictNode) ) {
      // Meaning it has been created globally
      formatter = globals.builder(funcName, formatStr, supportDict);
      if ( deferred ) {
        gen.write(formatter);
        return;
      }
    }
    else {
      // Meaning we have to feed it supportFunctions at instantiation
      formatter = globals.builder(funcName, formatStr);
      args.push(supportDict);
      if ( deferred ) {
        gen.call(formatter, args);
        return;
      }
    }

    args.push(defer(exprNode));
    gen.call(formatter, args);
  }

  // generate a logical 'not' evaluator
  function createNotEvaluator(node) {
    var isTruthy = globals.runtimeImport('isTruthy');
    gen.unaryOperator('not', function () {
      gen.call(isTruthy, [defer(node)]);
    });
  }

  // generate a mathematical negation evaluator
  function createNegEvaluator(node) {
    gen.unaryOperator('neg', defer(node));
  }
  
  // generate a mathematical positive evaluator
  function createPosEvaluator(node) {
    gen.unaryOperator('pos', defer(node));
  }

  // generate an array or object member access evaluator
  function createMemberEvaluator(parentNode, elemNodes) {
    var getMember = elemNodes.length === 1 ? 'getProperty' : 'getPath';
    var args = [defer(parentNode)].concat(map(elemNodes, defer));
    gen.call(globals.runtimeImport(getMember), args);
  }

  // generate an array evaluator
  function createArrayEvaluator(arrayNodes) {
    gen.vector(map(arrayNodes, defer));
  }

  // generate a dictionary evaluator
  function createDictionaryEvaluator(propertyDefs, ordered) {
    var result = map(propertyDefs, function (propertyDef) {
      var name;
      if ( isArray(propertyDef[0]) ) {
        name = defer(propertyDef[0]);
      }
      else {
        name = literals[propertyDef[0]];
      }
      return [name, defer(propertyDef[1])];
    });
    gen.dictionary(result, ordered);
  }

  // generate a local variable retrieval evaluator
  function createIdEvaluator(nameLiteral) {
    gen.getter(literals[nameLiteral]);
  }

  function createSelfEvaluator() {
    gen.self();
  }
}

// Exported Functions
exports.generateModuleBody = generateModuleBody;

},{"../util":24,"./annotations":4,"./javascript":7}],6:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var vm = require('vm');

var util = require('../util');
var types = require('../types');
var parser = require('./parser');
var rewriter = require('./rewriter');
var codegen = require('./codegen');
var compilerStub = require('./stub');

var parseTemplate = parser.parseTemplate;
var rewriteSyntaxTree = rewriter.rewriteSyntaxTree;
var generateModuleBody = codegen.generateModuleBody;

var isArray = util.isArray;
var mixin = util.mixin;
var selfMap = util.selfMap;

var isSymbol = parser.isSymbol;

function compileModule(template, options) {
  var warnings = [];
  var literals = [];
  var reverseLiterals = {};

  var parsed = parseTemplate(template);
  var rewritten = rewriteSyntaxTree(parsed, warnings);
  var stripped = replaceSymbols(rewritten);

  return {
    templateBody: generateModuleBody(stripped, literals, options),
    err: warnings
  };

  // convert all symbol placeholders into literal table entries
  function replaceSymbols(node) {
    if ( !isArray(node) ) {
      if ( isSymbol(node) ) {
        return lit(node.value);
      }
      return node;
    }

    selfMap(node, function (item) {
      return replaceSymbols(item);
    });

    return node;
  }

  function lit(value) {
    var canonical = JSON.stringify(value);
    var idx = reverseLiterals[canonical];
    if ( typeof idx === 'number' ) {
      return idx;
    }
    idx = literals.push(value) - 1;
    reverseLiterals[canonical] = idx;
    return idx;
  }
}

function generateNodeModule(generatedCode) {
  var buffer = [];
  buffer.push("\"use strict\";");
  buffer.push("module.exports={");
  buffer.push("__intNodeModule: true,");
  buffer.push("createTemplate:function(r){");
  buffer.push(generatedCode);
  buffer.push("}};");
  return buffer.join('');
}

var generateFunction;
if ( typeof vm !== 'undefined' && typeof vm.createContext === 'function' ) {
  // The safer sandboxed method
  generateFunction = function _sandboxed(scriptCode) {
    var context = vm.createContext({
      module: { exports: {} }
    });
    vm.runInContext(generateNodeModule(scriptCode), context);
    return context.module.exports.createTemplate;
  };
}
else {
  // The shitty browser-based approach
  generateFunction = function _funcConstructed(scriptCode) {
    return new Function(['r'], scriptCode);
  };
}

// Exported Functions
exports.compileModule = compileModule;
exports.generateNodeModule = generateNodeModule;
exports.generateFunction = generateFunction;

mixin(compilerStub, exports);

},{"../types":23,"../util":24,"./codegen":5,"./parser":8,"./rewriter":9,"./stub":10,"vm":29}],7:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var util = require('../util');
var types = require('../types');
var annotations = require('./annotations');

var isArray = util.isArray;
var extendObject = util.extendObject;
var mixin = util.mixin;
var objectKeys = util.objectKeys;
var each = util.each;
var map = util.map;
var filter = util.filter;
var annotate = annotations.annotate;
var hasAnnotation = annotations.hasAnnotation;

var jsonStringify = JSON.stringify;
var slice = Array.prototype.slice;

// presented operators are symbolic
var operatorMap = {
  'eq':  '===',
  'neq': '!==',
  'gt':  '>',
  'lt':  '<',
  'ge':  '>=',
  'le':  '<=',
  'add': '+',
  'sub': '-',
  'mul': '*',
  'div': '/',
  'mod': '%',
  'not': '!',
  'neg': '-',
  'pos': '+'
};

// globals can either be generated per template function or can be shared
// amongst several template functions (for bundles)
function createGlobals() {
  var globals = {};            // prefix -> nextId
  var generatedLiterals = {};  // literal -> globalId
  var generatedImports = {};   // funcName -> globalId
  var generatedBuilders = {};  // funcNameId,literalId -> globalId
  var globalVars = [];

  return {
    nextId: nextId,
    literal: literal,
    runtimeImport: runtimeImport,
    builder: builder,
    toString: toString
  };

  function nextId(prefix) {
    var next = globals[prefix];
    if ( typeof next !== 'number' ) {
      next = 0;  // seed it
    }
    var id = prefix + next;
    globals[prefix] = next + 1;
    return id;
  }

  function literal(literalValue) {
    var canonical = jsonStringify(literalValue);
    var id = generatedLiterals[canonical];
    if ( id ) {
      return id;
    }
    id = generatedLiterals[canonical] = nextId('l');

    globalVars.push(id + "=" + canonical);
    return id;
  }

  function runtimeImport(funcName) {
    var id = generatedImports[funcName];
    if ( id ) {
      return id;
    }
    id = generatedImports[funcName] = nextId('i');
    globalVars.push([id, "=r.", funcName].join(''));
    return id;
  }

  function builder(funcName) {
    var funcId = runtimeImport(funcName);
    var literalIds = slice.call(arguments, 1);

    var key = funcId + "/" + literalIds.join('/');
    var id = generatedBuilders[key];
    if ( id ) {
      return id;
    }
    id = generatedBuilders[key] = nextId('b');
    globalVars.push(id + "=" + funcId + "(" + literalIds.join(',') + ")");
    return id;
  }

  function toString() {
    if ( globalVars.length ) {
      return 'var ' + globalVars.join(',') + ';';
    }
    return '';
  }
}

function createModule(globals) {
  if ( globals === undefined ) {
    globals = createGlobals();
  }

  // Keeps track of name -> local mappings throughout the nesting
  var locals = {};       // prefix -> nextId
  var names = {};        // name -> localId
  var scopeInfo = createScopeInfo();
  var nameStack = [];
  var selfName = 'c';

  var writerStack = [];
  var body = [];

  return {
    localForName: localForName,
    anonymous: anonymous,
    self: self,
    writer: writer,
    write: write,
    getter: getter,
    assignments: assignments,
    unaryOperator: unaryOperator,
    binaryOperator: binaryOperator,
    conditionalOperator: conditionalOperator,
    statement: statement,
    ifStatement: ifStatement,
    loopStatement: loopStatement,
    func: func,
    subcontext: subcontext,
    compoundExpression: compoundExpression,
    returnStatement: returnStatement,
    call: call,
    vector: vector,
    vectorAppend: vectorAppend,
    dictionary: dictionary,
    dictionarySet: dictionarySet,
    code: code,
    toString: toString
  };

  function nextId(prefix) {
    var next = locals[prefix];
    if ( typeof next !== 'number' ) {
      next = 0;  // seed it
    }
    var id = prefix + next;
    locals[prefix] = next + 1;
    return id;
  }

  function createScopeInfo() {
    return {
      conditionDepth: 0,
      assignedEarly: {},
      snapshot: function () {
        return mixin({}, this);
      }
    };
  }

  function pushLocalScope() {
    nameStack.push({ names: names, scopeInfo: scopeInfo, selfName: selfName });
    names = extendObject(names);
    scopeInfo = createScopeInfo();
  }

  function popLocalScope() {
    var info = nameStack.pop();
    names = info.names;
    scopeInfo = info.scopeInfo;
    selfName = info.selfName;
  }

  function localForName(name, forAssignment) {
    var willMutate = hasAnnotation(scopeInfo, 'mutations', name);

    var id = names[name];
    if ( id && (names.hasOwnProperty(name) || !willMutate) ) {
      return id;
    }

    var inCondition = !!scopeInfo.conditionDepth;
    scopeInfo.assignedEarly[name] = forAssignment && !inCondition;
    id = names[name] = nextId('v');
    return id;
  }

  function self(propertyName) {
    if ( propertyName === undefined ) {
      write(selfName);
      return;
    }
    write(selfName, '[', globals.literal(propertyName), ']');
  }

  function anonymous(name, value) {
    if ( name === undefined ) {
      var id = nextId('h');
      name = ' ' + id;  // space allows anonymous locals
      names[name] = id;
      return name;
    }
    if ( value === undefined ) {
      write(names[name]);
      return;
    }
    write(names[name], '=', value, ';');
  }

  function isAnonymous(name) {
    return (/ h[0-9]+/).test(name);
  }

  function useContext() {
    return hasAnnotation(scopeInfo, 'self', 'read');
  }

  function writer(functionName) {
    if ( functionName === undefined ) {
      return 'w';
    }
    return 'w.' + functionName;
  }

  function pushWriter() {
    writerStack.push(body);
    body = [];
  }

  function popWriter() {
    var result = body;
    body = writerStack.pop();
    return code(result);
  }

  function captureState(capturedBody) {
    var myScopeInfo = scopeInfo.snapshot();
    var myNames = names;
    var mySelfName = selfName;

    return function () {
      pushLocalScope();
      scopeInfo = myScopeInfo;
      names = myNames;
      selfName = mySelfName;
      capturedBody();
      popLocalScope();
    };
  }

  function write() {
    var args = filter(arguments, function (arg) {
      return arg !== undefined && arg !== null;
    });
    each(args, function (arg) {
      if ( typeof arg === 'function' ) {
        body.push(captureState(arg));
      }
      else {
        body.push(arg);
      }
    });
  }

  function writeDelimited(items, delimiter) {
    if ( delimiter === undefined ) {
      delimiter = ',';
    }
    each(items, function (item, i) {
      if ( i > 0 ) {
        write(delimiter);
      }
      write(item);
    });
  }

  function generate(value) {
    if ( typeof value !== 'function' ) {
      write(value);
      return;
    }
    value();
  }

  function getter(name) {
    write(localForName(name));
  }

  function contextAssignments(names) {
    each(names, function (name) {
      var localName = localForName(name);
      self(name);
      write('=', localName, ';');
    });
  }

  function assignments(items) {
    each(items, function (item) {
      var name = item[0];
      var value = item[1];

      // Evaluate this first
      var localName = localForName(name, true);
      write(localName, '=');
      if ( !isAnonymous(name) && useContext() ) {
        self(name);
        write('=');
      }
      write(value, ';');
    });
  }

  function unaryOperator(operator, operand) {
    write('(', operatorMap[operator], '(', code(operand), '))');
  }

  function binaryOperator(operator, left, right) {
    write('(', code(left), operatorMap[operator], code(right), ')');
  }

  function conditionalOperator(condition, trueVal, falseVal) {
    var isTruthy = globals.runtimeImport('isTruthy');
    var condCode = code(condition);
    var trueCode = code(trueVal);
    var falseCode = code(falseVal);
    write('(', isTruthy, '(', condCode, ')?', trueCode, ':', falseCode, ')');
  }

  function statement(bodyCallback) {
    write(code(bodyCallback), ';');
  }

  function ifStatement(condition, thenBranch, elseBranch) {
    var condWrapperName = 'isTruthy';
    if ( !thenBranch ) {
      condWrapperName = 'isFalsy';
      thenBranch = elseBranch;
      elseBranch = null;
    }
    scopeInfo.conditionDepth += 1;
    var condWrapper = globals.runtimeImport(condWrapperName);
    var condCode = code(condition);
    var thenCode = code(thenBranch);
    write('if(', condWrapper, '(', condCode, ')){', thenCode, '}');
    if ( elseBranch ) {
      write('else{', code(elseBranch), '}');
    }
    scopeInfo.conditionDepth -= 1;
  }

  function loopStatement(itemName, collection, loopGuard,
                         loopBody, annotations) {
    var loop = globals.runtimeImport('loop');
    annotate(annotations, 'javascript', 'bypassCleanse');

    statement(function () {
      call(loop, [
        collection,
        function () {
          func([], [itemName], loopGuard, loopBody, annotations);
        }
      ]);
    });
  }

  function func(internalArgs, contextArgs, funcProlog, funcBody, annotations) {
    if ( !isArray(contextArgs) ) {
      annotations = funcBody;
      funcBody = funcProlog;
      funcProlog = contextArgs;
      contextArgs = [];
    }

    if ( typeof funcBody !== 'function' ) {
      annotations = funcBody;
      funcBody = funcProlog;
      funcProlog = null;
    }

    var parentNames = names;
    pushLocalScope();
    scopeInfo.annotations = annotations;
    var sub = contextArgs.length && useContext();
    var cleanse = !hasAnnotation(annotations, 'javascript', 'bypassCleanse');

    var localNames = map(contextArgs, localForName);

    var bodyContent = code(function () {
      if ( !sub ) {
        generate(funcBody);
        return;
      }

      statement(function () {
        subcontext(
          function () {
            contextAssignments(contextArgs);
            generate(funcBody);
          },
          annotations
        );
      });
    });

    var prologContent = code(function () {
      generate(funcProlog);
    });

    var argNames = internalArgs.concat(localNames);
    write('function(', argNames.join(','), '){');

    if ( contextArgs.length && cleanse ) {
      var cleanseArguments = globals.runtimeImport('cleanseArguments');
      write(cleanseArguments, '(arguments, ', internalArgs.length, ');');
    }

    write(prologContent);
    writeLocalVariables(parentNames, argNames);

    write(bodyContent, '}');
    popLocalScope();
  }

  function writeLocalVariables(parentNames, argNames) {
    if ( argNames === undefined ) {
      argNames = [];
    }

    var undefinedVars = [];
    each(objectKeys(names), function (name) {
      var localName = names[name];
      if ( argNames.indexOf(localName) !== -1 ) {
        // was an argument, skip it
        return;
      }

      if ( isAnonymous(name) || scopeInfo.assignedEarly[name] ) {
        undefinedVars.push(localName);
      }
      else if ( parentNames[name] ) {
        // Local Assignments (inherit from parent)
        write('var ', localName, '=', parentNames[name], ';');
      }
      else {
        var getProperty = globals.runtimeImport('getProperty');
        write('var ', localName, '=');
        call(getProperty, [
          self,
          globals.literal(name)
        ]);
        write(';');
      }
    });

    if ( undefinedVars.length ) {
      write('var ', undefinedVars.join(','), ';');
    }
  }

  function subcontext(bodyCallback, annotations) {
    var parentNames = names;
    var parentSelfName = selfName;

    pushLocalScope();
    scopeInfo.annotations = annotations;
    selfName = nextId('c');

    var extendObject = globals.runtimeImport('extendObject');
    statement(function () {
      write('var ', selfName, '=');
      call(extendObject, [parentSelfName]);
    });

    var bodyContent = code(function () {
      generate(bodyCallback);
    });

    writeLocalVariables(parentNames);
    write(bodyContent);
    popLocalScope();
  }

  function compoundExpression(bodyCallback, annotations) {
    var parentNames = names;

    pushLocalScope();
    scopeInfo.annotations = annotations;

    var bodyContent = code(function () {
      generate(bodyCallback);
    });

    write('(function(){');
    writeLocalVariables(parentNames);
    write(bodyContent);
    popLocalScope();
    write('}())');
  }

  function returnStatement(bodyCallback) {
    if ( bodyCallback === undefined ) {
      write('return;');
      return;
    }
    write('return ', bodyCallback, ';');
  }

  function call(funcId, args) {
    if ( !args ) {
      // Pass through local arguments (for partial chaining)
      write(funcId, '.apply(null,arguments)');
      return;
    }
    write(funcId, '(');
    writeDelimited(args);
    write(')');
  }

  function vector(items) {
    write('[');
    writeDelimited(items);
    write(']');
  }

  function vectorAppend(vector, value) {
    statement(function () {
      write(vector, '.push(', value, ')');
    });
  }

  function dictionary(items, ordered) {
    items = map(items, function (item) {
      return item.concat(typeof item[0] === 'function');
    });

    var literals = [];
    var expressions = items;

    if ( !ordered ) {
      expressions = [];
      each(items, function (item) {
        var target = item[2] ? expressions : literals;
        target.push(item);
      });
    }

    if ( expressions.length ) {
      write('(function(o){');
      each(expressions, function (item) {
        var name = item[2] ? item[0] : globals.literal(item[0]);
        write('o[', name, ']=', item[1], ';');
      });
      write('return o;}(');
      writeLiterals();
      write('))');
    }
    else {
      writeLiterals();
    }

    function writeLiterals() {
      write('{');
      each(literals, function (item, i) {
        if ( i > 0 ) {
          write(',');
        }
        write(jsonStringify(item[0]), ':', item[1]);
      });
      write('}');
    }
  }

  function dictionarySet(dict, name, value) {
    statement(function () {
      write(dict, '[', name, ']=', value);
    });
  }

  function code(value) {
    if ( value === undefined ) {
      return code(body);
    }

    if ( typeof value === 'function' ) {
      pushWriter();
      value();
      return popWriter();
    }

    if ( isArray(value) ) {
      return map(value, code).join('');
    }

    return value;
  }

  function toString() {
    return code();
  }
}

// Exported Functions
exports.createGlobals = createGlobals;
exports.createModule = createModule;

},{"../types":23,"../util":24,"./annotations":4}],8:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var util = require('../util');
var formatter = require('../format');
var generatedParser = require('../../build/parser');

var isArray = util.isArray;
var mixin = util.mixin;
var each = util.each;
var buildFormatter = formatter.buildFormatter;

var formatterCache = {};

function parseTemplate(template) {
  var result = generatedParser.parse(template);
  formatterCache = {};
  return result;
}

function buildBinaryChain(head, tail) {
  if ( !tail || !tail.length ) {
    return head;
  }

  each(tail, function (item) {
    head = [ item[0], head, item[1] ];
  });

  return head;
}

function sym(value, type, template) {
  if ( typeof type !== 'string' ) {
    template = type;
    type = null;
  }
  return mixin({}, template || {}, { value: value, type: type || 'op' });
}

function stmts(statements) {
  statements.stmts = true;
  return statements;
}

function symInterpolate(value, auto) {
  var testFormatter = formatterCache[value];
  if ( !testFormatter ) {
    testFormatter = formatterCache[value] = buildFormatter(value);
  }
  var requiredIndexes = testFormatter.__intRequiredIndexes || [];
  if ( !requiredIndexes.length ) {
    return sym(value, 'lit');
  }
  var result = sym(value, auto ? 'auto': 'int');
  result.formatter = testFormatter;
  return result;
}

function isDefined(value) {
  return value !== undefined && value !== null;
}

function isSymbol(node) {
  return isDefined(node) &&
         typeof node === 'object' &&
         node !== null &&
         node.value !== undefined &&
         node.type !== undefined;
}

function isStatements(node) {
  return isDefined(node) &&
         isArray(node) &&
         node.stmts === true;
}

function hasOperator(node, operator) {
  if ( !isArray(node) || isStatements(node) ) {
    return false;
  }

  var item = node[0];
  if ( !isSymbol(item) || item.type !== 'op' ) {
    return false;
  }

  if ( !operator ) {
    return item.value;
  }

  if ( !isArray(operator) ) {
    operator = [operator];
  }

  var idx = operator.indexOf(item.value);
  if ( idx === -1 ) {
    return false;
  }
  return operator[idx];
}

function changeOperator(node, operator) {
  var item = node[0];
  // assert(isSymbol(item) && item.type === 'op');
  item.value = operator;
  return node;
}

function isInterpolated(node) {
  return isSymbol(node) &&
         (node.type === 'auto' || node.type === 'int');
}

function isIdentifier(node) {
  return isSymbol(node) &&
         node.type === 'id';
}

function isLiteral(node) {
  return isSymbol(node) &&
         node.type === 'lit';
}

// Exceptions

/**
 * Intercepts a PEG.js Exception and generate a human-readable error message.
 *
 * @param {Exception} err the Exception that was raised
 * @param {String} [filePath] path to the file that was being parsed
 */
function formatSyntaxError(err, filePath) {
  if ( !err.name || err.name !== 'SyntaxError') {
    return err;
  }

  var unexpected = err.found ? "'" + err.found + "'" : "end of file";
  var errString = "Unexpected " + unexpected;
  var lineInfo = ":" + err.line + ":" + err.column;

  return new Error((filePath || 'string') + lineInfo + ": " + errString);
}

function formatWarning(warning, filePath) {
  var lineInfo = ":" + warning.line + ":" + warning.column;
  var warningString = warning.message;

  filePath = filePath || warning.filePath || 'string';
  return filePath + lineInfo + ": " + warningString;
}

// Exported Functions
exports.parseTemplate = parseTemplate;
exports.buildBinaryChain = buildBinaryChain;
exports.sym = sym;
exports.stmts = stmts;
exports.symInterpolate = symInterpolate;
exports.isDefined = isDefined;
exports.isSymbol = isSymbol;
exports.isStatements = isStatements;
exports.hasOperator = hasOperator;
exports.changeOperator = changeOperator;
exports.isInterpolated = isInterpolated;
exports.isIdentifier = isIdentifier;
exports.isLiteral = isLiteral;
exports.formatSyntaxError = formatSyntaxError;
exports.formatWarning = formatWarning;

},{"../../build/parser":3,"../format":11,"../util":24}],9:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var interpol = require('../interpol');
var util = require('../util');
var types = require('../types');
var parser = require('./parser');
var format = require('../format');
var match = require('../match');
var annotations = require('./annotations');

var isArray = util.isArray;
var objectKeys = util.objectKeys;
var each = util.each;
var map = util.map;
var selfMap = util.selfMap;

var escapeContent = types.escapeContent;
var escapeAttribute = types.escapeAttribute;
var stringify = types.stringify;
var isTruthy = types.isTruthy;

var sym = parser.sym;
var isStatements = parser.isStatements;
var stmts = parser.stmts;
var isSymbol = parser.isSymbol;
var hasOperator = parser.hasOperator;
var isIdentifier = parser.isIdentifier;
var isLiteral = parser.isLiteral;
var isInterpolated = parser.isInterpolated;

var isMatchingObject = match.matches;
var annotate = annotations.annotate;

var slice = Array.prototype.slice;

var inverseOperators = {
  'eq': 'nq', 'nq': 'eq',
  'lt': 'ge', 'ge': 'lt',
  'gt': 'le', 'le': 'gt'
};

var createTag = {
  'op': createOpenTag,
  'cl': createCloseTag,
  'ct': createCommentTag
};

var constantFolders = {
  'no': function (v) { return !isTruthy(v); },
  'ne': function (v) { return -v; },
  'ad': function (l, r) { return l + r; },
  'su': function (l, r) { return l - r; },
  'mu': function (l, r) { return l * r; },
  'di': function (l, r) { return l / r; },
  'eq': function (l, r) { return l === r; },
  'nq': function (l, r) { return l !== r; },
  'gt': function (l, r) { return l > r; },
  'lt': function (l, r) { return l < r; },
  'ge': function (l, r) { return l >= r; },
  'le': function (l, r) { return l <= r; },
  'mo': function (l, r) { return l % r; },
  'ma': function (l, r) { return isMatchingObject(r, l); },
  'mb': function (l, r) {
          if ( l === undefined ) { return l; }
          var res = l[r];
          return res === null ? undefined : res;
        }
};

var shortCircuitFolders = {
  'or': function (l, r) { return isTruthy(l.value) ? l : r; },
  'an': function (l, r) { return isTruthy(l.value) ? r : l; },
  'cn': function (c, t, f) { return isTruthy(c.value) ? t : f; }
};

var constantFolderKeys = objectKeys(constantFolders);
var shortCircuitFolderKeys = objectKeys(shortCircuitFolders);

function rewriteSyntaxTree(syntaxTree, warnings) {
  warnings = warnings || [];
  var nodeStack = [];

  var pipeline = [
    symbols(createFormatterNodes, isInterpolated),
    operators(foldShortCircuits, matchOps(shortCircuitFolderKeys)),
    operators(foldConstants, matchOps(constantFolderKeys)),
    operators(flipConditionals, matchOps('cn', 'if')),
    operators(flipEquality, matchOps('no')),
    operators(promoteNot, matchOps('an', 'or')),
    operators(literalFromArray, matchOps('ar')),
    operators(literalFromDictionary, matchOps('dc')),
    operators(immediateInterpolation, matchOps('ca')),
    operators(selfFormatFromDictionary, matchOps('fm')),
    statements(foldIfStatements),
    statements(hoistPartials),

    groups(mergePartials, matchOps('de')),
    operators(rollUpForLoops, matchOps('fr')),
    operators(rollUpMemberPaths, matchOps('mb')),
    operators(promoteRawLiteralOutput, matchOps('ou')),
    operators(convertLiteralHTML, matchOps('op', 'cl', 'ct')),
    groups(mergeRawOutput, matchOps('ra')),

    operators(assignPartials, matchOps('de')),

    operators(annotateSelfReferences, matchOps('se')),
    operators(annotateMutations, matchOps('as')),

    finalizeRoot
  ];

  each(pipeline, function (func) {
    // Mark the root for matching
    syntaxTree.root = true;
    syntaxTree = func(syntaxTree);
  });

  return syntaxTree;

  function finalizeRoot(node) {
    annotate(node, 'self', 'read');
    return node;
  }

  function annotateNearestParent(group, name, matcher) {
    for ( var i = nodeStack.length - 1; i >= 0; i-- ) {
      var node = nodeStack[i];
      if ( matcher(node) ) {
        annotate(node, group, name);
        return;
      }
    }
  }

  function annotateUpTree(group, name, matcher) {
    var matched = false;
    each(nodeStack, function (child) {
      if ( matcher(child) ) {
        annotate(child, group, name);
        matched = true;
      }
    });

    return matched;
  }

  function rewriteNodes(node, processor, matcher) {
    return rewrite(node);

    function rewrite(node) {
      if ( isArray(node) ) {
        // Depth-first Processing
        nodeStack.push(node);
        selfMap(node, rewrite);
        nodeStack.pop();
      }

      // Now the real work
      if ( matcher(node) ) {
        return processor(node);
      }
      return node;
    }
  }

  function symbols(processor, matcher) {
    return rewrite;

    function rewrite(node) {
      return rewriteNodes(node, processor, symbolMatcher);
    }

    function symbolMatcher(node) {
      return isSymbol(node) && matcher(node);
    }
  }

  function operators(processor, matcher) {
    return rewrite;

    function rewrite(node) {
      return rewriteNodes(node, processor, operatorMatcher);
    }

    function operatorMatcher(node) {
      return hasOperator(node) && matcher(node);
    }
  }

  function statements(processor) {
    return rewrite;

    function rewrite(node) {
      return rewriteNodes(node, statementsProcessor, isStatements);
    }

    function statementsProcessor(node) {
      return stmts(processor(node));
    }
  }

  // Iterates over a set of statements and presents adjacent groups
  // to the callback function for replacement
  function groups(processor, matcher) {
    return statements(groupProcessor);

    function groupProcessor(statements) {
      var group = [];
      var output = [];

      each(statements, function (statement) {
        if ( matcher(statement) ) {
          group.push(statement);
        }
        else {
          processMatches();
          output.push(statement);
        }
      });

      processMatches();
      return output;

      function processMatches() {
        var result = group.length < 2 ? group : processor(group);
        output = output.concat(result);
        group = [];
      }
    }
  }

  function createFormatterNodes(node) {
    var formatter = node.formatter;
    var result = [sym('fm', node), node];

    var requiredFunctions = formatter.__intRequiredFunctions || [];
    var requiredIndexes = node.formatter.__intRequiredIndexes || [];

    if ( !requiredIndexes.length ) {
      // Huh?  Issue a warning!
      issueWarning(node[0],
        "Attempt to perform interpolation against string with no escaping"
      );
      return node;
    }

    if ( requiredFunctions.length ) {
      // build a dictionary from the names
      var supportFuncElems = map(requiredFunctions, function (funcName) {
        return [
          sym(funcName, 'id'),
          [sym('id'), sym(funcName, 'lit')]
        ];
      });
      result.push([sym('dc'), supportFuncElems]);
    }
    else {
      result.push(sym({}, 'lit'));
    }

    result.formatter = formatter;
    return result;
  }

  // if an 'if' statement is evaluating a constant, then we can eliminate
  // the inapplicable branch and just inline the matching statements
  function foldIfStatements(statements) {
    var output = [];
    each(statements, function (statement) {
      if ( !hasOperator(statement, 'if') || !isLiteral(statement[1]) ) {
        output.push(statement);
        return;
      }
      var result = isTruthy(statement[1].value) ? statement[2] : statement[3];
      output = output.concat(result);
    });
    return output;
  }

  // Hoisting *only* occurs when the following condition is met:
  //
  //   (!partial_definition)+
  //   partial_definition+
  //
  // meaning that partial definitions can't be interspersed with
  // regular statements.  In that case, the logic is assumed too
  // complex to make a responsible guess as to the developer's
  // intentions.
  function hoistPartials(statements) {
    if ( statements.length < 2 ) {
      return statements;
    }

    var partials = [];
    var others = [];
    var invalid;

    each(statements, function (statement) {
      if ( hasOperator(statement, 'de') ) {
        if ( !invalid && !others.length ) {
          // Either all partials or we don't meet hoisting conditions
          invalid = statement;
        }
        partials.push(statement);
      }
      else {
        if ( !invalid && partials.length ) {
          // We don't hoist under these conditions
          invalid = partials[partials.length - 1];
        }
        others.push(statement);
      }
    });

    if ( invalid ) {
      if ( others.length ) {
        issueWarning(invalid[0],
          "Will only perform 'hoisting' if all partials are placed after " +
          "other statements"
        );
      }
      return statements;
    }
    return partials.concat(others);
  }

  // We can combine multiple sequential compatible partials into a
  // single branched partial
  function mergePartials(statements) {
    var namedDefs = {};
    each(statements, function (statement) {
      var name = statement[1].value;
      var group = namedDefs[name] || ( namedDefs[name] = [] );

      if ( !statement[4] && group.length ) {
        // if we see an unguarded, blow away previous definitions
        issueWarning(statement[0],
          "The unguarded Partial '" + name + "' will replace " +
          "any previous definitions"
        );
        group = [];
      }

      group.push(statement);
    });

    var result = [];
    for ( var key in namedDefs ) {
      var definitions = namedDefs[key];
      if ( definitions.length === 1 ) {
        result.push(definitions[0]);
        continue;
      }
      result = result.concat(mergeDefinitions(key, definitions));
    }
    return result;

    function mergeDefinitions(name, definitions) {
      var firstDefinition = definitions[0];
      var originalArgs = argumentsSignature(firstDefinition[2]);
      var statements = firstDefinition[3];
      var guard = firstDefinition[4];

      if ( guard ) {
        statements = [
          [sym('if'), guard, statements, []]
        ];
      }

      for ( var i = 1, len = definitions.length; i < len; i++ ) {
        var definition = definitions[i];
        var theseArgs = argumentsSignature(definition[2]);
        if ( originalArgs !== theseArgs ) {
          // Short-circuit, won't make assumptions about local names
          issueWarning(definition[0],
            "Reopened partial '" + name + "' has different " +
            "argument names than the original definition"
          );
          return definitions;
        }

        var theseStatements = definition[3];
        var thisGuard = definition[4];

        statements = [
          [sym('if'), thisGuard, theseStatements, statements]
        ];
        guard = guard && [sym('or'), thisGuard, guard];
      }

      firstDefinition[3] = statements;
      if ( guard ) {
        firstDefinition[4] = guard;
      }
      return [firstDefinition];
    }
  }

  function matchOps(ops) {
    if ( !isArray(ops) ) {
      ops = slice.call(arguments, 0);
    }
    return matcher;

    function matcher(node) {
      return hasOperator(node, ops);
    }
  }

  function matchOpsOrRoot(ops) {
    var opsMatcher = matchOps(ops);
    return matcher;

    function matcher(node) {
      var op = opsMatcher(node);
      if ( op ) {
        return op;
      }
      return node.root;
    }
  }

  // Partial declarations are really 'let name = partial'
  function assignPartials(node) {
    return [ sym('as'), [ [node[1], node] ] ];
  }

  // Convert literal output to pre-escaped raw output
  function promoteRawLiteralOutput(node) {
    if ( !isLiteral(node[1]) ) {
      return node;
    }
    var content = escapeContent(node[1].value);
    return [sym('ra'), sym(content, 'lit')];
  }

  // Literal HTML tags can be converted to raw output
  function convertLiteralHTML(node) {
    var op = hasOperator(node);
    var tag = createTag[op](node);
    return tag ? [sym('ra'), sym(tag, 'lit')] : node;
  }

  // We can combine sequences of raw literal output
  function mergeRawOutput(statements) {
    var buffer = map(statements, function (statement) {
      return statement[1].value;
    }).join('');

    return [ [sym('ra'), sym(buffer, 'lit')] ];
  }

  function annotateMutations(node) {
    each(node[1], function (assignment) {
      annotateNearestParent(
        'mutations',
        assignment[0].value,
        matchOpsOrRoot(['de', 'fr'])
      );
    });
    return node;
  }

  // We can roll up a single nested for loop into a containing for
  // loop so that they share the same context
  function rollUpForLoops(node) {
    var forStatements = node[2];

    if ( forStatements.length !== 1 ) {
      return node;  // should only be one child
    }
    if ( !hasOperator(forStatements[0], 'fr') ) {
      return node;  // should have a nested for loop
    }

    var nested = forStatements[0];
    if ( node[3].length || nested[3].length ) {
      return node;  // no else clauses
    }

    node[1] = node[1].concat(nested[1]);
    node[2] = nested[2];
    return node;
  }

  // if a member operator contains another member operator, it can be rolled 
  // up into a single path operator
  function rollUpMemberPaths(node) {
    var target = node[1];
    if ( !hasOperator(target, 'mb') ) {
      return node;
    }
    target[2] = target[2].concat(node[2]);
    return target;
  }

  // Or, And, Conditional Folding
  function foldShortCircuits(node) {
    if ( !isLiteral(node[1]) ) {
      return node;
    }
    var op = hasOperator(node);
    var args = node.slice(1);
    return shortCircuitFolders[op].apply(null, args);
  }
  
  // Simple constant folding
  function foldConstants(node) {
    var args = [];
    for ( var i = 1, len = node.length; i < len; i++ ) {
      var arg = node[i];
      if ( !isLiteral(arg) ) {
        return node;
      }
      args.push(arg.value);
    }
    var op = hasOperator(node);
    var output = constantFolders[op].apply(null, args);
    return sym(output, 'lit', node[0]);
  }
  
  // If the condition is 'not' we can roll up its argument
  // and flip the branches.
  function flipConditionals(node) {
    var cond = node[1];
    if ( !hasOperator(cond, 'no') ) {
      return node;
    }
    // Make it so
    node[1] = cond[1];
    var tmp = node[2];
    node[2] = node[3];
    node[3] = tmp;
    return node;
  }

  // if the operator is 'not' and it contains an equality,
  // then we can flip the equality operator and roll it up
  function flipEquality(node) {
    var child = node[1];
    var op = hasOperator(child);
    var newOp = inverseOperators[op];

    if ( !op || !newOp ) {
      return node;
    }

    child[0].value = newOp;
    return child;
  }

  // If left and right operands of an 'and' or 'or' are using the 'not'
  // unary, then promote it to the top and flip the and/or
  function promoteNot(node) {
    var left = node[1];
    var leftOp = hasOperator(left, 'no');
    var right = node[2];
    var rightOp = hasOperator(right, 'no');

    if ( !leftOp || !rightOp ) {
      return node;
    }

    var op = hasOperator(node);
    var newOp = op === 'an' && 'or' || 'an';
    return [ sym('no', left), [sym(newOp, node), left[1], right[1]] ];
  }

  // If all the elements of an Array are literals, then we can convert
  // the list to a literal array for the literal table
  function literalFromArray(node) {
    var elements = node[1];
    var output = [];

    for ( var i = 0, len = elements.length; i < len; i++ ) {
      var element = elements[i];
      if ( !isLiteral(element) ) {
        return node;
      }
      output.push(element.value);
    }

    return sym(output, 'lit', node[0]);
  }

  // If all the elements of a Dictionary are literals, then we can
  // convert the list to a literal object for the literal table
  function literalFromDictionary(node) {
    var elements = node[1];
    var output = {};

    for ( var i = 0, len = elements.length; i < len; i++ ) {
      var element = elements[i];
      var name = element[0];
      var value = element[1];
      if ( (!isIdentifier(name) && !isLiteral(name)) || !isLiteral(value) ) {
        return node;
      }
      output[name.value] = value.value;
    }

    return sym(output, 'lit', node[0]);
  }

  // If the left side of a call is a formatter, then we can generate code
  // that will immediately provide the evaluated expression to that formatter
  // instead of nesting the calls
  function immediateInterpolation(node) {
    var member = node[1];
    if ( !hasOperator(member, 'fm') ) {
      // Nothing to do here
      return node;
    }

    var args = node[2];
    member.push(args[0]);
    return member;
  }

  function selfFormatFromDictionary(node) {
    if ( node.length === 3 ) {
      return node;
    }

    var expr = node[3];
    if ( !hasOperator(expr, 'se') ) {
      return node;
    }

    var requiredIndexes = node.formatter.__intRequiredIndexes || [];
    var varNameElems = map(requiredIndexes, function (varName) {
      return [
        sym(varName, 'id'),
        [sym('id'), sym(varName, 'lit')]
      ];
    });

    node[3] = [sym('dc'), varNameElems];
    return node;
  }

  function annotateSelfReferences(node) {
    annotateUpTree('self', 'read', hasOperator);
    return node;
  }

  function issueWarning(source, message) {
    warnings.push({
      line: source.line,
      column: source.column,
      message: message
    });
  }
}

function argumentsSignature(argNames) {
  if ( !argNames || !argNames.length ) {
    return '';
  }

  return map(argNames, function (argName) {
    return argName.value;
  }).join(',');
}

function createOpenTag(statement) {
  if ( !isIdentifier(statement[1]) ) {
    return;
  }

  var tag = ["<", statement[1].value];
  var attrs = statement[2];
  if ( attrs && attrs.length ) {
    for ( var i = 0, len = attrs.length; i < len; i++ ) {
      var attr = attrs[i];
      if ( !isIdentifier(attr[0]) || !isLiteral(attr[1]) ) {
        return;
      }

      var val = attr[1].value;
      if ( typeof val !== 'boolean' ) {
        var content = escapeAttribute(val);
        tag.push(" ", attr[0].value, "=\"", content, "\"");
        continue;
      }

      if ( val ) {
        tag.push(" ", attr[0].value);
      }
    }
  }

  if ( statement[3] ) {
    tag.push(" /");
  }
  tag.push(">");

  return tag.join('');
}

function createCloseTag(statement) {
  if ( !isIdentifier(statement[1]) ) {
    return;
  }
  return ["</", statement[1].value, ">"].join('');
}

function createCommentTag(statement) {
  return ["<!--", statement[1].value, "-->"].join('');
}

// Exported Functions
exports.rewriteSyntaxTree = rewriteSyntaxTree;

},{"../format":11,"../interpol":12,"../match":13,"../types":23,"../util":24,"./annotations":4,"./parser":8}],10:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

/**
 * This is a stub that will be populated by the 'real' compiler functionality
 * should it be loaded by either node.js or Browserify.  It's here because
 * we shouldn't have to rely on Browserify's `--ignore` option.
 */

},{}],11:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var util = require('./util');
var types = require('./types');

var objectKeys = util.objectKeys;
var each = util.each;
var stringify = types.stringify;
var isInterpolFunction = types.isInterpolFunction;

var Digits = "0|[1-9][0-9]*";
var Ident = "[$_a-zA-Z][$_a-zA-Z0-9]*";
var Pipes = "([|]" + Ident + ")*";
var Term = ";?";
var Params = "%((%)|(" + Digits + ")|(" + Ident + "))?(" + Pipes + ")?" + Term;
             /* "%" ( "%" | digits | identifier )? ( "|" identifier )* ";"? */

var ParamRegex = new RegExp(Params, "m");

var nullWriter = require('./writers/null').createNullWriter();

/**
 * Builds a closure that will be used internally to support Interpol's
 * interpolation operations.  The returned closure will attach flags
 * that identify any names or indexes that must be provided by interpol
 * to fulfill its formatting.
 *
 * @param {String} formatStr the String to be used for interpolation
 */
function buildFormatter(formatStr) {
  var components = [];
  var requiredIndexes = {};
  var requiredFunctions = {};
  var clen = 0;
  var autoIdx = 0;

  var workStr = formatStr;
  while ( workStr && workStr.length ) {
    var paramMatch = ParamRegex.exec(workStr);
    if ( !paramMatch ) {
      components.push(createLiteralComponent(workStr));
      break;
    }

    var match = paramMatch[0];
    var matchIdx = paramMatch.index;
    var matchLen = match.length;

    if ( matchIdx ) {
      components.push(createLiteralComponent(workStr.substring(0, matchIdx)));
    }

    if ( paramMatch[2] === '%' ) {
      components.push(createLiteralComponent('%'));
      workStr = workStr.substring(matchIdx + matchLen);
      continue;
    }

    var idx = autoIdx++;
    if ( paramMatch[4] ) {
      idx = paramMatch[4];
    }
    else if ( paramMatch[3] ) {
      idx = parseInt(paramMatch[3], 10);
    }
    requiredIndexes[idx] = true;

    if ( paramMatch[5] ) {
      var formatters = paramMatch[5].slice(1).split('|');
      components.push(createPipedComponent(idx, formatters));
    }
    else {
      components.push(createIndexedComponent(idx));
    }

    workStr = workStr.substring(matchIdx + matchLen);
  }
  clen = components.length;

  formatFunction.__intRequiredIndexes = objectKeys(requiredIndexes);
  formatFunction.__intRequiredFunctions = objectKeys(requiredFunctions);
  formatFunction.toString = toString;
  return formatFunction;

  function toString() {
    return formatStr;
  }

  function formatFunction(supportFunctions, writer, data) {
    if ( typeof data !== 'object' || data === null ) {
      data = [data];
    }

    var result = '';
    for ( var i = 0; i < clen; i++ ) {
      var component = components[i];
      switch ( component[0] ) {
        case 0: result += component[1]; break;
        case 1: result += stringify(data[component[1]]); break;
        case 2: result += component[1](data, supportFunctions);
      }
    }
    return result;
  }

  function createLiteralComponent(literal) {
    return [0, literal];
  }

  function createIndexedComponent(idx) {
    return [1, idx];
  }

  function createPipedComponent(idx, formatters) {
    var funcs = formatters.reverse();
    var flen = funcs.length - 1;

    // Register requirement on these formatters
    each(funcs, function (funcName) {
      requiredFunctions[funcName] = true;
    });

    return [2, pipedFunction];

    function pipedFunction(data, supportFunctions) {
      var value = data[idx];
      for ( var i = flen; i >= 0; i-- ) {
        var funcName = funcs[i];
        var func = supportFunctions[funcName];

        if ( !isInterpolFunction(func) ) {
          if ( supportFunctions.__intExports ) {
            continue;
          }
          throw new Error("Attempting to call an unblessed function");
        }

        value = func(nullWriter, value);
      }
      return stringify(value);
    }
  }
}

function buildDeferredFormatter(formatStr, supportFunctions) {
  var formatter = buildFormatter(formatStr);
  supportedFormatter.__intFunction = 'format';
  supportedFormatter.toString = formatter.toString;
  if ( supportFunctions !== undefined ) {
    return supportedFormatter;
  }
  return deferredFormatter;

  function supportedFormatter(writer, data) {
    return formatter(supportFunctions, writer, data);
  }
  
  function deferredFormatter(_supportFunctions) {
    supportFunctions = _supportFunctions;
    return supportedFormatter;
  }
}

function buildImmediateFormatter(formatStr, supportFunctions) {
  var formatter = buildFormatter(formatStr);
  if ( supportFunctions !== undefined ) {
    return supportedFormatter;
  }
  return immediateFormatter;

  function supportedFormatter(data) {
    return formatter(supportFunctions, undefined, data);
  }
  
  function immediateFormatter(supportFunctions, data) {
    return formatter(supportFunctions, undefined, data);
  }
}

// Exported Functions
exports.buildFormatter = buildFormatter;
exports.buildDeferredFormatter = buildDeferredFormatter;
exports.buildImmediateFormatter = buildImmediateFormatter;

},{"./types":23,"./util":24,"./writers/null":27}],12:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var util = require('./util');
var types = require('./types');
var compiler = require('./compiler/stub');
var runtime = require('./runtime');

var isArray = util.isArray;
var bless = types.bless;

var createRuntime = runtime.createRuntime;
var compileModule;
var generateFunction;

var CURRENT_VERSION = "1.3.0";

// Bootstrap

interpol.VERSION = CURRENT_VERSION;
interpol.bless = bless;
interpol.evaluate = evaluate;
interpol.compile = compile;
interpol.runtime = getRuntime;
interpol.stopIteration = types.stopIteration;

// Core Interpol Implementation

var globalRuntime = createRuntime(interpol);

/**
 * Main Interpol entry point.  Takes a template and returns a closure
 * for rendering it.  The template must be a String.
 *
 * @param {String} template the template to be compiled
 * @param {Runtime} [runtime] Runtime Instance (or config Object)
 */
function interpol(template, runtime) {
  if ( typeof template !== 'string' ) {
    throw new Error("template must be a string");
  }

  runtime = getRuntime(runtime);
  var options = runtime.options;

  var compiledOutput = compile(template, options).templateBody;
  var wrapper = generateFunction(compiledOutput);
  return wrapper(runtime);
}

/**
 * Convenience function to compile and execute a template against a context
 * Object and options.  Not generally recommended.
 */
function evaluate(script, obj, options) {
  var compiled = interpol(script, options);
  return compiled(obj, options);
}

/**
 * Invokes the Interpol compiler against the specified template and produces
 * an Object that includes the compiled template generator and any errors or
 * warnings.  The compiler module has to be loaded for this to work.
 *
 * @param {String} template the Interpol Template to be compiled
 */
function compile(template, options) {
  if ( !compileModule ) {
    if ( typeof compiler.compileModule !== 'function' ) {
      throw new Error("The Interpol compiler was never loaded");
    }
    compileModule = compiler.compileModule;
    generateFunction = compiler.generateFunction;
  }
  return compileModule(template, options);
}

/**
 * Returns a new Runtime based on the provided options.  If no options are
 * provided, will return the global Runtime instance.
 *
 * @param {Object} [options] configuration Object
 */
function getRuntime(options) {
  if ( !options ) {
    return globalRuntime;
  }
  return createRuntime(interpol, options);
}

// Exported Functions
module.exports = interpol;

},{"./compiler/stub":10,"./runtime":22,"./types":23,"./util":24}],13:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var util = require('./util');
var isArray = util.isArray;
var objectKeys = util.objectKeys;

/**
 * Basic Object Matcher to support the `like` operator.
 *
 * @param {Mixed} template the Template to match against
 * @param {Mixed} obj the Object being inspected
 */
function isMatchingObject(template, obj) {
  if ( template === null || template === undefined ) {
    return obj === null || obj === undefined;
  }

  if ( typeof template !== 'object' ) {
    return template === obj;
  }

  if ( isArray(template) ) {
    if ( !isArray(obj) || template.length !== obj.length ) {
      return false;
    }

    for ( var i = 0, len = template.length; i < len; i++ ) {
      if ( !isMatchingObject(template[i], obj[i]) ) {
        return false;
      }
    }

    return true;
  }

  if ( typeof obj !== 'object' || obj === null ) {
    return false;
  }

  for ( var key in template ) {
    if ( !isMatchingObject(template[key], obj[key]) ) {
      return false;
    }
  }
  return true;
}

/**
 * Compiled matcher, for when the template has been defined as a literal.
 *
 * @param {Mixed} template the Template to match against
 */
function buildMatcher(template) {
  if ( template === null || template === undefined ) {
    return nullMatcher;
  }
  if ( typeof template !== 'object' ) {
    return valueMatcher;
  }
  if ( isArray(template) ) {
    return buildArrayMatcher(template);
  }
  return buildObjectMatcher(template);

  function nullMatcher(obj) {
    return obj === null || obj === undefined;
  }

  function valueMatcher(obj) {
    return template === obj;
  }
}

function buildArrayMatcher(template) {
  var matchers = [];
  var mlen = template.length;

  for ( var i = 0; i < mlen; i++ ) {
    matchers.push(buildMatcher(template[i]));
  }
  return arrayMatcher;

  function arrayMatcher(obj) {
    if ( template === obj ) {
      return true;
    }
    if ( !isArray(obj) || mlen !== obj.length ) {
      return false;
    }
    for ( var i = 0; i < mlen; i++ ) {
      if ( !matchers[i](obj[i]) ) {
        return false;
      }
    }
    return true;
  }
}

function buildObjectMatcher(template) {
  var matchers = [];
  var keys = objectKeys(template);
  var mlen = keys.length;

  for ( var i = 0; i < mlen; i++ ) {
    matchers.push(buildMatcher(template[keys[i]]));
  }
  return objectMatcher;

  function objectMatcher(obj) {
    if ( template === obj ) {
      return true;
    }
    if ( typeof obj !== 'object' || obj === null ) {
      return false;
    }
    for ( var i = 0; i < mlen; i++ ) {
      if ( !matchers[i](obj[keys[i]]) ) {
        return false;
      }
    }
    return true;
  }
}

// Exported Functions
exports.matches = isMatchingObject;
exports.matcher = buildMatcher;

},{"./util":24}],14:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var memory = require('./memory');
var system = require('./system');

// Exported Functions
exports.createMemoryResolver = memory.createMemoryResolver;
exports.createSystemResolver = system.createSystemResolver;

},{"./memory":15,"./system":17}],15:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var types = require('../types');
var util = require('../util');

var isInterpolModule = types.isInterpolModule;
var isArray = util.isArray;
var bless = types.bless;

/**
 * Creates a new MemoryResolver.  As its name implies, this resolver
 * allows one to register a module to be stored in memory.  A default
 * instance of this resolver is used to store the System Modules.
 * Because of its flexibility, it can also be used to store custom
 * modules and native JavaScript helpers.
 *
 * @param {Runtime} [runtime] Runtime owner for MemoryResolver
 * @param {boolean} [addRuntimeEntries] whether to add registerModule
 */
function createMemoryResolver(runtime, addRuntimeEntries) {
  var interpol = runtime.interpol;
  var cache = {};

  var resolver = {
    resolveModule: resolveModule,
    resolveExports: resolveExports,
    unregisterModule: unregisterModule,
    registerModule: registerModule
  };

  runtime.resolvers().push(resolver);
  if ( addRuntimeEntries ) {
    runtime.registerModule = registerModule;
    runtime.unregisterModule = unregisterModule;
  }
  return resolver;

  function resolveModule(name) {
    var result = cache[name];
    return result ? result.module : undefined;
  }

  function resolveExports(name) {
    var result = cache[name];
    if ( !result ) {
      return undefined;
    }

    if ( result.moduleExports ) {
      return result.moduleExports;
    }

    var moduleExports = result.moduleExports = result.module.exports();
    return moduleExports;
  }

  /**
   * Removes a module from the resolver cache.
   *
   * @param {String} name the name of the module to remove
   */
  function unregisterModule(name) {
    delete cache[name];
  }

  /**
   * Registers a module in the module cache.
   *
   * @param {String} name the name of the module to be registered
   * @param {Function|String|Object} module the module to register
   */
  function registerModule(name, module) {
    // A compiled Interpol Module function
    if ( isInterpolModule(module) ) {
      cache[name] = { module: module };
      return;
    }

    // *String* - An unparsed Interpol template
    if ( typeof module === 'string' ) {
      cache[name] = { module: interpol(module) };
      return;
    }

    // *Object* - A hash of Helpers (name->Function)
    if ( typeof module === 'object' && module !== null && !isArray(module) ) {
      cache[name] = { module: createModuleStub(module) };
      return;
    }

    throw new Error("Module not provided");
  }
}

/**
 * Creates a 'blessed' module where are Functions are made to be both
 * Interpol-compatible and configurable.
 *
 * @param {Object} module the Module to bless
 */
function blessModule(module) {
  var result = {};
  for ( var key in module ) {
    var value = module[key];
    if ( typeof value === 'function') {
      result[key] = bless(value);
    }
    else {
      result[key] = value;
    }
  }
  return result;
}

/**
 * Takes a hash of Functions, blesses them, and creates a stub module for
 * them that can be returned by the `resolveModule()` call.
 *
 * @param {Object} moduleExports the hash of Functions to stub
 */
function createModuleStub(moduleExports) {
  moduleExports = blessModule(moduleExports);
  templateInterface.__intModule = true;
  templateInterface.exports = templateExports;
  return templateInterface;

  function templateInterface() {
    return '';
  }

  function templateExports() {
    return moduleExports;
  }
}

// Exported Functions
exports.createMemoryResolver = createMemoryResolver;

},{"../types":23,"../util":24}],16:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var types = require('../../types');
var bless = types.bless;

var slice = Array.prototype.slice;

/**
 * Wraps a Function in an envelope that accepts a Writer (but discards it).
 *
 * @param {Function} func the Function to wrap
 */
function wrap(func) {
  return bless(wrappedFunction);

  function wrappedFunction(writer) {
    /* jshint validthis:true */
    return func.apply(this, slice.call(arguments, 1));
  }
}

// Exported Functions
exports.wrap = wrap;

},{"../../types":23}],17:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var memory = require('../memory');

var math = require('./math');
var list = require('./list');
var render = require('./render');
var string = require('./string');

var createMemoryResolver = memory.createMemoryResolver;

function createSystemResolver(runtime) {
  var resolver = createMemoryResolver(runtime);

  resolver.registerModule('math', math);
  resolver.registerModule('list', list);
  resolver.registerModule('render', render);
  resolver.registerModule('string', string);

  delete resolver.registerModule;
  delete resolver.unregisterModule;

  runtime.resolvers().push(resolver);
  return resolver;
}

// Exported Functions
exports.createSystemResolver = createSystemResolver;

},{"../memory":15,"./list":18,"./math":19,"./render":20,"./string":21}],18:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var util = require('../../util');
var objectKeys = util.objectKeys;
var isArray = util.isArray;

// `first(value)` returns the first item of the provided array (or `null` if
// the array is empty).
function first(writer, value) {
  if ( isArray(value) ) {
    return value[0];
  }
  if ( typeof value === 'object' && value !== null ) {
    var name = objectKeys(value)[0];
    var val = value[name];
    return {
        name: name,
        value: val === null ? undefined : val
    };
  }
  return value;
}

// `join(delim, value)` returns the result of joining the elements of the
// provided array. Each element will be concatenated into a string separated
// by the specified delimiter (or ' ').
function join(writer, delim, value) {
  if ( value === undefined ) {
    value = delim;
    delim = ' ';
  }
  if ( isArray(value) ) {
    return value.join(delim);
  }
  return value;
}

// `last(value)` returns the last item of the provided array (or `null` if
// the array is empty).
function last(writer, value) {
  if ( isArray(value) ) {
    return value[value.length - 1];
  }
  if ( typeof value === 'object' && value !== null ) {
    var keys = objectKeys(value);
    var name = keys[keys.length - 1];
    var val = value[name];
    return {
        name: name,
        value: val === null ? undefined : val
    };
  }
  return value;
}

// `length(value)` if it is an array, returns the length of the provided
// value, if an object, the number of keys, otherwise `0`.
function length(writer, value) {
  if ( isArray(value) ) {
    return value.length;
  }
  if ( typeof value === 'object' && value !== null ) {
    return objectKeys(value).length;
  }
  return 0;
}

// `empty(value)` returns true or false depending on whether or not the
// provided array is empty.
function empty(writer, value) {
  if ( isArray(value) ) {
    return !value.length;
  }
  if ( typeof value === 'object' && value !== null ) {
    return !objectKeys(value).length;
  }
  return true;
}

// `keys(value)` returns the keys of the Object or indexes of the Array
// passed to it.  If the Array is sparse (has gaps) it will only return
// the indexes with assigned values.
function keys(writer, value) {
  if ( typeof value === 'object' && value !== null ) {
    return objectKeys(value);
  }
  return undefined;
}

// values(value)` returns the values of the Object or Array passed to
// it.  If the array is sparse (has gaps) it will only return the
// assigned values.
function values(writer, value) {
  if ( typeof value !== 'object' || value === null ) {
    return undefined;
  }
  var keys = objectKeys(value);
  var result = [];
  for ( var i = 0, len = keys.length; i < len; i++ ) {
    result[i] = value[keys[i]];
  }
  return result;
}

// Exports
exports.first = first;
exports.join = join;
exports.last = last;
exports.length = length;
exports.empty = empty;
exports.keys = keys;
exports.values = values;

},{"../../util":24}],19:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var util = require('../../util');
var isArray = util.isArray;

var types = require('../../types');
var bless = types.bless;
var stopIteration = types.stopIteration;

var helpers = require('./helpers');
var wrap = helpers.wrap;

function numberSort(left, right) {
  return left > right;
}

// `range(start, end)` creates an integer range generator
function range(writer, start, end) {
  start = Math.floor(start);
  end = Math.floor(end);
  var increment = end > start ? 1 : -1;
  return bless(rangeInstance, 'gen');
  
  function rangeInstance() {
    if ( start === stopIteration ) {
      return stopIteration;
    }
    var result = start;
    if ( start === end ) {
      start = stopIteration;
    }
    else {
      start += increment;
    }
    return result;
  }
}

// `avg(value)` if an Array, returns the average (mathematical mean) of
// value's elements
function avg(writer, value) {
  if ( !isArray(value) ) {
    return typeof value === 'number' ? value : NaN;
  }
  if ( value.length === 0 ) {
    return 0;
  }
  for ( var i = 0, r = 0, l = value.length; i < l; r += value[i++] );
  return r / l;
}

// `max(value)` if an Array, return the greatest value in it
function max(writer, value) {
  if ( !isArray(value) ) {
    return typeof value === 'number' ? value : NaN;
  }
  return Math.max.apply(Math, value);
}

// `median(value)` if an Array, return the mathematical median of
// value's elements
function median(writer, value) {
  if ( !isArray(value) ) {
    return typeof value === 'number' ? value : NaN;
  }
  if ( value.length === 0 ) {
    return 0;
  }
  var temp = value.slice(0).sort(numberSort);
  if ( temp.length % 2 === 0 ) {
    var mid = temp.length / 2;
    return (temp[mid - 1] + temp[mid]) / 2;
  }
  return temp[((temp.length + 1) / 2) - 1];
}

// `min(value)` if an Array, return the lowest value in it
function min(writer, value) {
  if ( !isArray(value) ) {
    return typeof value === 'number' ? value : NaN;
  }
  return Math.min.apply(Math, value);
}

// `sum(value)` if an Array, return the mathematical sum of value's
// elements
function sum(writer, value) {
  if ( !isArray(value) ) {
    return typeof value === 'number' ? value : NaN;
  }
  for ( var i = 0, res = 0, l = value.length; i < l; res += value[i++] );
  return res;
}

// Math functions

// `number(value)` convert value to a Number
exports.number = wrap(Number);
// `abs(value)` returns the absolute value
exports.abs = wrap(Math.abs);
// `acos(value)` returns the arc-cosine of value (in radians)
exports.acos = wrap(Math.acos);
// `asin(value)` returns the arc-sine of value (in radians)
exports.asin = wrap(Math.asin);
// `atan(value)` returns the arc-tangent of value (in radians)
exports.atan = wrap(Math.atan);
// `atan2(x,y)` returns the arc-tangent of the coords
exports.atan2 = wrap(Math.atan2);
// `ceil(value)` rounds to the next highest integer
exports.ceil = wrap(Math.ceil);
// `cos(value)` returns the cosine of value (in radians)
exports.cos = wrap(Math.cos);
// `exp(x)` returns E to the power of x
exports.exp = wrap(Math.exp);
// `floor(value)` rounds to the next lowest integer
exports.floor = wrap(Math.floor);
// `log(value)` returns the natural logarithm
exports.log = wrap(Math.log);
// `pow(x,y)` returns x raised to the power of y
exports.pow = wrap(Math.pow);
// `random()` returns a random number (0 <= x < 1)
exports.random = wrap(Math.random);
// `round(value)` rounds up or down to the closest integer
exports.round = wrap(Math.round);
// `sin(value)` returns the sine of value (in radians)
exports.sin = wrap(Math.sin);
// `sqrt(value)` returns the square root
exports.sqrt = wrap(Math.sqrt);
// `tan(value)` returns the tangent of value (in radians)
exports.tan = wrap(Math.tan);

// ### Constants

// `E` is Euler's Number
exports.E = Math.E;
// `LN2` is the Natural Logarithm of 2
exports.LN2 = Math.LN2;
// `LN10` is the Natural Logarithm of 10
exports.LN10 = Math.LN10;
// `LOG2E` is the Base-2 Logarithm of E
exports.LOG2E = Math.LOG2E;
// `LOG10E` is the Base-10 Logarithm of E
exports.LOG10E = Math.LOG10E;
// `PI` is Pi
exports.PI = Math.PI;
// `SQRT1_2` is the Square Root of 1/2
exports.SQRT1_2 = Math.SQRT1_2;
// `SQRT2` is the Square Root of 2
exports.SQRT2 = Math.SQRT2;

// Exported Functions
exports.range = range;
exports.avg = avg;
exports.max = max;
exports.median = median;
exports.min = min;
exports.sum = sum;

},{"../../types":23,"../../util":24,"./helpers":16}],20:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var types = require('../../types');
var bless = types.bless;

var noOp = bless(function () {});

function counter(writer, start, increment) {
  if ( typeof start !== 'number' || isNaN(start) ) {
    start = 0;
  }
  if ( typeof increment !== 'number' || isNaN(increment) ) {
    increment = 1;
  }
  return bless(counterInstance);

  function counterInstance() {
    var result = start;
    start += increment;
    return result;
  }
}

function evenOdd(writer, even, odd) {
  if ( even === undefined ) {
    even = 'even';
  }
  if ( odd === undefined ) {
    odd = 'odd';
  }

  var current = true;
  return bless(evenOddInstance);

  function evenOddInstance() {
    current = !current;
    return current ? odd : even;
  }
}

function separator(writer, sep) {
  var empty = '';
  if ( sep === undefined ) {
    sep = ', ';
  }
  else if ( typeof sep === 'function' ) {
    empty = noOp;
  }

  var first = true;
  return bless(separatorInstance);

  function separatorInstance() {
    if ( first ) {
      first = false;
      return empty;
    }
    return sep;
  }
}

// Exports
exports.counter = counter;
exports.evenOdd = evenOdd;
exports.separator = separator;

},{"../../types":23}],21:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var format = require('../../format');
var types = require('../../types');
var helpers = require('./helpers');

var buildDeferredFormatter = format.buildDeferredFormatter;
var stringify = types.stringify;
var wrap = helpers.wrap;

// `build(value, supportFunctions)` converts the provided string and
// supportFunctions Object into an Interpol interpolation function.
function build(writer, value, supportFunctions) {
  var formatter = buildDeferredFormatter(stringify(value));
  return formatter(supportFunctions);
}

// `lower(value)` converts the provided string to lower-case and returns
// the result.
function lower(writer, value) {
  return stringify(value).toLowerCase();
}

// `split(delim, value)` splits the provided string wherever the
// specified delimiter (or whitespace) is encountered and returns the
// result.
function split(writer, delim, value) {
  if ( value === undefined ) {
    value = delim;
    delim = /\s*/;
  }
  return stringify(value).split(delim);
}

// `title(value)` converts the provided string to title-case and returns
// the result.  Title case converts the first character of each word to
// upper-case, and the rest to lower-case.
function title(writer, value) {
  return stringify(value).replace(/\w\S*/g, function (word) {
    return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
  });
}

// `upper(value)` converts the provided string to upper-case and returns
// the result.
function upper(writer, value) {
  return stringify(value).toUpperCase();
}

// `string(value)` converts value to a String
exports.string = wrap(String);

// Exported Functions
exports.build = build;
exports.lower = lower;
exports.split = split;
exports.title = title;
exports.upper = upper;

},{"../../format":11,"../../types":23,"./helpers":16}],22:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var format = require('./format');
var match = require('./match');

var types = require('./types');
var isInterpolRuntime = types.isInterpolRuntime;
var isInterpolFunction = types.isInterpolFunction;
var isInterpolPartial = types.isInterpolPartial;
var isInterpolGenerator = types.isInterpolGenerator;
var stopIteration = types.stopIteration;
var bless = types.bless;

var util = require('./util');
var isArray = util.isArray;
var mixin = util.mixin;
var extendObject = util.extendObject;
var objectKeys = util.objectKeys;

var internalResolvers = require('./resolvers/internal');
var createSystemResolver = internalResolvers.createSystemResolver;
var createMemoryResolver = internalResolvers.createMemoryResolver;

var writers = require('./writers');
var createStringWriter = writers.createStringWriter;
var nullWriter = writers.createNullWriter();

var noOp = bless(function () {});

var slice = Array.prototype.slice;

function createRuntime(interpol, runtimeOptions) {
  if ( isInterpolRuntime(runtimeOptions) ) {
    return runtimeOptions;
  }

  var options = mixin({}, runtimeOptions);
  var cacheModules = options.cache;
  var createDefaultResolvers = !options.resolvers;
  var resolvers = createDefaultResolvers ? [] : options.resolvers;

  var resolveExports = createResolver('resolveExports');
  var resolveModule = createResolver('resolveModule');

  var runtime = {
    __intRuntime: true,
    interpol: interpol,

    options: getOptions,
    resolvers: getResolvers,

    extendObject: util.extendObject,
    mixin: util.mixin,
    isTruthy: types.isTruthy,
    isFalsy: types.isFalsy,

    immediateFormatter: format.buildImmediateFormatter,
    deferredFormatter: format.buildDeferredFormatter,

    matches: match.matches,
    matcher: match.matcher,

    resolveExports: resolveExports,
    resolveModule: resolveModule,
    importer: buildImporter,
    defineModule: defineModule,
    definePartial: definePartial,
    defineGuardedPartial: defineGuardedPartial,
    cleanseArguments: cleanseArguments,

    getProperty: getProperty,
    getPath: getPath,
    bindPartial: bindPartial,
    loop: loop,
    exec: exec
  };

  if ( createDefaultResolvers ) {
    createSystemResolver(runtime);
    createMemoryResolver(runtime, true);
  }

  return runtime;

  function getOptions() {
    return options;
  }

  function getResolvers() {
    return resolvers;
  }

  function createResolver(methodName) {
    return resolve;

    function resolve(moduleName) {
      for ( var i = resolvers.length - 1; i >= 0; i-- ) {
        var module = resolvers[i][methodName](moduleName);
        if ( module ) {
          return module;
        }
      }
      return undefined;
    }
  }

  // where exports are actually resolved. raiseError will be false
  // if we're in the process of evaluating a template for the purpose
  // of yielding its exports
  function buildImporter(moduleName) {
    var importer = dynamicImporter;
    var module;

    return performImport;

    function performImport() {
      return importer();
    }

    function cachedImporter() {
      return module;
    }

    function dynamicImporter() {
      module = resolveExports(moduleName);
      if ( !module ) {
        throw new Error("Module '" + moduleName + "' not resolved");
      }
      if ( cacheModules ) {
        importer = cachedImporter;
      }
      return module;
    }
  }
}

function createToString(func) {
  var stringWriters = [];
  var stringWritersAvail = 0;
  return toString;

  function toString() {
    var writer;
    if ( stringWritersAvail ) {
      writer = stringWriters[--stringWritersAvail];
    }
    else {
      writer = createStringWriter();
    }
    try {
      func(writer);
      var result = writer.done();
      stringWriters[stringWritersAvail++] = writer;
      return result;
    }
    catch ( err ) {
      writer.reset();
      stringWriters[stringWritersAvail++] = writer;
      throw err;
    }
  }
}

function defineModule(template) {
  var stringWriters = [];
  var stringWritersAvail = 0;
  var defaultOptions = {};
  var exportedContext;

  templateInterface.__intModule = true;
  templateInterface.exports = templateExports;
  return templateInterface;

  function templateInterface(obj, templateOptions) {
    var ctx = obj ? extendObject(obj) : {};
    if ( !templateOptions ) {
      templateOptions = defaultOptions;
    }

    // If no Writer is provided, create a throw-away Array Writer
    var writer = templateOptions.writer;
    var useStringWriter = !writer;

    try {
      if ( useStringWriter ) {
        if ( stringWritersAvail ) {
          writer = stringWriters[--stringWritersAvail];
        }
        else {
          writer = createStringWriter();
        }
        template(ctx, writer);
        var result = writer.done();
        stringWriters[stringWritersAvail++] = writer;
        return result;
      }
      template(ctx, writer);
      return writer.done();
    }
    catch ( err ) {
      writer.reset();
      if ( useStringWriter ) {
        stringWriters[stringWritersAvail++] = writer;
      }
      if ( typeof templateOptions.errorCallback === 'function' ) {
        templateOptions.errorCallback(err);
        return;
      }
      // Re-raise if no callback
      throw err;
    }
  }

  /**
   * Returns the symbols (partials and assignments) that the runtime
   * template will product against an empty `{}` context Object.  This is
   * the method by which Interpol imports work.  Partials produced with
   * this method still have access to the global context.
   */
  function templateExports() {
    /* istanbul ignore if: guard */
    if ( exportedContext ) {
      return exportedContext;
    }

    // `__intExports` is an indicator to evaluators that we're processing
    // exports and so they can be a bit lax about reporting errors or
    // resolving imports

    exportedContext = {};
    exportedContext.__intExports = true;
    template(exportedContext, nullWriter);
    delete exportedContext.__intExports;

    return exportedContext;
  }
}

function definePartial(partial) {
  partial.__intFunction = 'part';
  partial.toString = createToString(partial);
  return partial;
}

function defineGuardedPartial(originalPartial, envelope) {
  if ( !isInterpolPartial(originalPartial) ) {
    originalPartial = noOp;
  }
  return definePartial(envelope(originalPartial));
}

/* istanbul ignore next: sanity checker */
function cleanseArguments(arr, startIdx) {
  for ( var i = startIdx, len = arr.length; i < len; i++ ) {
    if ( arr[i] === null ) {
      arr[i] = undefined;
    }
  }
}

function getProperty(obj, property) {
  if ( obj === undefined || obj === null ) {
    return undefined;
  }
  var res = obj[property];
  return res === null ? undefined : res;
}

function getPath(obj) {
  for ( var i = 1, len = arguments.length; i < len; i++ ) {
    if ( obj === undefined || obj === null ) {
      return undefined;
    }
    obj = obj[arguments[i]];
  }
  return obj === null ? undefined : obj;
}

function bindPartial(ctx, func, callArgs) {
  /* istanbul ignore if: short-circuit */
  if ( !isInterpolFunction(func) ) {
    if ( ctx.__intExports ) {
      return undefined;
    }
    throw new Error("Attempting to bind an unblessed function");
  }

  var argTemplate = [undefined].concat(callArgs);
  boundPartial.__intFunction = func.__intFunction;
  boundPartial.toString = createToString(boundPartial);
  return boundPartial;

  function boundPartial(writer) {
    /* jshint validthis:true */
    var applyArgs = argTemplate.slice(0).concat(slice.call(arguments, 1));
    applyArgs[0] = writer;
    return func.apply(this, applyArgs);
  }
}

function loop(data, loopCallback) {
  var i, len, name, value;

  if ( isArray(data) ) {
    for ( i = 0, len = data.length; i < len; i++ ) {
      value = data[i];
      loopCallback(value === null ? undefined : value);
    }
    return;
  }
  
  if ( typeof data === 'object' && data !== null ) {
    var items = objectKeys(data);
    for ( i = 0, len = items.length; i < len; i++ ) {
      name = items[i];
      value = data[name];
      loopCallback({
        name: name,
        value: value === null ? undefined : value
      });
    }
    return;
  }
  
  if ( isInterpolGenerator(data) ) {
    for ( value = data(); value !== stopIteration; value = data() ) {
      loopCallback(value);
    }
  }
}

function exec(ctx, func, args) {
  /* istanbul ignore if: short-circuit */
  if ( !isInterpolFunction(func) ) {
    if ( ctx.__intExports ) {
      return undefined;
    }
    throw new Error("Attempting to call an unblessed function");
  }
  return func.apply(null, args);
}

// Exported Functions
exports.createRuntime = createRuntime;

},{"./format":11,"./match":13,"./resolvers/internal":14,"./types":23,"./util":24,"./writers":26}],23:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var util = require('./util');

var isArray = util.isArray;
var objectKeys = util.objectKeys;

function emptyString() {
  return '';
}

var stopIteration = {
  __intStopIteration: true
};

/**
 * Returns whether or not an Object is an Interpol Runtime instance.
 *
 * @param {Object} obj the Object to check
 */
function isInterpolRuntime(obj) {
  return typeof obj === 'object' && obj !== null && obj.__intRuntime;
}

/**
 * Returns whether or not an Object is an Interpol Node Module.
 *
 * @param {Object} obj the Object to check
 */
function isInterpolNodeModule(obj) {
  return typeof obj === 'object' && obj !== null && obj.__intNodeModule;
}

/**
 * Returns whether or not a Function is a compiled Interpol Module.
 *
 * @param {Function} func the Function to check
 */
function isInterpolModule(func) {
  return typeof func === 'function' && func.__intModule;
}

/**
 * Returns whether or not a Function is 'blessed' as Interpol-compatible.
 *
 * @param {Function} func the Function to check
 */
function isInterpolFunction(func) {
  return typeof func === 'function' && func.__intFunction;
}

/**
 * Same as isInterpolFunction except that it's checking specifically for
 * a declared partial.
 *
 * @param {Function} func the Function to check
 */
function isInterpolPartial(func) {
  return typeof func === 'function' && func.__intFunction === 'part';
}

/**
 * Same as isInterpolFunction except that it's checking specifically for
 * a generator.
 *
 * @param {Function} func the Function to check
 */
function isInterpolGenerator(func) {
  return typeof func === 'function' && func.__intFunction === 'gen';
}

/**
 * 'bless' a Function or String as being Interpol-compatible.  In the case of
 * a String, it will mark the String as capable of being rendered without 
 * escaping.  With the exception of generators, all Functions in Interpol
 *  will be passed a Writer instance as the first argument. 
 *
 * @param {Function|String} value the String or Function to 'bless'
 * @param {String} [funcType] the blessed type ('wrap' or 'string' by default) 
 */
function bless(value, funcType) {
  var type = typeof value;

  switch ( type ) {
    case 'string':
      var blessString = function () { return value; };
      blessString.toString = blessString;
      blessString.__intFunction = 'string';
      return blessString;

    case 'function':
      if ( value.__intFunction ) {
        return value;
      }
      value.__intFunction = funcType || 'wrap';
      value.toString = emptyString;
      return value;

    default:
      throw new Error("Argument to bless must be a Function or String");
  }
}

function stringifyArray(value, stringifier) {
  var result = [];
  for ( var i = 0, len = value.length; i < len; i++ ) {
    result[i] = stringifier(value[i]);
  }
  return result.join(' ');
}

/**
 * Stringify the provided value for Interpol's purposes.
 *
 * @param {Mixed} value the value to stringify
 */
function stringify(value) {
  switch ( typeof value ) {
    case 'string':
      return value;

    case 'number':
      return '' + value;

    case 'boolean':
      return value ? 'true' : 'false';

    case 'function':
      return value.__intFunction ? value.toString() : '';

    case 'object':
      if ( isArray(value) ) {
        return stringifyArray(value, stringify);
      }
      return value === null ? '' : value.toString();

    default:
      return '';
  }
}

var ampRegex = /&/g;
var ltRegex = /</g;
var gtRegex = />/g;
var quoteRegex = /"/g;
var aposRegex = /'/g;

/**
 * Escape the provided value for the purposes of rendering it as an HTML
 * attribute.
 *
 * @param {Mixed} value the value to escape
 */
var escapeAttribute = createEscapedStringifier(/[&<>'"]/g, replaceAttribute);

/**
 * Escape the provided value for the purposes of rendering it as HTML
 * content.
 *
 * @param {Mixed} value the value to escape
 */
var escapeContent = createEscapedStringifier(/[&<>]/g, replaceContent);

function replaceAttribute(value) {
  return value.replace(ampRegex, '&amp;')
              .replace(ltRegex, '&lt;')
              .replace(gtRegex, '&gt;')
              .replace(quoteRegex, '&quot;')
              .replace(aposRegex, '&#39;');
}

function replaceContent(value) {
  return value.replace(ampRegex, '&amp;')
              .replace(ltRegex, '&lt;')
              .replace(gtRegex, '&gt;');
}

function createEscapedStringifier(escapeRegex, replaceFunction) {
  return escapedStringifier;

  // This is very similar to 'stringify' with the exception of 'string'
  function escapedStringifier(value) {
    switch ( typeof value ) {
      case 'string':
        return escapeRegex.test(value) ? replaceFunction(value) : value;

      case 'number':
        return '' + value;

      case 'boolean':
        return value ? 'true' : 'false';

      case 'function':
        return value.__intFunction ? value.toString() : '';

      case 'object':
        if ( isArray(value) ) {
          return stringifyArray(value, escapedStringifier);
        }
        return value === null ? '' : value.toString();
        
      default:
        return '';
    }
  }
}

/**
 * Checks whether or not the provided value is *truthy* by Interpol's
 * standards.
 *
 * @param {Mixed} value the value to test
 * @returns {boolean} if the value constitutes a *truthy* one
 */
function isTruthy(value) {
  if ( !value ) {
    return false;
  }
  if ( isArray(value) ) {
    return value.length > 0;
  }
  if ( typeof value === 'object' && value !== null ) {
    return objectKeys(value).length > 0;
  }
  return true;
}

/**
 * Checks whether or not the provided value is *falsy* by Interpol's
 * standards.
 *
 * @param {Mixed} value the value to test
 * @returns {boolean} if the value constitutes a *falsy* one
 */
function isFalsy(value) {
  if ( !value ) {
    return true;
  }
  if ( isArray(value) ) {
    return value.length === 0;
  }
  if ( typeof value === 'object' && value !== null ) {
    return objectKeys(value).length === 0;
  }
  return false;
}

// Exported Functions
exports.stopIteration = stopIteration;
exports.isInterpolRuntime = isInterpolRuntime;
exports.isInterpolNodeModule = isInterpolNodeModule;
exports.isInterpolModule = isInterpolModule;
exports.isInterpolFunction = isInterpolFunction;
exports.isInterpolPartial = isInterpolPartial;
exports.isInterpolGenerator = isInterpolGenerator;
exports.stringify = stringify;
exports.escapeAttribute = escapeAttribute;
exports.escapeContent = escapeContent;
exports.bless = bless;
exports.isTruthy = isTruthy;
exports.isFalsy = isFalsy;

},{"./util":24}],24:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

// Interpol-specific utilities and polyfills.  These are implemented *as*
// Interpol uses them rather than being strictly ES5 compatible.

var toString = Object.prototype.toString;

var isArray = Array.isArray;
/* istanbul ignore if: won't happen in node */
if ( !isArray ) {
  isArray = function _isArray(obj) {
    return obj && toString.call(obj) === '[object Array]';
  };
}

var objectKeys = Object.keys;
/* istanbul ignore if: won't happen in node */
if ( !objectKeys ) {
  objectKeys = function _objectKeys(obj) {
    var keys = [];
    for ( var key in obj ) {
      if ( obj.hasOwnProperty(key) ) {
        keys.push(key);
      }
    }
    return keys;
  };
}

var extendObject;
/* istanbul ignore else: won't happen in node */
var testProto = { __proto__: { works: true } };           // jshint ignore:line
if ( testProto.works && objectKeys(testProto).length === 0 ) {
  extendObject = function _fastExtendObject(obj) {
    return { __proto__: obj };                            // jshint ignore:line
  };
}
else if ( Object.create ) {
  extendObject = Object.create;
}
else {
  extendObject = (function () {
    function FakeConstructor() {}
    return function _slowExtendObject(obj) {
      FakeConstructor.prototype = obj;
      return new FakeConstructor();
    };
  })();
}

function mixin(target) {
  for ( var i = 1, ilen = arguments.length; i < ilen; i++ ) {
    var src = arguments[i];
    if ( typeof src !== 'object' || src === null || isArray(src) ) {
      continue;
    }
    var keys = objectKeys(src);
    for ( var j = keys.length - 1; j >= 0; j-- ) {
      var key = keys[j];
      target[key] = src[key];
    }
  }
  return target;
}

var each;
/* istanbul ignore else: won't happen in node */
if ( Array.prototype.forEach ) {
  each = (function () {
    var inner = Array.prototype.forEach;
    return function _each(value, callback) {
      return inner.call(value, callback);
    };
  })();
}
else {
  each = function _each(arr, callback) {
    for ( var i = 0, len = arr.length; i < len; i++ ) {
      callback(arr[i], i);
    }
  };
}

var map;
/* istanbul ignore else: won't happen in node */
if ( Array.prototype.map ) {
  map = (function () {
    var inner = Array.prototype.map;
    return function _map(value, callback) {
      return inner.call(value, callback);
    };
  })();
}
else {
  map = function _map(arr, callback) {
    var result = [];
    each(arr, function (item, i) {
      result[i] = callback(item);
    });
    return result;
  };
}

var filter;
/* istanbul ignore else: won't happen in node */
if ( Array.prototype.filter ) {
  filter = (function () {
    var inner = Array.prototype.filter;
    return function _filter(value, callback) {
      return inner.call(value, callback);
    };
  })();
}
else {
  filter = function _filter(arr, callback) {
    var result = [];
    each(arr, function (item) {
      if ( !callback(item) ) {
        result.push(item);
      }
    });
    return result;
  };
}

function selfMap(arr, callback) {
  each(arr, function (item, i) {
    arr[i] = callback(item);
  });
  return arr;
}

// Exported Functions
exports.isArray = isArray;
exports.extendObject = extendObject;
exports.objectKeys = objectKeys;
exports.mixin = mixin;

exports.each = each;
exports.map = map;
exports.filter = filter;
exports.selfMap = selfMap;

},{}],25:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var util = require('../util');
var string = require('./string');

var createStringWriter = string.createStringWriter;

var REPLACE = createDOMWriter.REPLACE = 'replace';
var APPEND = createDOMWriter.APPEND = 'append';
var INSERT = createDOMWriter.INSERT = 'insert';

/**
 * Creates a DOMWriter.  A DOMWriter attaches itself to a DOM Element,
 * and will manipulate that Element's content when a template is rendered
 * with it.  The writer is very simple and won't cover all use-cases, it
 * also may not be the most performant approach.
 *
 * The default mode is REPLACE, meaning all of the Element's children are
 * replaced when the associated template is rendered.  INSERT and APPEND
 * will insert new renderings to the beginning or end of the child list
 * respectively.
 *
 * @param {Element} parentElement the Element to which this DOMWriter attaches
 * @param {String} [renderMode] the DOM rendering mode: REPLACE|APPEND|INSERT
 */
 
/* istanbul ignore next: browser-only */
function createDOMWriter(parentElement, renderMode) {
  var writer = createStringWriter();
  var writerDone = writer.done;

  if ( renderMode === undefined ) {
    renderMode = REPLACE;
  }

  switch ( renderMode ) {
    case APPEND:
      writer.done = appendEndRender;
      break;

    case INSERT:
      writer.done = insertEndRender;
      break;

    case REPLACE:
      writer.done = replaceEndRender;
      break;

    default:
      throw new Error("Invalid renderMode: " + renderMode);
  }

  function appendEndRender() {
    var container = document.createElement("span");
    container.innerHTML = writerDone();
    parentElement.appendChild(container);
  }

  function insertEndRender() {
    var container = document.createElement("span");
    container.innerHTML = writerDone();
    parentElement.insertBefore(container, parentElement.firstChild);
  }

  function replaceEndRender() {
    parentElement.innerHTML = writerDone();
  }
}

// Exported Functions
exports.createDOMWriter = createDOMWriter;

},{"../util":24,"./string":28}],26:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var domWriter = require('./dom');
var nullWriter = require('./null');
var stringWriter = require('./string');

// Exported Functions
exports.createDOMWriter = domWriter.createDOMWriter;
exports.createNullWriter = nullWriter.createNullWriter;
exports.createStringWriter = stringWriter.createStringWriter;

},{"./dom":25,"./null":27,"./string":28}],27:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var util = require('../util');

function noOp() {}

/**
 * Creates a NullWriter.  All calls to this writer find their way into the
 * bit bucket.  Its primary purpose is to support the background rendering of
 * modules in order to yield their exported symbols.
 */
function createNullWriter() {
  return {
    done: noOp,
    reset: noOp,
    startElement: noOp,
    selfCloseElement: noOp,
    endElement: noOp,
    comment: noOp,
    docType: noOp,
    content: noOp,
    raw: noOp
  };
}

// Exported Functions
exports.createNullWriter = createNullWriter;

},{"../util":24}],28:[function(require,module,exports){
/*
 * Interpol (Logicful HTML Templates)
 * Licensed under the MIT License
 * see doc/LICENSE.md
 *
 * @author Thomas S. Bradford (kode4food.it)
 */

"use strict";

var types = require('../types');
var util = require('../util');

var stringify = types.stringify;
var escapeAttribute = types.escapeAttribute;
var escapeContent = types.escapeContent;

/**
 * Creates a StringWriter.  Interpol will create one by default if it is not
 * provided as an option to a compiled template.  A StringWriter manages the
 * writing of content as an underlying Array of Strings.  This Array is joined
 * and returned when the `done()` function is called.
 */
function createStringWriter() {
  var buffer = '';

  return {
    done: done,
    reset: reset,
    startElement: startElement,
    selfCloseElement: selfCloseElement,
    endElement: endElement,
    comment: comment,
    docType: docType,
    content: content,
    raw: raw
  };

  function done() {
    var result = buffer;
    buffer = '';
    return result;
  }

  function reset() {
    buffer = '';
  }

  function writeAttributes(attributes) {
    for ( var key in attributes ) {
      var val = attributes[key];
      if ( typeof val !== 'boolean' ) {
        buffer += " " + stringify(key) + "=\"" + escapeAttribute(val) + "\"";
        continue;
      }
      if ( val ) {
        buffer += " " + stringify(key);
      }
    }
  }

  function startElement(tagName, attributes) {
    buffer += "<" + stringify(tagName);
    writeAttributes(attributes);
    buffer += ">";
  }

  function selfCloseElement(tagName, attributes) {
    buffer += "<" + stringify(tagName);
    writeAttributes(attributes);
    buffer += " />";
  }

  function endElement(tagName) {
    buffer += "</" + stringify(tagName) + ">";
  }

  function comment(content) {
    buffer += "<!--" + content + "-->";
  }

  function docType(rootElement) {
    buffer += "<!DOCTYPE " + stringify(rootElement) + ">";
  }

  function content(value) {
    buffer += escapeContent(value);
  }

  function raw(value) {
    buffer += value;
  }
}

// Exported Functions
exports.createStringWriter = createStringWriter;

},{"../types":23,"../util":24}],29:[function(require,module,exports){

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJicm93c2VyaWZ5L2NvbXBpbGVyLmpzIiwiYnJvd3NlcmlmeS9zdGFuZGFyZC5qcyIsImJ1aWxkL3BhcnNlci5qcyIsImxpYi9jb21waWxlci9hbm5vdGF0aW9ucy5qcyIsImxpYi9jb21waWxlci9jb2RlZ2VuLmpzIiwibGliL2NvbXBpbGVyL2luZGV4LmpzIiwibGliL2NvbXBpbGVyL2phdmFzY3JpcHQuanMiLCJsaWIvY29tcGlsZXIvcGFyc2VyLmpzIiwibGliL2NvbXBpbGVyL3Jld3JpdGVyLmpzIiwibGliL2NvbXBpbGVyL3N0dWIuanMiLCJsaWIvZm9ybWF0LmpzIiwibGliL2ludGVycG9sLmpzIiwibGliL21hdGNoLmpzIiwibGliL3Jlc29sdmVycy9pbnRlcm5hbC5qcyIsImxpYi9yZXNvbHZlcnMvbWVtb3J5LmpzIiwibGliL3Jlc29sdmVycy9zeXN0ZW0vaGVscGVycy5qcyIsImxpYi9yZXNvbHZlcnMvc3lzdGVtL2luZGV4LmpzIiwibGliL3Jlc29sdmVycy9zeXN0ZW0vbGlzdC5qcyIsImxpYi9yZXNvbHZlcnMvc3lzdGVtL21hdGguanMiLCJsaWIvcmVzb2x2ZXJzL3N5c3RlbS9yZW5kZXIuanMiLCJsaWIvcmVzb2x2ZXJzL3N5c3RlbS9zdHJpbmcuanMiLCJsaWIvcnVudGltZS5qcyIsImxpYi90eXBlcy5qcyIsImxpYi91dGlsLmpzIiwibGliL3dyaXRlcnMvZG9tLmpzIiwibGliL3dyaXRlcnMvaW5kZXguanMiLCJsaWIvd3JpdGVycy9udWxsLmpzIiwibGliL3dyaXRlcnMvc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3FCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzltQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qXG4gKiBJbnRlcnBvbCAoTG9naWNmdWwgSFRNTCBUZW1wbGF0ZXMpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIHNlZSBkb2MvTElDRU5TRS5tZFxuICpcbiAqIEBhdXRob3IgVGhvbWFzIFMuIEJyYWRmb3JkIChrb2RlNGZvb2QuaXQpXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoaXMgbW9kdWxlIGlzIHVzZWQgdG8gY29sbGVjdCB0aGUgcmVxdWlyZW1lbnRzIGZvciBhIGNvbXBpbGVyLWluY2x1ZGVkXG4vLyBCcm93c2VyaWZ5IGJ1aWxkLiAgSXQncyBvZiBubyBpbnRlcmVzdCB0byBub2RlLmpzXG5cbnJlcXVpcmUoJy4vc3RhbmRhcmQnKTtcbnJlcXVpcmUoJy4uL2xpYi9jb21waWxlcicpO1xuIiwiLypcbiAqIEludGVycG9sIChMb2dpY2Z1bCBIVE1MIFRlbXBsYXRlcylcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogc2VlIGRvYy9MSUNFTlNFLm1kXG4gKlxuICogQGF1dGhvciBUaG9tYXMgUy4gQnJhZGZvcmQgKGtvZGU0Zm9vZC5pdClcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gVGhpcyBtb2R1bGUgaXMgdXNlZCB0byBjb2xsZWN0IHRoZSByZXF1aXJlbWVudHMgZm9yIGEgbWluaW1hbFxuLy8gQnJvd3NlcmlmeSBidWlsZC4gIEl0J3Mgb2Ygbm8gaW50ZXJlc3QgdG8gbm9kZS5qc1xuXG4vLyBTZXQgdGhlIEludGVycG9sIGJyb3dzZXIgZ2xvYmFsXG52YXIgaW50ZXJwb2wgPSB3aW5kb3cuaW50ZXJwb2wgPSByZXF1aXJlKCcuLi9saWIvaW50ZXJwb2wnKTtcblxuLy8gUmVnaXN0ZXIgdGhlIFdyaXRlcnMgZm9yIGVhc2llciBhY2Nlc3NcbnZhciB3cml0ZXJzID0gcmVxdWlyZSgnLi4vbGliL3dyaXRlcnMnKTtcbmludGVycG9sLmNyZWF0ZURPTVdyaXRlciA9IHdyaXRlcnMuY3JlYXRlRE9NV3JpdGVyO1xuaW50ZXJwb2wuY3JlYXRlTnVsbFdyaXRlciA9IHdyaXRlcnMuY3JlYXRlTnVsbFdyaXRlcjtcbmludGVycG9sLmNyZWF0ZVN0cmluZ1dyaXRlciA9IHdyaXRlcnMuY3JlYXRlU3RyaW5nV3JpdGVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIC8qXG4gICAqIEdlbmVyYXRlZCBieSBQRUcuanMgMC44LjAuXG4gICAqXG4gICAqIGh0dHA6Ly9wZWdqcy5tYWpkYS5jei9cbiAgICovXG5cbiAgZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgICBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH1cbiAgICBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgb2Zmc2V0LCBsaW5lLCBjb2x1bW4pIHtcbiAgICB0aGlzLm1lc3NhZ2UgID0gbWVzc2FnZTtcbiAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgdGhpcy5mb3VuZCAgICA9IGZvdW5kO1xuICAgIHRoaXMub2Zmc2V0ICAgPSBvZmZzZXQ7XG4gICAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gICA9IGNvbHVtbjtcblxuICAgIHRoaXMubmFtZSAgICAgPSBcIlN5bnRheEVycm9yXCI7XG4gIH1cblxuICBwZWckc3ViY2xhc3MoU3ludGF4RXJyb3IsIEVycm9yKTtcblxuICBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB7fSxcblxuICAgICAgICBwZWckRkFJTEVEID0ge30sXG5cbiAgICAgICAgcGVnJHN0YXJ0UnVsZUluZGljZXMgPSB7IHN0YXJ0OiAwIH0sXG4gICAgICAgIHBlZyRzdGFydFJ1bGVJbmRleCAgID0gMCxcblxuICAgICAgICBwZWckY29uc3RzID0gW1xuICAgICAgICAgIHBlZyRGQUlMRUQsXG4gICAgICAgICAgXCJmb3JcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJmb3JcIiwgZGVzY3JpcHRpb246IFwiXFxcImZvclxcXCJcIiB9LFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdmcic7IH0sXG4gICAgICAgICAgXCJkZWZcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJkZWZcIiwgZGVzY3JpcHRpb246IFwiXFxcImRlZlxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gJ2RlJzsgfSxcbiAgICAgICAgICBcImZyb21cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJmcm9tXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJmcm9tXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiAnaW0nOyB9LFxuICAgICAgICAgIFwiaW1wb3J0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiaW1wb3J0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJpbXBvcnRcXFwiXCIgfSxcbiAgICAgICAgICBcImV4cG9ydFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImV4cG9ydFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZXhwb3J0XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiAnZXgnOyB9LFxuICAgICAgICAgIFwibGV0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibGV0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJsZXRcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdhcyc7IH0sXG4gICAgICAgICAgXCJhbmRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhbmRcIiwgZGVzY3JpcHRpb246IFwiXFxcImFuZFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gJ2FuJzsgfSxcbiAgICAgICAgICBcIm9yXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwib3JcIiwgZGVzY3JpcHRpb246IFwiXFxcIm9yXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiAnb3InOyB9LFxuICAgICAgICAgIFwibGlrZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImxpa2VcIiwgZGVzY3JpcHRpb246IFwiXFxcImxpa2VcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdtYSc7IH0sXG4gICAgICAgICAgXCJsdFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImx0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJsdFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gJ2x0JzsgfSxcbiAgICAgICAgICBcImd0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZ3RcIiwgZGVzY3JpcHRpb246IFwiXFxcImd0XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiAnZ3QnOyB9LFxuICAgICAgICAgIFwibW9kXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW9kXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb2RcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdtbyc7IH0sXG4gICAgICAgICAgXCJzZWxmXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwic2VsZlwiLCBkZXNjcmlwdGlvbjogXCJcXFwic2VsZlxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gJ3NlJzsgfSxcbiAgICAgICAgICBcIm5vdFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm5vdFwiLCBkZXNjcmlwdGlvbjogXCJcXFwibm90XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiAnbm8nOyB9LFxuICAgICAgICAgIFwibmlsXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibmlsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJuaWxcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICBcImlmXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiaWZcIiwgZGVzY3JpcHRpb246IFwiXFxcImlmXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgIFwidW5sZXNzXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidW5sZXNzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ1bmxlc3NcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgIFwidHJ1ZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRydWVcIiwgZGVzY3JpcHRpb246IFwiXFxcInRydWVcXFwiXCIgfSxcbiAgICAgICAgICBcImZhbHNlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZmFsc2VcIiwgZGVzY3JpcHRpb246IFwiXFxcImZhbHNlXFxcIlwiIH0sXG4gICAgICAgICAgXCJhc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImFzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhc1xcXCJcIiB9LFxuICAgICAgICAgIFwiaW5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJpblwiLCBkZXNjcmlwdGlvbjogXCJcXFwiaW5cXFwiXCIgfSxcbiAgICAgICAgICBcImVsc2VcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJlbHNlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJlbHNlXFxcIlwiIH0sXG4gICAgICAgICAgXCJlbmRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJlbmRcIiwgZGVzY3JpcHRpb246IFwiXFxcImVuZFxcXCJcIiB9LFxuICAgICAgICAgIFwibGVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJsZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwibGVcXFwiXCIgfSxcbiAgICAgICAgICBcImx0ZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImx0ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwibHRlXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiAnbGUnOyB9LFxuICAgICAgICAgIFwiZ2VcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJnZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZ2VcXFwiXCIgfSxcbiAgICAgICAgICBcImd0ZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImd0ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZ3RlXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiAnZ2UnOyB9LFxuICAgICAgICAgIFwid2hlblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIndoZW5cIiwgZGVzY3JpcHRpb246IFwiXFxcIndoZW5cXFwiXCIgfSxcbiAgICAgICAgICBcIndoZXJlXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwid2hlcmVcIiwgZGVzY3JpcHRpb246IFwiXFxcIndoZXJlXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltKGlkLCAnaWQnKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBbXSxcbiAgICAgICAgICBmdW5jdGlvbihzdGFydCwgY29udCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydCArIGNvbnQuam9pbignJyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgL15bJF9hLXpBLVpdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWyRfYS16QS1aXVwiLCBkZXNjcmlwdGlvbjogXCJbJF9hLXpBLVpdXCIgfSxcbiAgICAgICAgICAvXlskX2EtekEtWjAtOV0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbJF9hLXpBLVowLTldXCIsIGRlc2NyaXB0aW9uOiBcIlskX2EtekEtWjAtOV1cIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHN0YXJ0LCBjb250KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bShzdGFydCArIGNvbnQuam9pbignJyksICdpZCcpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIC9eW2EtekEtWl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aXVwiLCBkZXNjcmlwdGlvbjogXCJbYS16QS1aXVwiIH0sXG4gICAgICAgICAgL15bMC05XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlswLTldXCIsIGRlc2NyaXB0aW9uOiBcIlswLTldXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihjaGFycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW0oY2hhcnMuam9pbignJyksICdpZCcpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIC9eW15cXDAtXFx4MUYnXCI+IFxcLz1dLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW15cXFxcMC1cXFxceDFGJ1xcXCI+IFxcXFwvPV1cIiwgZGVzY3JpcHRpb246IFwiW15cXFxcMC1cXFxceDFGJ1xcXCI+IFxcXFwvPV1cIiB9LFxuICAgICAgICAgIC9eW2REXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltkRF1cIiwgZGVzY3JpcHRpb246IFwiW2REXVwiIH0sXG4gICAgICAgICAgL15bb09dLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW29PXVwiLCBkZXNjcmlwdGlvbjogXCJbb09dXCIgfSxcbiAgICAgICAgICAvXltjQ10vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbY0NdXCIsIGRlc2NyaXB0aW9uOiBcIltjQ11cIiB9LFxuICAgICAgICAgIC9eW3RUXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlt0VF1cIiwgZGVzY3JpcHRpb246IFwiW3RUXVwiIH0sXG4gICAgICAgICAgL15beVldLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW3lZXVwiLCBkZXNjcmlwdGlvbjogXCJbeVldXCIgfSxcbiAgICAgICAgICAvXltwUF0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbcFBdXCIsIGRlc2NyaXB0aW9uOiBcIltwUF1cIiB9LFxuICAgICAgICAgIC9eW2VFXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltlRV1cIiwgZGVzY3JpcHRpb246IFwiW2VFXVwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBcIkRPQ1RZUEVcIjsgfSxcbiAgICAgICAgICAvXlsxLTldLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzEtOV1cIiwgZGVzY3JpcHRpb246IFwiWzEtOV1cIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGgsIHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaCArIHQuam9pbignJyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAvXltcXC0rXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxcLStdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxcLStdXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihzLCBkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdlJyArIChzID8gcyA6ICcrJykgKyBkLmpvaW4oJycpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwiLlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi5cIiwgZGVzY3JpcHRpb246IFwiXFxcIi5cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcuJyArIGQuam9pbignJyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oYywgZiwgZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW0ocGFyc2VGbG9hdChjICsgKGYgPyBmIDogJycpICsgKGUgPyBlIDogJycpKSwgJ2xpdCcpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIHsgdHlwZTogXCJhbnlcIiwgZGVzY3JpcHRpb246IFwiYW55IGNoYXJhY3RlclwiIH0sXG4gICAgICAgICAgL15bIFxcdFxceDBCXFxmXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlsgXFxcXHRcXFxceDBCXFxcXGZdXCIsIGRlc2NyaXB0aW9uOiBcIlsgXFxcXHRcXFxceDBCXFxcXGZdXCIgfSxcbiAgICAgICAgICAvXltcXG5cXHJdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW1xcXFxuXFxcXHJdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxcblxcXFxyXVwiIH0sXG4gICAgICAgICAgXCIjXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiI1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiI1xcXCJcIiB9LFxuICAgICAgICAgIFwiXFxcIlxcXCJcXFwiXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxcIlxcXCJcXFwiXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcIlxcXFxcXFwiXFxcXFxcXCJcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihjKSB7IHJldHVybiBjOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGNoYXJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bUludGVycG9sYXRlKGNoYXJzLmpvaW4oJycpLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcIicnJ1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIicnJ1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiJycnXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oY2hhcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltSW50ZXJwb2xhdGUoY2hhcnMuam9pbignJykpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwiXFxcIlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcXCJcIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxcXFwiXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBzeW0oJycsICdsaXQnKTsgfSxcbiAgICAgICAgICBcIidcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCInXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCInXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oYykgeyByZXR1cm4gc3ltSW50ZXJwb2xhdGUoYy5qb2luKCcnKSwgdHJ1ZSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oYykgeyByZXR1cm4gc3ltSW50ZXJwb2xhdGUoYy5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgL15bXlwiXFxcXF0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXlxcXCJcXFxcXFxcXF1cIiwgZGVzY3JpcHRpb246IFwiW15cXFwiXFxcXFxcXFxdXCIgfSxcbiAgICAgICAgICAvXlteJ1xcXFxdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW14nXFxcXFxcXFxdXCIsIGRlc2NyaXB0aW9uOiBcIlteJ1xcXFxcXFxcXVwiIH0sXG4gICAgICAgICAgXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcXFxcXFxcXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcXFxcXFxcXFxcXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBcIlxcXFxcIjsgfSxcbiAgICAgICAgICBcIlxcXFxcXFwiXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxcXFxcXCJcIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxcXFxcXFxcXFxcXCJcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdcIic7IH0sXG4gICAgICAgICAgXCJcXFxcJ1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcXFwnXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcXCdcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIFwiJ1wiOyB9LFxuICAgICAgICAgIFwiXFxcXGJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcYlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFxiXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBcIlxcYlwiOyB9LFxuICAgICAgICAgIFwiXFxcXGZcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcZlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFxmXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBcIlxcZlwiOyB9LFxuICAgICAgICAgIFwiXFxcXG5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcblwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFxuXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBcIlxcblwiOyB9LFxuICAgICAgICAgIFwiXFxcXHJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcclwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFxyXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBcIlxcclwiOyB9LFxuICAgICAgICAgIFwiXFxcXHRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcdFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFx0XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBcIlxcdFwiOyB9LFxuICAgICAgICAgIFwiPT1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI9PVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPT1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdlcSc7IH0sXG4gICAgICAgICAgXCIhPVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiE9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIhPVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gJ25xJzsgfSxcbiAgICAgICAgICBcIitcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIrXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIrXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiAnYWQnOyB9LFxuICAgICAgICAgIFwiLVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi1cIiwgZGVzY3JpcHRpb246IFwiXFxcIi1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdzdSc7IH0sXG4gICAgICAgICAgXCIqXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKlxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gJ211JzsgfSxcbiAgICAgICAgICBcIi9cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIvXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIvXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiAnZGknOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gJ25lJzsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdwbyc7IH0sXG4gICAgICAgICAgXCJAXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiQFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiQFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gJ2JpJzsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICcgJzsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdcXG4nOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gcy5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICBpZiAoICFyZXMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuaW5kZXhPZignXFxuJykgIT09IC0xID8gJ1xcbicgOiAnICc7XG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihzKSB7IHJldHVybiBzOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbGVuID0gc3RhdGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLCBzdGF0ZW1lbnRzW2ldWzBdKTtcbiAgICAgICAgICAgICAgICAgIHZhciB3cyA9IHN0YXRlbWVudHNbaV1bMV07XG4gICAgICAgICAgICAgICAgICBpZiAoIHdzICYmIHdzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFtzeW0oJ291JyksIHN5bSh3cywgJ2xpdCcpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdG10cyhyZXN1bHRzKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihzLCB3cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbW3NdLCB3c107XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXMpIHsgcmV0dXJuIGVzOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICBmdW5jdGlvbihzLCB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0ICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtbcywgdF0sIG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1tzXSwgbnVsbF07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCI8IS0tXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiPCEtLVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPCEtLVxcXCJcIiB9LFxuICAgICAgICAgIFwiLS0+XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLS0+XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCItLT5cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihjb21tZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeW0oJ2N0JyksIHN5bShjb21tZW50LmpvaW4oJycpLCAnbGl0JyldO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwiPCFcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI8IVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPCFcXFwiXCIgfSxcbiAgICAgICAgICBcIj5cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI+XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI+XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocm9vdEVsZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N5bSgnZHQnKSwgcm9vdEVsZW1dO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjxcIiwgZGVzY3JpcHRpb246IFwiXFxcIjxcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihhKSB7IHJldHVybiBhOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHRhZywgYXR0cnMsIHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N5bSgnb3AnKSwgdGFnLCBhdHRycywgdF07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCIoXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKFxcXCJcIiB9LFxuICAgICAgICAgIFwiKVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIilcIiwgZGVzY3JpcHRpb246IFwiXFxcIilcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCIvPlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi8+XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIvPlxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gMTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH0sXG4gICAgICAgICAgXCI9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiPVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGU7IH0sXG4gICAgICAgICAgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW25hbWUsIHZhbHVlID09PSBudWxsID8gc3ltKHRydWUsICdsaXQnKSA6IHZhbHVlXTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcIjwvXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiPC9cIiwgZGVzY3JpcHRpb246IFwiXFxcIjwvXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeW0oJ2NsJyksIHRhZ107XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZykgeyByZXR1cm4gZzsgfSxcbiAgICAgICAgICBmdW5jdGlvbihvcCwgaWQsIHBhcmFtcywgZ3VhcmQsIHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgICAgICAgICAgdmFyIGd1YXJkcyA9IHBhcmFtcy5ndWFyZHMgfHwgW107XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgICAgICAgICBpZiAoIGd1YXJkcy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIGd1YXJkICkgeyBndWFyZHMucHVzaChndWFyZCk7IH1cbiAgICAgICAgICAgICAgICAgIGd1YXJkID0gZ3VhcmRzWzBdO1xuICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDEsIGxlbiA9IGd1YXJkcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3VhcmQgPSBbc3ltKCdhbicpLCBndWFyZCwgZ3VhcmRzW2ldXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGd1YXJkICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzeW0ob3ApLCBpZCwgcGFyYW1zLmlkcyB8fCBbXSwgc3RhdGVtZW50cywgZ3VhcmRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3N5bShvcCksIGlkLCBwYXJhbXMuaWRzIHx8IFtdLCBzdGF0ZW1lbnRzXTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcIixcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIsXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocGFyYW0pIHsgcmV0dXJuIHBhcmFtOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHN0YXJ0LCBjb250KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBndWFyZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBbc3RhcnRdLmNvbmNhdChjb250KTtcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtRGVmID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHBhcmFtRGVmWzBdO1xuICAgICAgICAgICAgICAgICAgaWYgKCBpc0lkZW50aWZpZXIoaXRlbSkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBpZFN5bSA9IHBhcmFtRGVmWzFdIHx8IHN5bShpLCAnbGl0Jyk7XG4gICAgICAgICAgICAgICAgICBpZHMucHVzaChpZFN5bSk7XG4gICAgICAgICAgICAgICAgICBndWFyZHMucHVzaChbc3ltKCdtYScpLCBbc3ltKCdpZCcpLCBpZFN5bV0sIGl0ZW1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaWRzOiBpZHMsIGd1YXJkczogZ3VhcmRzIH07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3BhcmFtXTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihpZCkgeyByZXR1cm4gaWQ7IH0sXG4gICAgICAgICAgZnVuY3Rpb24ocGFyYW0sIGFsaWFzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBhbGlhcyApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbcGFyYW0sIGFsaWFzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtwYXJhbV07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24ob3AsIHBhdGgsIGltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N5bShvcCksIFtbcGF0aCwgaW1wb3J0c11dXTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihvcCwgbW9kdWxlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3ltKG9wKSwgbW9kdWxlc107XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbTsgfSxcbiAgICAgICAgICBmdW5jdGlvbihzdGFydCwgY29udCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW0oW3N0YXJ0XS5jb25jYXQoY29udCkuam9pbignLycpKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihzdGFydCwgY29udCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3RhcnRdLmNvbmNhdChjb250KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihuYW1lLCBhbGlhcykge1xuICAgICAgICAgICAgICAgIGlmICggYWxpYXMgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW25hbWUsIGFsaWFzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuYW1lXTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihzcGVjKSB7IHJldHVybiBzcGVjOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHBhdGgsIGFsaWFzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBhbGlhcyApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbcGF0aCwgYWxpYXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3BhdGhdO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKG9wLCByYW5nZXMsIHN0YXRlbWVudHMsIHRhaWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N5bShvcCksIHJhbmdlcywgc3RhdGVtZW50cywgdGFpbF07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocikgeyByZXR1cm4gcjsgfSxcbiAgICAgICAgICBmdW5jdGlvbihpZCwgY29sLCBndWFyZCkge1xuICAgICAgICAgICAgICAgIGlmICggZ3VhcmQgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2lkLCBjb2wsIGd1YXJkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtpZCwgY29sXTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihvcCwgZXhwciwgc3RhdGVtZW50cywgdGFpbCkge1xuICAgICAgICAgICAgICAgIGlmICggIW9wICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzeW0oJ2lmJyksIGV4cHIsIHRhaWwsIHN0YXRlbWVudHNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3N5bSgnaWYnKSwgZXhwciwgc3RhdGVtZW50cywgdGFpbF07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oaWZTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RtdHMoW2lmU3RhdGVtZW50XSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0bXRzKFtdKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihvcCwgYSkge1xuICAgICAgICAgICAgICByZXR1cm4gW3N5bShvcCksIGFdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihpZCwgZXhwcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbaWQsIGV4cHJdO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGV4cHIpIHsgcmV0dXJuIFtzeW0oJ291JyksIGV4cHJdOyB9LFxuICAgICAgICAgIFwifFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInxcIiwgZGVzY3JpcHRpb246IFwiXFxcInxcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihhcmdzLCBjYWxscykge1xuICAgICAgICAgICAgICAgIGlmICggY2FsbHMgJiYgY2FsbHMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgc3RhcnRzIHdpdGggYW4gaW50ZXJwb2xhdGlvbiwgd2UgbmVlZCB0byBmZWVkIGl0ICdzZWxmJ1xuICAgICAgICAgICAgICAgICAgaWYgKCBpc0ludGVycG9sYXRlZChhcmdzKSApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbHMudW5zaGlmdChhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtzeW0oJ3NlJywgYXJncyldO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSBjYWxscy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtzeW0oJ2NhJyksIGNhbGxzW2ldLCBbYXJnc11dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIG9yIGlmIGl0J3MgYW4gYXV0byBpbnRlcnBvbGF0aW9uLCB3ZSBhbHNvIGZlZWQgaXQgJ3NlbGYnXG4gICAgICAgICAgICAgICAgICBpZiAoIGlzSW50ZXJwb2xhdGVkKGFyZ3MpICYmIGFyZ3MudHlwZSA9PT0gJ2F1dG8nICkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gWyBzeW0oJ2NhJyksIGFyZ3MsIFtbc3ltKCdzZScpXV0gXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24odHZhbCwgb3AsIGNvbmQsIGZ2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoICFvcCApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbc3ltKCdjbicpLCBjb25kLCBmdmFsLCB0dmFsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeW0oJ2NuJyksIGNvbmQsIHR2YWwsIGZ2YWxdO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKG9wLCByKSB7IHJldHVybiBbc3ltKG9wKSwgcl07IH0sXG4gICAgICAgICAgZnVuY3Rpb24oaGVhZCwgdGFpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZEJpbmFyeUNoYWluKGhlYWQsIHRhaWwpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKG9wLCBleHByKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBvcCA9PT0gJ25vJyB8fCAhaXNJbnRlcnBvbGF0ZWQoZXhwcikgfHwgZXhwci5tYXJrZWQgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW3N5bShvcCksIGV4cHJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggb3AgPT09ICduZScgfHwgb3AgPT09ICdwbycgKSB7XG4gICAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBvcCA9PT0gJ25lJyA/ICdpbnQnIDogJ2F1dG8nO1xuICAgICAgICAgICAgICAgICAgZXhwci5tYXJrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBoYXZlIGdvdHRlbiBoZXJlXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQoXCJ1bmFyeSBvcGVyYXRvciBvZiAnKycgb3IgJy0nXCIpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKG9wLCBsaXN0SW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhaGFzT3BlcmF0b3IobGlzdEludCwgJ2NhJykgKSB7XG4gICAgICAgICAgICAgICAgICBleHBlY3RlZChcImJpbmQgdG8gdGFyZ2V0IGEgZnVuY3Rpb24gb3IgcGFydGlhbCBjYWxsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlT3BlcmF0b3IobGlzdEludCwgb3ApO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHN0ciwgbGlzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbIHN5bSgnY2EnKSwgc3RyLCBbbGlzdF0gXTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihzZWwpIHsgcmV0dXJuIHNlbDsgfSxcbiAgICAgICAgICBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeW0oJ21iJyksIFtzeW0oZWxlbS52YWx1ZSwgJ2xpdCcpXV07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJbXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiW1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiW1xcXCJcIiB9LFxuICAgICAgICAgIFwiXVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIl1cIiwgZGVzY3JpcHRpb246IFwiXFxcIl1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeW0oJ21iJyksIFtlbGVtXV07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3ltKCdjYScpLCBhcmdzXTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihlbGVtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtcztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oY29tcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGVsZW1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeW0oJ2FyJyksIGVsZW1zXTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihlbGVtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3ltKCdkYycpLCBlbGVtc107XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeW0oJ2FyJyksIFtdXTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmFtZSwgdmFsdWVdO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwiOlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjpcIiwgZGVzY3JpcHRpb246IFwiXFxcIjpcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmFtZSwgdmFsdWVdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXhwciwgb3AsIHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3ltKCdsYycpLCByYW5nZXMsIGV4cHJdO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGFzc2lnbiwgb3AsIHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3ltKCdsYycpLCByYW5nZXMsIGFzc2lnblsxXSwgYXNzaWduWzBdXTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHN5bSh0cnVlLCAnbGl0Jyk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBzeW0oZmFsc2UsICdsaXQnKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3ltKCdpZCcpLCBpZF07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24ob3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N5bShvcCldO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKG9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bShvcCwgJ2xpdCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgIF0sXG5cbiAgICAgICAgcGVnJGJ5dGVjb2RlID0gW1xuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3bFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS4hXFxcIlxcXCIyITNcXFwiKz8kITg3PzkqJCRcXFwiXFxcIiAjXFxcIiMgICsnJTRcXFwiNiRcXFwiICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuJVxcXCJcXFwiMiUzJis/JCE4Nz85KiQkXFxcIlxcXCIgI1xcXCIjICArJyU0XFxcIjYnXFxcIiAlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLihcXFwiXFxcIjIoMykrPyQhODc/OSokJFxcXCJcXFwiICNcXFwiIyAgKyclNFxcXCI2KlxcXCIgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS4rXFxcIlxcXCIyKzMsKz8kITg3PzkqJCRcXFwiXFxcIiAjXFxcIiMgICsnJTRcXFwiNipcXFwiICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuLVxcXCJcXFwiMi0zLis/JCE4Nz85KiQkXFxcIlxcXCIgI1xcXCIjICArJyU0XFxcIjYvXFxcIiAlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLjBcXFwiXFxcIjIwMzErPyQhODc/OSokJFxcXCJcXFwiICNcXFwiIyAgKyclNFxcXCI2MlxcXCIgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS4zXFxcIlxcXCIyMzM0Kz8kITg3PzkqJCRcXFwiXFxcIiAjXFxcIiMgICsnJTRcXFwiNjVcXFwiICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuNlxcXCJcXFwiMjYzNys/JCE4Nz85KiQkXFxcIlxcXCIgI1xcXCIjICArJyU0XFxcIjY4XFxcIiAlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLjlcXFwiXFxcIjI5MzorPyQhODc/OSokJFxcXCJcXFwiICNcXFwiIyAgKyclNFxcXCI2O1xcXCIgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS48XFxcIlxcXCIyPDM9Kz8kITg3PzkqJCRcXFwiXFxcIiAjXFxcIiMgICsnJTRcXFwiNj5cXFwiICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuP1xcXCJcXFwiMj8zQCs/JCE4Nz85KiQkXFxcIlxcXCIgI1xcXCIjICArJyU0XFxcIjZBXFxcIiAlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLkJcXFwiXFxcIjJCM0MrPyQhODc/OSokJFxcXCJcXFwiICNcXFwiIyAgKyclNFxcXCI2RFxcXCIgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5FXFxcIlxcXCIyRTNGKz8kITg3PzkqJCRcXFwiXFxcIiAjXFxcIiMgICsnJTRcXFwiNkdcXFwiICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuSFxcXCJcXFwiMkgzSSs/JCE4Nz85KiQkXFxcIlxcXCIgI1xcXCIjICArJyU0XFxcIjZKXFxcIiAlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLktcXFwiXFxcIjJLM0wrPyQhODc/OSokJFxcXCJcXFwiICNcXFwiIyAgKyclNFxcXCI2TVxcXCIgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5OXFxcIlxcXCIyTjNPKz8kITg3PzkqJCRcXFwiXFxcIiAjXFxcIiMgICsnJTRcXFwiNlBcXFwiICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuUVxcXCJcXFwiMlEzUis/JCE4Nz85KiQkXFxcIlxcXCIgI1xcXCIjICArJyU0XFxcIjZTXFxcIiAlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlRcXFwiXFxcIjJUM1UrPyQhODc/OSokJFxcXCJcXFwiICNcXFwiIyAgKyclNFxcXCI2UFxcXCIgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5WXFxcIlxcXCIyVjNXKz8kITg3PzkqJCRcXFwiXFxcIiAjXFxcIiMgICsnJTRcXFwiNlNcXFwiICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuWFxcXCJcXFwiMlgzWSs7JCE4Nz85KiQkXFxcIlxcXCIgI1xcXCIjICArIyUnXFxcIiUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuWlxcXCJcXFwiMlozWys7JCE4Nz85KiQkXFxcIlxcXCIgI1xcXCIjICArIyUnXFxcIiUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFxcXFxcXCJcXFwiMlxcXFwzXSs7JCE4Nz85KiQkXFxcIlxcXCIgI1xcXCIjICArIyUnXFxcIiUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXlxcXCJcXFwiMl4zXys7JCE4Nz85KiQkXFxcIlxcXCIgI1xcXCIjICArIyUnXFxcIiUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuYFxcXCJcXFwiMmAzYSopIFxcXCIuYlxcXCJcXFwiMmIzYys/JCE4Nz85KiQkXFxcIlxcXCIgI1xcXCIjICArJyU0XFxcIjZkXFxcIiAlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLmVcXFwiXFxcIjJlM2YqKSBcXFwiLmdcXFwiXFxcIjJnM2grPyQhODc/OSokJFxcXCJcXFwiICNcXFwiIyAgKyclNFxcXCI2aVxcXCIgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5qXFxcIlxcXCIyajNrKikgXFxcIi5sXFxcIlxcXCIybDNtKzskITg3PzkqJCRcXFwiXFxcIiAjXFxcIiMgICsjJSdcXFwiJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNyEqXFx4QjMgXFxcIjdcXFwiKlxceEFEIFxcXCI3IypcXHhBNyBcXFwiNyQqXFx4QTEgXFxcIjclKlxceDlCIFxcXCI3JipcXHg5NSBcXFwiNycqXFx4OEYgXFxcIjcoKlxceDg5IFxcXCI3KSpcXHg4MyBcXFwiNyoqfSBcXFwiNysqdyBcXFwiNzgqcSBcXFwiNzkqayBcXFwiNywqZSBcXFwiNy0qXyBcXFwiNy4qWSBcXFwiNy8qUyBcXFwiNzAqTSBcXFwiNzEqRyBcXFwiNzIqQSBcXFwiNzMqOyBcXFwiNzQqNSBcXFwiNzUqLyBcXFwiNzYqKSBcXFwiNzcqIyBcXFwiNzpcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhODc7OSokJFxcXCJcXFwiICNcXFwiIyAgKzIkNz0rKCU0XFxcIjZuXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc+KzskIG83PywjJjc/XFxcIispJTRcXFwiNnBcXFwiXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMHFcXFwiXFxcIjEhM3JcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjc+KikgXFxcIjBzXFxcIlxcXCIxITN0XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN0ErOyQgbzdCLCMmN0JcXFwiKyklNFxcXCI2dVxcXCJcXFwiISAlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwdlxcXCJcXFwiMSEzd1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN0EqKSBcXFwiMHhcXFwiXFxcIjEhM3lcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgbzdEKyYkLCMmN0RcXFwiXFxcIlxcXCIgICsnIDQhNnohISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwe1xcXCJcXFwiMSEzfFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITB9XFxcIlxcXCIxITN+K1xceDg3JDB/XFxcIlxcXCIxITNcXHg4MCt3JTBcXHg4MVxcXCJcXFwiMSEzXFx4ODIrZyUwXFx4ODNcXFwiXFxcIjEhM1xceDg0K1clMFxceDg1XFxcIlxcXCIxITNcXHg4NitHJTBcXHg4N1xcXCJcXFwiMSEzXFx4ODgrNyUwXFx4ODlcXFwiXFxcIjEhM1xceDhBKyclNCc2XFx4OEInICUkJyMgICQmIyAgJCUjICAkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIweFxcXCJcXFwiMSEzeVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITBcXHg4Q1xcXCJcXFwiMSEzXFx4OEQrQiQgbzdGKyYkLCMmN0ZcXFwiXFxcIlxcXCIgICspJTRcXFwiNlxceDhFXFxcIlxcXCIhICUkXFxcIiMgIFxcXCIjICAqIyBcXFwiN0ZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEwXFx4ODlcXFwiXFxcIjEhM1xceDhBK1gkMFxceDkwXFxcIlxcXCIxITNcXHg5MSojIFxcXCIgXFx4OEYrQiUgbzdGKyYkLCMmN0ZcXFwiXFxcIlxcXCIgICspJTQjNlxceDkyI1xcXCIhICUkIyMgICRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHg5M1xcXCJcXFwiMlxceDkzM1xceDk0K0EkIG83RismJCwjJjdGXFxcIlxcXCJcXFwiICArKCU0XFxcIjZcXHg5NVxcXCIhICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3RytKJDdJKiMgXFxcIiBcXHg4Ris6JTdIKiMgXFxcIiBcXHg4RisqJTQjNlxceDk2IyNcXFwiISAlJCMjICAkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi1cXFwiXFxcIjEhM1xceDk3XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwXFx4OThcXFwiXFxcIjEhM1xceDk5XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwXFx4OUFcXFwiXFxcIjEhM1xceDlCXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3TSo2IFxcXCIhOC1cXFwiXFxcIjEhM1xceDk3OSokJFxcXCJcXFwiICNcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIG83TCwjJjdMXFxcIistJDdQKyMlJ1xcXCIlJFxcXCIjICBcXFwiIyAgKkAgXFxcIiEgbzdMLCMmN0xcXFwiKy0kN04rIyUnXFxcIiUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx4OUNcXFwiXFxcIjJcXHg5QzNcXHg5RCtcXHg4NSQgbyEhODdOOSokJFxcXCJcXFwiICNcXFwiIyAgKy0kN0srIyUnXFxcIiUkXFxcIiMgIFxcXCIjICAsRiYhITg3TjkqJCRcXFwiXFxcIiAjXFxcIiMgICstJDdLKyMlJ1xcXCIlJFxcXCIjICBcXFwiIyAgXFxcIistJTdOKyMlJyMlJCMjICAkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdSKiMgXFxcIjdTXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceDlFXFxcIlxcXCIyXFx4OUUzXFx4OUYrXFx4QTQkN1QqIyBcXFwiIFxceDhGK1xceDk0JSBvISE4N1U5KiQkXFxcIlxcXCIgI1xcXCIjICArMiQ3SysoJTRcXFwiNlxceEEwXFxcIiEgJSRcXFwiIyAgXFxcIiMgICxLJiEhODdVOSokJFxcXCJcXFwiICNcXFwiIyAgKzIkN0srKCU0XFxcIjZcXHhBMFxcXCIhICUkXFxcIiMgIFxcXCIjICBcXFwiKzIlN1UrKCU0JDZcXHhBMSQhISUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEEyXFxcIlxcXCIyXFx4QTIzXFx4QTMrXFx4QTQkN1QqIyBcXFwiIFxceDhGK1xceDk0JSBvISE4N1Y5KiQkXFxcIlxcXCIgI1xcXCIjICArMiQ3SysoJTRcXFwiNlxceEEwXFxcIiEgJSRcXFwiIyAgXFxcIiMgICxLJiEhODdWOSokJFxcXCJcXFwiICNcXFwiIyAgKzIkN0srKCU0XFxcIjZcXHhBMFxcXCIhICUkXFxcIiMgIFxcXCIjICBcXFwiKzIlN1YrKCU0JDZcXHhBNCQhISUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIG83TCwjJjdMXFxcIistJDdNKyMlJ1xcXCIlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN00qIyBcXFwiIFxceDhGKzMkLlxceDlFXFxcIlxcXCIyXFx4OUUzXFx4OUYrIyUnXFxcIiUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3TSojIFxcXCIgXFx4OEYrMyQuXFx4QTJcXFwiXFxcIjJcXHhBMjNcXHhBMysjJSdcXFwiJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHhBNVxcXCJcXFwiMlxceEE1M1xceEE2KzckLlxceEE1XFxcIlxcXCIyXFx4QTUzXFx4QTYrJyU0XFxcIjZcXHhBN1xcXCIgJSRcXFwiIyAgXFxcIiMgICpcXHhEMiBcXFwiIS5cXHhBOFxcXCJcXFwiMlxceEE4M1xceEE5KzckLlxceEE4XFxcIlxcXCIyXFx4QTgzXFx4QTkrJyU0XFxcIjZcXHhBN1xcXCIgJSRcXFwiIyAgXFxcIiMgICpcXHhBNyBcXFwiIS5cXHhBNVxcXCJcXFwiMlxceEE1M1xceEE2K1EkIG83WCsmJCwjJjdYXFxcIlxcXCJcXFwiICArOCUuXFx4QTVcXFwiXFxcIjJcXHhBNTNcXHhBNisoJTQjNlxceEFBIyEhJSQjIyAgJFxcXCIjICBcXFwiIyAgKmIgXFxcIiEuXFx4QThcXFwiXFxcIjJcXHhBODNcXHhBOStRJCBvN1krJiQsIyY3WVxcXCJcXFwiXFxcIiAgKzglLlxceEE4XFxcIlxcXCIyXFx4QTgzXFx4QTkrKCU0IzZcXHhBQiMhISUkIyMgICRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMFxceEFDXFxcIlxcXCIxITNcXHhBRCojIFxcXCI3WlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMFxceEFFXFxcIlxcXCIxITNcXHhBRiojIFxcXCI3WlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHhCMFxcXCJcXFwiMlxceEIwM1xceEIxKyYgNCE2XFx4QjIhICUqXFx4QkUgXFxcIiEuXFx4QjNcXFwiXFxcIjJcXHhCMzNcXHhCNCsmIDQhNlxceEI1ISAlKlxceEE3IFxcXCIhLlxceEI2XFxcIlxcXCIyXFx4QjYzXFx4QjcrJiA0ITZcXHhCOCEgJSpcXHg5MCBcXFwiIS5cXHhCOVxcXCJcXFwiMlxceEI5M1xceEJBKyYgNCE2XFx4QkIhICUqeSBcXFwiIS5cXHhCQ1xcXCJcXFwiMlxceEJDM1xceEJEKyYgNCE2XFx4QkUhICUqYiBcXFwiIS5cXHhCRlxcXCJcXFwiMlxceEJGM1xceEMwKyYgNCE2XFx4QzEhICUqSyBcXFwiIS5cXHhDMlxcXCJcXFwiMlxceEMyM1xceEMzKyYgNCE2XFx4QzQhICUqNCBcXFwiIS5cXHhDNVxcXCJcXFwiMlxceEM1M1xceEM2KyYgNCE2XFx4QzchICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcwKiMgXFxcIjcxXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEM4XFxcIlxcXCIyXFx4QzgzXFx4QzkrJiA0ITZcXHhDQSEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHhDQlxcXCJcXFwiMlxceENCM1xceENDKyYgNCE2XFx4Q0QhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx4Q0VcXFwiXFxcIjJcXHhDRTNcXHhDRismIDQhNlxceEQwISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEQxXFxcIlxcXCIyXFx4RDEzXFx4RDIrJiA0ITZcXHhEMyEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHhENFxcXCJcXFwiMlxceEQ0M1xceEQ1KyYgNCE2XFx4RDYhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx4RDdcXFwiXFxcIjJcXHhENzNcXHhEOCsmIDQhNlxceEQ5ISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEQxXFxcIlxcXCIyXFx4RDEzXFx4RDIrJiA0ITZcXHhEQSEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHhDRVxcXCJcXFwiMlxceENFM1xceENGKyYgNCE2XFx4REIhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx4RENcXFwiXFxcIjJcXHhEQzNcXHhERCsmIDQhNlxceERFISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3KSopIFxcXCI3XSojIFxcXCI3XFxcXFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNzkqLyBcXFwiNzgqKSBcXFwiNyoqIyBcXFwiNytcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdeKiMgXFxcIjdfXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3YCopIFxcXCI3YSojIFxcXCI3LFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN2IqKSBcXFwiN2MqIyBcXFwiNy5cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgbyE3TCsmIDQhNlxceERGISAlKjQgXFxcIiE3TSojIFxcXCI3UCsmIDQhNlxceEUwISAlLEUmITdMKyYgNCE2XFx4REYhICUqNCBcXFwiITdNKiMgXFxcIjdQKyYgNCE2XFx4RTAhICVcXFwiKycgNCE2XFx4RTEhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIG83TCwjJjdMXFxcIismIDQhNlxceERGISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN2orMiQ3bSsoJTRcXFwiNlxceEUyXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBvN24sIyY3blxcXCIrJyA0ITZcXHhFMyEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3cCojIFxcXCI3XFx4OEYrMyQ3aispJTRcXFwiNlxceEU0XFxcIlxcXCIhICUkXFxcIiMgIFxcXCIjICAqcyBcXFwiITdxK2gkITdrKzIkN3ArKCU0XFxcIjZcXHhFNVxcXCIhICUkXFxcIiMgIFxcXCIjICAqLiBcXFwiITdPKyYgNCE2XFx4RTYhICUrMyU3aispJTQjNlxceEU3I1xcXCJcXFwiISUkIyMgICRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN3AqKSBcXFwiN3EqIyBcXFwiN1xceDhGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3ciovIFxcXCI3cyopIFxcXCI3eSojIFxcXCI3dFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN3oqNSBcXFwiN1xceDgwKi8gXFxcIjdcXHg4NyopIFxcXCI3XFx4OEEqIyBcXFwiN1xceDhDXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEU4XFxcIlxcXCIyXFx4RTgzXFx4RTkrXFx4QTYkIG8hITguXFx4RUFcXFwiXFxcIjJcXHhFQTNcXHhFQjkqJCRcXFwiXFxcIiAjXFxcIiMgICsyJDdLKyglNFxcXCI2XFx4QTBcXFwiISAlJFxcXCIjICBcXFwiIyAgLFEmISE4LlxceEVBXFxcIlxcXCIyXFx4RUEzXFx4RUI5KiQkXFxcIlxcXCIgI1xcXCIjICArMiQ3SysoJTRcXFwiNlxceEEwXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFxcXCIrOCUuXFx4RUFcXFwiXFxcIjJcXHhFQTNcXHhFQisoJTQjNlxceEVDIyEhJSQjIyAgJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEVEXFxcIlxcXCIyXFx4RUQzXFx4RUUrYCQ3RStWJTdrK0wlN0ArQiU3ays4JS5cXHhFRlxcXCJcXFwiMlxceEVGM1xceEYwKyglNCY2XFx4RjEmIVxcXCIlJCYjICAkJSMgICQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx4RjJcXFwiXFxcIjJcXHhGMjNcXHhGMytcXHg5OCQ3aitcXHg4RSU3dStcXHg4NCU3ait6JSBvITd4KzIkN2orKCU0XFxcIjZcXHhGNFxcXCIhISUkXFxcIiMgIFxcXCIjICAsPSYhN3grMiQ3aisoJTRcXFwiNlxceEY0XFxcIiEhJSRcXFwiIyAgXFxcIiMgIFxcXCIrNCU3dysqJTQmNlxceEY1JiMjISAlJCYjICAkJSMgICQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx4RjZcXFwiXFxcIjJcXHhGNjNcXHhGNytWJDdqK0wlN1xceDkwK0IlN2orOCUuXFx4RjhcXFwiXFxcIjJcXHhGODNcXHhGOSsoJTQlNlxceEZBJSFcXFwiJSQlIyAgJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgICojIFxcXCI3QFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHhGNlxcXCJcXFwiMlxceEY2M1xceEY3K1YkN2orTCU3XFx4OTArQiU3ais4JS5cXHhGOFxcXCJcXFwiMlxceEY4M1xceEY5KyglNCU2XFx4RkElIVxcXCIlJCUjICAkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgKiMgXFxcIjdDXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEZCXFxcIlxcXCIyXFx4RkIzXFx4RkMrJiA0ITZcXHhGRCEgJSo0IFxcXCIhLlxceEVGXFxcIlxcXCIyXFx4RUYzXFx4RjArJiA0ITZcXHhGRSEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITd2K20kITdrK0wkLlxceEZGXFxcIlxcXCIyXFx4RkYzXFx1MDEwMCs8JTdqKzIlN1xceDkwKyglNCQ2XFx1MDEwMSQhICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgKiMgXFxcIiBcXHg4RispJTRcXFwiNlxcdTAxMDJcXFwiXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHUwMTAzXFxcIlxcXCIyXFx1MDEwMzNcXHUwMTA0K1YkN2orTCU3dStCJTdqKzglLlxceEVGXFxcIlxcXCIyXFx4RUYzXFx4RjArKCU0JTZcXHUwMTA1JSFcXFwiJSQlIyAgJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXFwiK1xceDhFJDdrK1xceDg0JTc8K3olN2srcCU3fSojIFxcXCIgXFx4OEYrYCUhN2orMiQ3eysoJTRcXFwiNlxcdTAxMDZcXFwiISAlJFxcXCIjICBcXFwiIyAgKiMgXFxcIiBcXHg4Ris2JTd8KywlNCc2XFx1MDEwNyclJiRcXFwiISAlJCcjICAkJiMgICQlIyAgJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc6KzwkN2srMiU3XFx4OTArKCU0IzZcXHhGQSMhICUkIyMgICRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdqKzwkN20rMiU3NysoJTQjNlxcdTAxMDgjISElJCMjICAkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx4RjZcXFwiXFxcIjJcXHhGNjNcXHhGNytWJDdqK0wlN34rQiU3ais4JS5cXHhGOFxcXCJcXFwiMlxceEY4M1xceEY5KyglNCU2XFx1MDEwOSUhXFxcIiUkJSMgICQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICAqUiBcXFwiIS5cXHhGNlxcXCJcXFwiMlxceEY2M1xceEY3K0EkN2orNyUuXFx4RjhcXFwiXFxcIjJcXHhGODNcXHhGOSsnJTQjNlxcdTAxMEEjICUkIyMgICRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITd/K1xceEEzJCBvITdrK0wkLlxcdTAxMEJcXFwiXFxcIjJcXHUwMTBCM1xcdTAxMEMrPCU3aisyJTd/KyglNCQ2XFx1MDEwRCQhICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgLFcmITdrK0wkLlxcdTAxMEJcXFwiXFxcIjJcXHUwMTBCM1xcdTAxMEMrPCU3aisyJTd/KyglNCQ2XFx1MDEwRCQhICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXFxcIispJTRcXFwiNlxcdTAxMEVcXFwiXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc8KycgNCE2XFx1MDEwRiEhICUqciBcXFwiITdcXHg5MCtnJCE3aytGJDc0KzwlN2srMiU3PCsoJTQkNlxcdTAxMTAkISAlJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgICojIFxcXCIgXFx4OEYrKSU0XFxcIjZcXHUwMTExXFxcIlxcXCIhICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3IytmJDdrK1xcXFwlN1xceDgxK1IlN2orSCU3JCs+JTdrKzQlN1xceDgzKyolNCc2XFx1MDExMicjJiQgJSQnIyAgJCYjICAkJSMgICQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICAqSCBcXFwiITckKz0kN2srMyU3XFx4ODUrKSU0IzZcXHUwMTEzI1xcXCJcXFwiICUkIyMgICRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg4Mit7JCBvIS5cXHg5M1xcXCJcXFwiMlxceDkzM1xceDk0KzIkN1xceDgyKyglNFxcXCI2XFx1MDExNFxcXCIhICUkXFxcIiMgIFxcXCIjICAsQyYhLlxceDkzXFxcIlxcXCIyXFx4OTMzXFx4OTQrMiQ3XFx4ODIrKCU0XFxcIjZcXHUwMTE0XFxcIiEgJSRcXFwiIyAgXFxcIiMgIFxcXCIrKSU0XFxcIjZcXHUwMTE1XFxcIlxcXCIhICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhODc7OSokJFxcXCJcXFwiICNcXFwiIyAgKzIkNz0rKCU0XFxcIjZcXHUwMTE2XFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg4NCtcXHhBMyQgbyE3aytMJC5cXHUwMTBCXFxcIlxcXCIyXFx1MDEwQjNcXHUwMTBDKzwlN2orMiU3XFx4ODQrKCU0JDZcXHUwMTE0JCEgJSQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICAsVyYhN2srTCQuXFx1MDEwQlxcXCJcXFwiMlxcdTAxMEIzXFx1MDEwQys8JTdqKzIlN1xceDg0KyglNCQ2XFx1MDExNCQhICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXFxcIispJTRcXFwiNlxcdTAxMTdcXFwiXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc8K2ckITdrK0YkNzQrPCU3aysyJTc8KyglNCQ2XFx1MDExMCQhICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgKiMgXFxcIiBcXHg4RispJTRcXFwiNlxcdTAxMThcXFwiXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg4NitcXHhBMyQgbyE3aytMJC5cXHUwMTBCXFxcIlxcXCIyXFx1MDEwQjNcXHUwMTBDKzwlN2orMiU3XFx4ODYrKCU0JDZcXHUwMTE5JCEgJSQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICAsVyYhN2srTCQuXFx1MDEwQlxcXCJcXFwiMlxcdTAxMEIzXFx1MDEwQys8JTdqKzIlN1xceDg2KyglNCQ2XFx1MDExOSQhICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXFxcIispJTRcXFwiNlxcdTAxMTdcXFwiXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg4MStnJCE3aytGJDc0KzwlN2srMiU3PCsoJTQkNlxcdTAxMTAkISAlJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgICojIFxcXCIgXFx4OEYrKSU0XFxcIjZcXHUwMTFBXFxcIlxcXCIhICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3IStdJDdrK1MlN1xceDg4K0klN2orPyU3bSs1JTdcXHg4QisrJTQmNlxcdTAxMUImJCUjISAlJCYjICAkJSMgICQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4ODkrXFx4QTMkIG8hN2srTCQuXFx1MDEwQlxcXCJcXFwiMlxcdTAxMEIzXFx1MDEwQys8JTdqKzIlN1xceDg5KyglNCQ2XFx1MDExQyQhICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgLFcmITdrK0wkLlxcdTAxMEJcXFwiXFxcIjJcXHUwMTBCM1xcdTAxMEMrPCU3aisyJTdcXHg4OSsoJTQkNlxcdTAxMUMkISAlJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgIFxcXCIrKSU0XFxcIjZcXHUwMTE3XFxcIlxcXCIhICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3PCt8JDdrK3IlNzUraCU3aiteJTdcXHg5MCtUJSE3aisyJDd7KyglNFxcXCI2XFx1MDEwNlxcXCIhICUkXFxcIiMgIFxcXCIjICAqIyBcXFwiIFxceDhGKyolNCY2XFx1MDExRCYjJSEgJSQmIyAgJCUjICAkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1srXSQ3aytTJTdcXHg5MCtJJTdqKz8lN20rNSU3XFx4OEIrKyU0JjZcXHUwMTFFJiQlIyEgJSQmIyAgJCUjICAkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrPCQ3aysyJTdcXHg4QSsoJTQjNlxcdTAxMUYjISAlJCMjICAkXFxcIiMgIFxcXCIjICAqYiBcXFwiITc2K0YkN2orPCU3bSsyJTc3KyglNCQ2XFx1MDEwOCQhISUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgKi4gXFxcIiE3NysmIDQhNlxcdTAxMjAhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3Jis9JDdrKzMlN1xceDhEKyklNCM2XFx1MDEyMSNcXFwiXFxcIiAlJCMjICAkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OEUrXFx4QTMkIG8hN2srTCQuXFx1MDEwQlxcXCJcXFwiMlxcdTAxMEIzXFx1MDEwQys8JTdqKzIlN1xceDhFKyglNCQ2XFx4RjQkISAlJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgICxXJiE3aytMJC5cXHUwMTBCXFxcIlxcXCIyXFx1MDEwQjNcXHUwMTBDKzwlN2orMiU3XFx4OEUrKCU0JDZcXHhGNCQhICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXFxcIispJTRcXFwiNlxcdTAxMTdcXFwiXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc8K1ckN2srTSUuXFx4RkZcXFwiXFxcIjJcXHhGRjNcXHUwMTAwKz0lN2orMyU3XFx4OTArKSU0JTZcXHUwMTIyJVxcXCIkICUkJSMgICQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OTArJyA0ITZcXHUwMTIzISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5MStcXHhBMyQgbyE3aytMJC5cXHUwMTI0XFxcIlxcXCIyXFx1MDEyNDNcXHUwMTI1KzwlN2orMiU3XFx4OTErKCU0JDZcXHhBMCQhICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgLFcmITdrK0wkLlxcdTAxMjRcXFwiXFxcIjJcXHUwMTI0M1xcdTAxMjUrPCU3aisyJTdcXHg5MSsoJTQkNlxceEEwJCEgJSQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICBcXFwiKyklNFxcXCI2XFx1MDEyNlxcXCJcXFwiISAlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDkyK3skN2srcSU3WytnJTdqK10lN1xceDkyK1MlN2orSSU3Nis/JTdqKzUlN1xceDkxKyslNCk2XFx1MDEyNykkKCYkICUkKSMgICQoIyAgJCcjICAkJiMgICQlIyAgJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgICojIFxcXCI3XFx4OTJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OTMrXFx4OTkkIG8hN2srRyQ3KCs9JTdqKzMlN1xceDkzKyklNCQ2XFx1MDEyOCRcXFwiXFxcIiAlJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgICxSJiE3aytHJDcoKz0lN2orMyU3XFx4OTMrKSU0JDZcXHUwMTI4JFxcXCJcXFwiICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXFxcIispJTRcXFwiNlxcdTAxMjlcXFwiXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5NCtcXHg5OSQgbyE3aytHJDcnKz0lN2orMyU3XFx4OTQrKSU0JDZcXHUwMTI4JFxcXCJcXFwiICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgLFImITdrK0ckNycrPSU3aiszJTdcXHg5NCspJTQkNlxcdTAxMjgkXFxcIlxcXCIgJSQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICBcXFwiKyklNFxcXCI2XFx1MDEyOVxcXCJcXFwiISAlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDk1K1xceDk5JCBvITdrK0ckN2UrPSU3aiszJTdcXHg5NSspJTQkNlxcdTAxMjgkXFxcIlxcXCIgJSQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICAsUiYhN2srRyQ3ZSs9JTdqKzMlN1xceDk1KyklNCQ2XFx1MDEyOCRcXFwiXFxcIiAlJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgIFxcXCIrKSU0XFxcIjZcXHUwMTI5XFxcIlxcXCIhICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OTYrXFx4OTkkIG8hN2srRyQ3Zis9JTdqKzMlN1xceDk2KyklNCQ2XFx1MDEyOCRcXFwiXFxcIiAlJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgICxSJiE3aytHJDdmKz0lN2orMyU3XFx4OTYrKSU0JDZcXHUwMTI4JFxcXCJcXFwiICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXFxcIispJTRcXFwiNlxcdTAxMjlcXFwiXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5NytcXHg5OSQgbyE3aytHJDdnKz0lN2orMyU3XFx4OTcrKSU0JDZcXHUwMTI4JFxcXCJcXFwiICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgLFImITdrK0ckN2crPSU3aiszJTdcXHg5NyspJTQkNlxcdTAxMjgkXFxcIlxcXCIgJSQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICBcXFwiKyklNFxcXCI2XFx1MDEyOVxcXCJcXFwiISAlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDk4K1xceDk5JCBvITdrK0ckN2grPSU3aiszJTdcXHg5OCspJTQkNlxcdTAxMjgkXFxcIlxcXCIgJSQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICAsUiYhN2srRyQ3aCs9JTdqKzMlN1xceDk4KyklNCQ2XFx1MDEyOCRcXFwiXFxcIiAlJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgIFxcXCIrKSU0XFxcIjZcXHUwMTI5XFxcIlxcXCIhICUkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3aSs9JDdrKzMlN1xceDk4KyklNCM2XFx1MDEyQSNcXFwiXFxcIiAlJCMjICAkXFxcIiMgIFxcXCIjICAqIyBcXFwiN1xceDk5XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN2QrPSQ3ayszJTdcXHg5QSspJTQjNlxcdTAxMkIjXFxcIlxcXCIgJSQjIyAgJFxcXCIjICBcXFwiIyAgKiMgXFxcIjdcXHg5QVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhBOCs9JDdrKzMlN1xceDlGKyklNCM2XFx1MDEyQyNcXFwiXFxcIiAlJCMjICAkXFxcIiMgIFxcXCIjICAqIyBcXFwiN1xceDlCXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDlFK28kIG8hN2srMiQ3XFx4OUMrKCU0XFxcIjZcXHUwMTJEXFxcIiEgJSRcXFwiIyAgXFxcIiMgICw9JiE3aysyJDdcXHg5QysoJTRcXFwiNlxcdTAxMkRcXFwiISAlJFxcXCIjICBcXFwiIyAgXFxcIispJTRcXFwiNlxcdTAxMjlcXFwiXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHg5M1xcXCJcXFwiMlxceDkzM1xceDk0KzwkN2orMiU3PCsoJTQjNlxcdTAxMkUjISAlJCMjICAkXFxcIiMgIFxcXCIjICAqeSBcXFwiIS5cXHUwMTJGXFxcIlxcXCIyXFx1MDEyRjNcXHUwMTMwK1YkN2orTCU3XFx4OTArQiU3ais4JS5cXHUwMTMxXFxcIlxcXCIyXFx1MDEzMTNcXHUwMTMyKyglNCU2XFx1MDEzMyUhXFxcIiUkJSMgICQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICAqLyBcXFwiITdcXHg5RCsnIDQhNlxcdTAxMzQhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEY2XFxcIlxcXCIyXFx4RjYzXFx4RjcrViQ3aitMJTdcXHhBNStCJTdqKzglLlxceEY4XFxcIlxcXCIyXFx4RjgzXFx4RjkrKCU0JTZcXHUwMTM1JSFcXFwiJSQlIyAgJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgICpSIFxcXCIhLlxceEY2XFxcIlxcXCIyXFx4RjYzXFx4RjcrQSQ3ais3JS5cXHhGOFxcXCJcXFwiMlxceEY4M1xceEY5KyclNCM2XFx1MDEzNiMgJSQjIyAgJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4OUYqIyBcXFwiN1xceEE2XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxcdTAxMkZcXFwiXFxcIjJcXHUwMTJGM1xcdTAxMzArViQ3aitMJTdcXHhBMitCJTdqKzglLlxcdTAxMzFcXFwiXFxcIjJcXHUwMTMxM1xcdTAxMzIrKCU0JTZcXHUwMTM3JSFcXFwiJSQlIyAgJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgICpcXHhFNiBcXFwiIS5cXHUwMTJGXFxcIlxcXCIyXFx1MDEyRjNcXHUwMTMwK1YkN2orTCU3XFx4QTUrQiU3ais4JS5cXHUwMTMxXFxcIlxcXCIyXFx1MDEzMTNcXHUwMTMyKyglNCU2XFx1MDEzOCUhXFxcIiUkJSMgICQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICAqXFx4OUMgXFxcIiEuXFx1MDEyRlxcXCJcXFwiMlxcdTAxMkYzXFx1MDEzMCtWJDdqK0wlN1xceEEwK0IlN2orOCUuXFx1MDEzMVxcXCJcXFwiMlxcdTAxMzEzXFx1MDEzMisoJTQlNlxcdTAxMzklIVxcXCIlJCUjICAkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgKlIgXFxcIiEuXFx1MDEyRlxcXCJcXFwiMlxcdTAxMkYzXFx1MDEzMCtBJDdqKzclLlxcdTAxMzFcXFwiXFxcIjJcXHUwMTMxM1xcdTAxMzIrJyU0IzZcXHUwMTNBIyAlJCMjICAkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4QTErXFx4QTMkIG8hN2srTCQuXFx1MDEwQlxcXCJcXFwiMlxcdTAxMEIzXFx1MDEwQys8JTdqKzIlN1xceEExKyglNCQ2XFx4RjQkISAlJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgICxXJiE3aytMJC5cXHUwMTBCXFxcIlxcXCIyXFx1MDEwQjNcXHUwMTBDKzwlN2orMiU3XFx4QTErKCU0JDZcXHhGNCQhICUkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXFxcIispJTRcXFwiNlxcdTAxMTdcXFwiXFxcIiEgJSRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc8K1ckN2srTSUuXFx4RkZcXFwiXFxcIjJcXHhGRjNcXHUwMTAwKz0lN2orMyU3XFx4OTArKSU0JTZcXHUwMTNCJVxcXCIkICUkJSMgICQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICAqYiBcXFwiITdcXHg5MCtXJDdrK00lLlxcdTAxM0NcXFwiXFxcIjJcXHUwMTNDM1xcdTAxM0QrPSU3aiszJTdcXHg5MCspJTQlNlxcdTAxM0UlXFxcIiQgJSQlIyAgJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgIFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEEzKiMgXFxcIjdcXHhBNFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5MCtSJDdqK0glNyErPiU3ais0JTdcXHg4OCsqJTQlNlxcdTAxM0YlIyRcXFwiICUkJSMgICQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICBcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4QTErUiQ3aitIJTchKz4lN2orNCU3XFx4ODgrKiU0JTZcXHUwMTQwJSMkXFxcIiAlJCUjICAkJCMgICQjIyAgJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDkwK1xceEEzJCBvITdrK0wkLlxcdTAxMEJcXFwiXFxcIjJcXHUwMTBCM1xcdTAxMEMrPCU3aisyJTdcXHg5MCsoJTQkNlxcdTAxMDEkISAlJCQjICAkIyMgICRcXFwiIyAgXFxcIiMgICxXJiE3aytMJC5cXHUwMTBCXFxcIlxcXCIyXFx1MDEwQjNcXHUwMTBDKzwlN2orMiU3XFx4OTArKCU0JDZcXHUwMTAxJCEgJSQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICBcXFwiKyklNFxcXCI2XFx1MDExN1xcXCJcXFwiISAlJFxcXCIjICBcXFwiIyAgXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEY2XFxcIlxcXCIyXFx4RjYzXFx4RjcrViQ3aitMJTdcXHg5MCtCJTdqKzglLlxceEY4XFxcIlxcXCIyXFx4RjgzXFx4RjkrKCU0JTZcXHhGQSUhXFxcIiUkJSMgICQkIyAgJCMjICAkXFxcIiMgIFxcXCIjICAqIyBcXFwiN1xceEE3XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3Sio7IFxcXCI3XFx4QTgqNSBcXFwiN1xceEE5Ki8gXFxcIjdcXHhBQSopIFxcXCI3XFx4QUIqIyBcXFwiN1xceEFDXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3USojIFxcXCI3V1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcyKyYgNCE2XFx1MDE0MSEgJSouIFxcXCIhNzMrJiA0ITZcXHUwMTQyISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzwrJyA0ITZcXHUwMTQzISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITctKycgNCE2XFx1MDE0NCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LysnIDQhNlxcdTAxNDUhISAlXCIpXG4gICAgICAgIF0sXG5cbiAgICAgICAgcGVnJGN1cnJQb3MgICAgICAgICAgPSAwLFxuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgICAgICA9IDAsXG4gICAgICAgIHBlZyRjYWNoZWRQb3MgICAgICAgID0gMCxcbiAgICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9LFxuICAgICAgICBwZWckbWF4RmFpbFBvcyAgICAgICA9IDAsXG4gICAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgID0gW10sXG4gICAgICAgIHBlZyRzaWxlbnRGYWlscyAgICAgID0gMCxcblxuICAgICAgICBwZWckcmVzdWx0O1xuXG4gICAgaWYgKFwic3RhcnRSdWxlXCIgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKCEob3B0aW9ucy5zdGFydFJ1bGUgaW4gcGVnJHN0YXJ0UnVsZUluZGljZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFwiLlwiKTtcbiAgICAgIH1cblxuICAgICAgcGVnJHN0YXJ0UnVsZUluZGV4ID0gcGVnJHN0YXJ0UnVsZUluZGljZXNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRyZXBvcnRlZFBvcywgcGVnJGN1cnJQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICAgIHJldHVybiBwZWckcmVwb3J0ZWRQb3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZSgpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5saW5lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbHVtbigpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5jb2x1bW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24pIHtcbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihcbiAgICAgICAgbnVsbCxcbiAgICAgICAgW3sgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfV0sXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgbnVsbCwgcGVnJHJlcG9ydGVkUG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XG4gICAgICBmdW5jdGlvbiBhZHZhbmNlKGRldGFpbHMsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICAgICAgdmFyIHAsIGNoO1xuXG4gICAgICAgIGZvciAocCA9IHN0YXJ0UG9zOyBwIDwgZW5kUG9zOyBwKyspIHtcbiAgICAgICAgICBjaCA9IGlucHV0LmNoYXJBdChwKTtcbiAgICAgICAgICBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGlmICghZGV0YWlscy5zZWVuQ1IpIHsgZGV0YWlscy5saW5lKys7IH1cbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwZWckY2FjaGVkUG9zICE9PSBwb3MpIHtcbiAgICAgICAgaWYgKHBlZyRjYWNoZWRQb3MgPiBwb3MpIHtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zID0gMDtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZShwZWckY2FjaGVkUG9zRGV0YWlscywgcGVnJGNhY2hlZFBvcywgcG9zKTtcbiAgICAgICAgcGVnJGNhY2hlZFBvcyA9IHBvcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlZyRjYWNoZWRQb3NEZXRhaWxzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgICAgfVxuXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBleHBlY3RlZCwgcG9zKSB7XG4gICAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuXG4gICAgICAgIGV4cGVjdGVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIGlmIChhLmRlc2NyaXB0aW9uIDwgYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYS5kZXNjcmlwdGlvbiA+IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdoaWxlIChpIDwgZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkW2kgLSAxXSA9PT0gZXhwZWN0ZWRbaV0pIHtcbiAgICAgICAgICAgIGV4cGVjdGVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZ0VzY2FwZShzKSB7XG4gICAgICAgICAgZnVuY3Rpb24gaGV4KGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG5cbiAgICAgICAgICByZXR1cm4gc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgICAnXFxcXFxcXFwnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICAgICdcXFxcXCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICAgJ1xcXFx0JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgICAnXFxcXG4nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcZi9nLCAgICdcXFxcZicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyL2csICAgJ1xcXFxyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4ODAtXFx4RkZdL2csICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgnICArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTAxODAtXFx1MEZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUxMDgwLVxcdUZGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdScgICsgaGV4KGNoKTsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWREZXNjcyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICAgICAgZXhwZWN0ZWREZXNjLCBmb3VuZERlc2MsIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZXhwZWN0ZWREZXNjc1tpXSA9IGV4cGVjdGVkW2ldLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0ZWREZXNjID0gZXhwZWN0ZWQubGVuZ3RoID4gMVxuICAgICAgICAgID8gZXhwZWN0ZWREZXNjcy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICAgICsgXCIgb3IgXCJcbiAgICAgICAgICAgICAgKyBleHBlY3RlZERlc2NzW2V4cGVjdGVkLmxlbmd0aCAtIDFdXG4gICAgICAgICAgOiBleHBlY3RlZERlc2NzWzBdO1xuXG4gICAgICAgIGZvdW5kRGVzYyA9IGZvdW5kID8gXCJcXFwiXCIgKyBzdHJpbmdFc2NhcGUoZm91bmQpICsgXCJcXFwiXCIgOiBcImVuZCBvZiBpbnB1dFwiO1xuXG4gICAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWREZXNjICsgXCIgYnV0IFwiICsgZm91bmREZXNjICsgXCIgZm91bmQuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcyksXG4gICAgICAgICAgZm91bmQgICAgICA9IHBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwb3MpIDogbnVsbDtcblxuICAgICAgaWYgKGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgIG1lc3NhZ2UgIT09IG51bGwgPyBtZXNzYWdlIDogYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksXG4gICAgICAgIGV4cGVjdGVkLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgcG9zLFxuICAgICAgICBwb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIHBvc0RldGFpbHMuY29sdW1uXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRkZWNvZGUocykge1xuICAgICAgdmFyIGJjID0gbmV3IEFycmF5KHMubGVuZ3RoKSwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmNbaV0gPSBzLmNoYXJDb2RlQXQoaSkgLSAzMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVJ1bGUoaW5kZXgpIHtcbiAgICAgIHZhciBiYyAgICA9IHBlZyRieXRlY29kZVtpbmRleF0sXG4gICAgICAgICAgaXAgICAgPSAwLFxuICAgICAgICAgIGlwcyAgID0gW10sXG4gICAgICAgICAgZW5kICAgPSBiYy5sZW5ndGgsXG4gICAgICAgICAgZW5kcyAgPSBbXSxcbiAgICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICAgIHBhcmFtcywgaTtcblxuICAgICAgZnVuY3Rpb24gcHJvdGVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkob2JqZWN0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiID8gW10gOiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHdoaWxlIChpcCA8IGVuZCkge1xuICAgICAgICAgIHN3aXRjaCAoYmNbaXBdKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gocHJvdGVjdChwZWckY29uc3RzW2JjW2lwICsgMV1dKSk7XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgc3RhY2subGVuZ3RoIC09IGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHN0YWNrLnNwbGljZSgtMiwgMSk7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnB1c2goc3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSBiY1tpcCArIDFdLCBiY1tpcCArIDFdKSk7XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKGlucHV0LnN1YnN0cmluZyhzdGFja1tzdGFjay5sZW5ndGggLSAxXSwgcGVnJGN1cnJQb3MpKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcblxuICAgICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgIGlwICs9IDM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcblxuICAgICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgIGlwICs9IDM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcblxuICAgICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgIGlwICs9IDM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgICAgaXBzLnB1c2goaXApO1xuXG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAyICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlwICs9IDIgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBlZyRjdXJyUG9zKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5sZW5ndGgpID09PSBwZWckY29uc3RzW2JjW2lwICsgMV1dKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM107XG4gICAgICAgICAgICAgICAgaXAgKz0gNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdKTtcblxuICAgICAgICAgICAgICBpZiAocGVnJGNvbnN0c1tiY1tpcCArIDFdXS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCBiY1tpcCArIDFdKSk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IGJjW2lwICsgMV07XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSBwZWckY29uc3RzW2JjW2lwICsgMV1dLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJEZBSUxFRCk7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckY29uc3RzW2JjW2lwICsgMV1dKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMSAtIGJjW2lwICsgMV1dO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICBwYXJhbXMgPSBiYy5zbGljZShpcCArIDQsIGlwICsgNCArIGJjW2lwICsgM10pO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmNbaXAgKyAzXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2ldID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMSAtIHBhcmFtc1tpXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdGFjay5zcGxpY2UoXG4gICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoIC0gYmNbaXAgKyAyXSxcbiAgICAgICAgICAgICAgICBiY1tpcCArIDJdLFxuICAgICAgICAgICAgICAgIHBlZyRjb25zdHNbYmNbaXAgKyAxXV0uYXBwbHkobnVsbCwgcGFyYW1zKVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChwZWckcGFyc2VSdWxlKGJjW2lwICsgMV0pKTtcbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wY29kZTogXCIgKyBiY1tpcF0gKyBcIi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVuZCA9IGVuZHMucG9wKCk7XG4gICAgICAgICAgaXAgPSBpcHMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YWNrWzBdO1xuICAgIH1cblxuXG4gICAgICB2YXIgcGFyc2VyID0gcmVxdWlyZSgnLi4vbGliL2NvbXBpbGVyL3BhcnNlcicpO1xuICAgICAgdmFyIGJ1aWxkQmluYXJ5Q2hhaW4gPSBwYXJzZXIuYnVpbGRCaW5hcnlDaGFpbjtcbiAgICAgIHZhciBoYXNPcGVyYXRvciA9IHBhcnNlci5oYXNPcGVyYXRvcjtcbiAgICAgIHZhciBjaGFuZ2VPcGVyYXRvciA9IHBhcnNlci5jaGFuZ2VPcGVyYXRvcjtcbiAgICAgIHZhciBzeW1JbnRlcnBvbGF0ZSA9IHBhcnNlci5zeW1JbnRlcnBvbGF0ZTtcbiAgICAgIHZhciBpc0ludGVycG9sYXRlZCA9IHBhcnNlci5pc0ludGVycG9sYXRlZDtcbiAgICAgIHZhciBpc0lkZW50aWZpZXIgPSBwYXJzZXIuaXNJZGVudGlmaWVyO1xuICAgICAgdmFyIHN0bXRzID0gcGFyc2VyLnN0bXRzO1xuXG4gICAgICBmdW5jdGlvbiBzeW0odmFsdWUsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgdHlwZTogdHlwZSB8fCAnb3AnLFxuICAgICAgICAgIGxpbmU6IGxpbmUoKSxcbiAgICAgICAgICBjb2x1bW46IGNvbHVtbigpXG4gICAgICAgIH07XG4gICAgICB9XG5cblxuICAgIHBlZyRyZXN1bHQgPSBwZWckcGFyc2VSdWxlKHBlZyRzdGFydFJ1bGVJbmRleCk7XG5cbiAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcGVnJHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcGVnJGZhaWwoeyB0eXBlOiBcImVuZFwiLCBkZXNjcmlwdGlvbjogXCJlbmQgb2YgaW5wdXRcIiB9KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG51bGwsIHBlZyRtYXhGYWlsRXhwZWN0ZWQsIHBlZyRtYXhGYWlsUG9zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFN5bnRheEVycm9yOiBTeW50YXhFcnJvcixcbiAgICBwYXJzZTogICAgICAgcGFyc2VcbiAgfTtcbn0pKCk7XG4iLCIvKlxuICogSW50ZXJwb2wgKExvZ2ljZnVsIEhUTUwgVGVtcGxhdGVzKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBzZWUgZG9jL0xJQ0VOU0UubWRcbiAqXG4gKiBAYXV0aG9yIFRob21hcyBTLiBCcmFkZm9yZCAoa29kZTRmb29kLml0KVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gaXNBbm5vdGF0aW9ucyhub2RlKSB7XG4gIHJldHVybiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZSAhPT0gbnVsbCAmJiBub2RlLl9faW50QW5ub3RhdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFubm90YXRpb25zKCkge1xuICByZXR1cm4ge1xuICAgIF9faW50QW5ub3RhdGlvbnM6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QW5ub3RhdGlvbnMobm9kZSkge1xuICBpZiAoIGlzQW5ub3RhdGlvbnMobm9kZSkgKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgYW5ub3RhdGlvbnMgPSBub2RlLmFubm90YXRpb25zO1xuICBpZiAoICFhbm5vdGF0aW9ucyApIHtcbiAgICBhbm5vdGF0aW9ucyA9IG5vZGUuYW5ub3RhdGlvbnMgPSBjcmVhdGVBbm5vdGF0aW9ucygpO1xuICB9XG4gIHJldHVybiBhbm5vdGF0aW9ucztcbn1cblxuZnVuY3Rpb24gYW5ub3RhdGUobm9kZSwgZ3JvdXAsIG5hbWUpIHtcbiAgdmFyIGFubm90YXRpb25zID0gZ2V0QW5ub3RhdGlvbnMobm9kZSk7XG4gIHZhciBncm91cE9iamVjdCA9IGFubm90YXRpb25zW2dyb3VwXTtcbiAgaWYgKCAhZ3JvdXBPYmplY3QgKSB7XG4gICAgZ3JvdXBPYmplY3QgPSBhbm5vdGF0aW9uc1tncm91cF0gPSB7fTtcbiAgfVxuICBncm91cE9iamVjdFtuYW1lXSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGhhc0Fubm90YXRpb24obm9kZSwgZ3JvdXAsIG5hbWUpIHtcbiAgdmFyIGFubm90YXRpb25zID0gZ2V0QW5ub3RhdGlvbnMobm9kZSk7XG4gIHZhciBncm91cE9iamVjdCA9IGFubm90YXRpb25zW2dyb3VwXTtcbiAgaWYgKCAhZ3JvdXBPYmplY3QgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBncm91cE9iamVjdFtuYW1lXTtcbn1cblxuLy8gRXhwb3J0ZWQgRnVuY3Rpb25zXG5leHBvcnRzLmlzQW5ub3RhdGlvbnMgPSBpc0Fubm90YXRpb25zO1xuZXhwb3J0cy5jcmVhdGVBbm5vdGF0aW9ucyA9IGNyZWF0ZUFubm90YXRpb25zO1xuZXhwb3J0cy5nZXRBbm5vdGF0aW9ucyA9IGdldEFubm90YXRpb25zO1xuZXhwb3J0cy5hbm5vdGF0ZSA9IGFubm90YXRlO1xuZXhwb3J0cy5oYXNBbm5vdGF0aW9uID0gaGFzQW5ub3RhdGlvbjtcbiIsIi8qXG4gKiBJbnRlcnBvbCAoTG9naWNmdWwgSFRNTCBUZW1wbGF0ZXMpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIHNlZSBkb2MvTElDRU5TRS5tZFxuICpcbiAqIEBhdXRob3IgVGhvbWFzIFMuIEJyYWRmb3JkIChrb2RlNGZvb2QuaXQpXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhbm5vdGF0aW9ucyA9IHJlcXVpcmUoJy4vYW5ub3RhdGlvbnMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgZ2V0QW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5nZXRBbm5vdGF0aW9ucztcbnZhciBoYXNBbm5vdGF0aW9uID0gYW5ub3RhdGlvbnMuaGFzQW5ub3RhdGlvbjtcblxudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG52YXIgb2JqZWN0S2V5cyA9IHV0aWwub2JqZWN0S2V5cztcbnZhciBlYWNoID0gdXRpbC5lYWNoO1xudmFyIG1hcCA9IHV0aWwubWFwO1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbnZhciBsYW5ndWFnZXMgPSB7XG4gICdqYXZhc2NyaXB0JzogcmVxdWlyZSgnLi9qYXZhc2NyaXB0Jylcbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXRMYW5ndWFnZSh0YXJnZXRMYW5ndWFnZSkge1xuICB2YXIgbGFuZyA9IGxhbmd1YWdlc1t0YXJnZXRMYW5ndWFnZV07XG4gIGlmICggbGFuZyApIHtcbiAgICByZXR1cm4gbGFuZztcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBUYXJnZXQgTGFuZ3VhZ2U6IFwiICsgdGFyZ2V0TGFuZ3VhZ2UpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcGFyc2UgdHJlZSBpbnRvIHNvdXJjZSBjb2RlIChpbml0aWFsbHkgSmF2YVNjcmlwdCkgdGhhdCBjYW5cbiAqIGJlIHB1bGxlZCBpbnRvIGFuIEludGVycG9sIFJ1bnRpbWUgaW5zdGFuY2UuICBIb3N0IExhbmd1YWdlLXNwZWNpZmljXG4gKiBjb25zdHJ1Y3RzIGFyZSBhdm9pZGVkIGhlcmUgYW5kIGluc3RlYWQgcHJvZHVjZWQgYnkgSmF2YVNjcmlwdCBjb2RlXG4gKiBnZW5lcmF0aW9uIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyaXBwZWRUcmVlIHRoZSBwYXJzZSB0cmVlIHRvIHVzZSAocmV3cml0dGVuICYgc3RyaXBwZWQpXG4gKiBAcGFyYW0ge01peGVkW119IGxpdGVyYWxzIEEgdGFibGUgb2YgbGl0ZXJhbCB2YWx1ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB1c2VkIGJ5IEludGVycG9sIG9yIGl0cyBDTElcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVNb2R1bGVCb2R5KHN0cmlwcGVkVHJlZSwgbGl0ZXJhbHMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzaGFyZWRHbG9iYWxzID0gISFvcHRpb25zLmdsb2JhbHM7XG4gIHZhciBmdW5jdGlvbldyYXBwZXIgPSBvcHRpb25zLmZ1bmN0aW9uV3JhcHBlciB8fCBub1dyYXBwZXI7XG4gIHZhciB0YXJnZXRMYW5ndWFnZSA9IG9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2UgfHwgJ2phdmFzY3JpcHQnO1xuICB2YXIgbGFuZyA9IHJlc29sdmVUYXJnZXRMYW5ndWFnZSh0YXJnZXRMYW5ndWFnZSk7XG5cbiAgdmFyIGdsb2JhbHMgPSBvcHRpb25zLmdsb2JhbHMgfHwgbGFuZy5jcmVhdGVHbG9iYWxzKCk7XG4gIHZhciBnZW4gPSBsYW5nLmNyZWF0ZU1vZHVsZShnbG9iYWxzKTtcblxuICAvLyBBIGxvb2t1cCB0YWJsZSBvZiBjb2RlIGdlbmVyYXRvcnNcbiAgdmFyIEV2YWx1YXRvcnMgPSB7XG4gICAgJ2ltJzogY3JlYXRlSW1wb3J0RXZhbHVhdG9yLFxuICAgICdkZSc6IGNyZWF0ZVBhcnRpYWxFdmFsdWF0b3IsXG4gICAgJ2JpJzogY3JlYXRlQmluZEV2YWx1YXRvcixcbiAgICAnY2EnOiBjcmVhdGVDYWxsRXZhbHVhdG9yLFxuICAgICdhcyc6IGNyZWF0ZUFzc2lnbkV2YWx1YXRvcixcbiAgICAnb3AnOiBjcmVhdGVPcGVuVGFnRXZhbHVhdG9yLFxuICAgICdjbCc6IGNyZWF0ZUNsb3NlVGFnRXZhbHVhdG9yLFxuICAgICdjdCc6IGNyZWF0ZUNvbW1lbnRUYWdFdmFsdWF0b3IsXG4gICAgJ2R0JzogY3JlYXRlRG9jVHlwZUV2YWx1YXRvcixcbiAgICAnb3UnOiBjcmVhdGVPdXRwdXRFdmFsdWF0b3IsXG4gICAgJ3JhJzogY3JlYXRlUmF3T3V0cHV0RXZhbHVhdG9yLFxuICAgICdsYyc6IGNyZWF0ZUxpc3RDb21wRXZhbHVhdG9yLFxuICAgICdmcic6IGNyZWF0ZUZvckV2YWx1YXRvcixcbiAgICAnY24nOiBjcmVhdGVUZXJuYXJ5RXZhbHVhdG9yLFxuICAgICdpZic6IGNyZWF0ZUlmRXZhbHVhdG9yLFxuICAgICdvcic6IGNyZWF0ZU9yRXZhbHVhdG9yLFxuICAgICdhbic6IGNyZWF0ZUFuZEV2YWx1YXRvcixcbiAgICAnZXEnOiBjcmVhdGVFcUV2YWx1YXRvcixcbiAgICAnbWEnOiBjcmVhdGVNYXRjaEV2YWx1YXRvcixcbiAgICAnbnEnOiBjcmVhdGVOZXFFdmFsdWF0b3IsXG4gICAgJ2d0JzogY3JlYXRlR3RFdmFsdWF0b3IsXG4gICAgJ2x0JzogY3JlYXRlTHRFdmFsdWF0b3IsXG4gICAgJ2dlJzogY3JlYXRlR3RlRXZhbHVhdG9yLFxuICAgICdsZSc6IGNyZWF0ZUx0ZUV2YWx1YXRvcixcbiAgICAnYWQnOiBjcmVhdGVBZGRFdmFsdWF0b3IsXG4gICAgJ3N1JzogY3JlYXRlU3ViRXZhbHVhdG9yLFxuICAgICdtdSc6IGNyZWF0ZU11bEV2YWx1YXRvcixcbiAgICAnZGknOiBjcmVhdGVEaXZFdmFsdWF0b3IsXG4gICAgJ21vJzogY3JlYXRlTW9kRXZhbHVhdG9yLFxuICAgICdmbSc6IGNyZWF0ZUZvcm1hdEV2YWx1YXRvcixcbiAgICAnbm8nOiBjcmVhdGVOb3RFdmFsdWF0b3IsXG4gICAgJ25lJzogY3JlYXRlTmVnRXZhbHVhdG9yLFxuICAgICdwbyc6IGNyZWF0ZVBvc0V2YWx1YXRvcixcbiAgICAnbWInOiBjcmVhdGVNZW1iZXJFdmFsdWF0b3IsXG4gICAgJ2FyJzogY3JlYXRlQXJyYXlFdmFsdWF0b3IsXG4gICAgJ2RjJzogY3JlYXRlRGljdGlvbmFyeUV2YWx1YXRvcixcbiAgICAnaWQnOiBjcmVhdGVJZEV2YWx1YXRvcixcbiAgICAnc2UnOiBjcmVhdGVTZWxmRXZhbHVhdG9yXG4gIH07XG5cbiAgLy8gQXR0YWNoIGFubm90YXRpb24gcmV0cmlldmVyIHRvIGNyZWF0ZSBmdW5jdGlvbnNcbiAgZWFjaChvYmplY3RLZXlzKEV2YWx1YXRvcnMpLCBmdW5jdGlvbiAoZnVuY05hbWUpIHtcbiAgICB2YXIgZnVuYyA9IEV2YWx1YXRvcnNbZnVuY05hbWVdO1xuICAgIGZ1bmMuZ2V0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgcmV0dXJuIGFyZ3NbZnVuYy5sZW5ndGhdIHx8IHt9O1xuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbldyYXBwZXIoZnVuY3Rpb24gKCkge1xuICAgIGNyZWF0ZU1vZHVsZUZ1bmN0aW9uKHN0cmlwcGVkVHJlZSk7XG4gICAgdmFyIGJvZHkgPSBnZW4udG9TdHJpbmcoKTtcblxuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICBpZiAoICFzaGFyZWRHbG9iYWxzICkge1xuICAgICAgYnVmZmVyLnB1c2goZ2xvYmFscy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgYnVmZmVyLnB1c2goYm9keSk7XG5cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xuICB9KTtcblxuICBmdW5jdGlvbiBjcmVhdGVNb2R1bGVGdW5jdGlvbihwYXJzZVRyZWUpIHtcbiAgICB2YXIgZGVmaW5lTW9kdWxlID0gZ2xvYmFscy5ydW50aW1lSW1wb3J0KCdkZWZpbmVNb2R1bGUnKTtcblxuICAgIGdlbi5yZXR1cm5TdGF0ZW1lbnQoZnVuY3Rpb24gKCkge1xuICAgICAgZ2VuLmNhbGwoZGVmaW5lTW9kdWxlLCBbXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBnZW4uZnVuYyhbJ2MnLCAndyddLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGVTdGF0ZW1lbnRzRXZhbHVhdG9yIHdpbGwgcG9wdWxhdGUgZ2xvYmFsVmFyc1xuICAgICAgICAgICAgY3JlYXRlU3RhdGVtZW50c0V2YWx1YXRvcihwYXJzZVRyZWUpO1xuICAgICAgICAgIH0sIGdldEFubm90YXRpb25zKHBhcnNlVHJlZSkpO1xuICAgICAgICB9XG4gICAgICBdKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vV3JhcHBlcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmZXIoZnVuYykge1xuICAgIHZhciBhcmdzO1xuICAgIGlmICggdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICBmdW5jID0gY3JlYXRlRXZhbHVhdG9yO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYnVzaWVzdCBmdW5jdGlvbiBpbiB0aGUgY29kZSBnZW5lcmF0b3IuICBjcmVhdGVFdmFsdWF0b3JcbiAgICogcmVzb2x2ZXMgdGhlIGV2YWx1YXRvciBnZW5lcmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSBieSB0YWtpbmcgdGhlXG4gICAqIGZpcnN0IGVsZW1lbnQgb2YgdGhlIG5vZGUgYXJyYXkuICBJdCB0aGVuIHBhc3NlcyB0aGUgcmVzdCBvZiB0aGVcbiAgICogbm9kZSdzIGVsZW1lbnRzIGFzIGFyZ3VtZW50cyB0byB0aGF0IGdlbmVyYXRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSBub2RlIEVpdGhlciBhbiBBcnJheSBvciBhIExpdGVyYWwgSWRcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUV2YWx1YXRvcihub2RlKSB7XG4gICAgaWYgKCAhaXNBcnJheShub2RlKSApIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdW50ZXN0YWJsZSAqL1xuICAgICAgaWYgKCBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBOb2RlIGluIFBhcnNlIFRyZWVcIik7XG4gICAgICB9XG4gICAgICB2YXIgbGl0ZXJhbCA9IGdsb2JhbHMubGl0ZXJhbChsaXRlcmFsc1tub2RlXSk7XG4gICAgICBnZW4ud3JpdGUobGl0ZXJhbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vZGVUeXBlID0gbGl0ZXJhbHNbbm9kZVswXV07XG4gICAgdmFyIGNyZWF0ZUZ1bmN0aW9uID0gRXZhbHVhdG9yc1tub2RlVHlwZV07XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHVudGVzdGFibGUgKi9cbiAgICBpZiAoICFjcmVhdGVGdW5jdGlvbiApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTm9kZSBpbiBQYXJzZSBUcmVlOiBcIiArIG5vZGVUeXBlKTtcbiAgICB9XG5cbiAgICAvLyBhdHRhY2ggYW5ub3RhdGlvbnMganVzdCBiZXlvbmQgdGhlIGxhc3Qga25vd24gYXJndW1lbnRcbiAgICB2YXIgYXJncyA9IG5vZGUuc2xpY2UoMSk7XG4gICAgYXJnc1tjcmVhdGVGdW5jdGlvbi5sZW5ndGhdID0gZ2V0QW5ub3RhdGlvbnMobm9kZSk7XG4gICAgY3JlYXRlRnVuY3Rpb24uYXBwbHkobm9kZSwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVCaW5hcnlFdmFsdWF0b3Iob3BlcmF0b3IsIGxlZnROb2RlLCByaWdodE5vZGUpIHtcbiAgICBnZW4uYmluYXJ5T3BlcmF0b3Iob3BlcmF0b3IsIGRlZmVyKGxlZnROb2RlKSwgZGVmZXIocmlnaHROb2RlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdGF0ZW1lbnRzRXZhbHVhdG9yKHN0YXRlbWVudE5vZGVzKSB7XG4gICAgZWFjaChzdGF0ZW1lbnROb2RlcywgY3JlYXRlRXZhbHVhdG9yKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGFuIGV2YWx1YXRvciB0byBkZWFsIHdpdGggJ2Zyb20nIGFuZCAnaW1wb3J0JyBzdGF0ZW1lbnRzXG4gIGZ1bmN0aW9uIGNyZWF0ZUltcG9ydEV2YWx1YXRvcihmcm9tTm9kZXMpIHtcbiAgICB2YXIgYXNzaWducyA9IFtdO1xuICAgIGVhY2goZnJvbU5vZGVzLCBmdW5jdGlvbiAoZnJvbU5vZGUpIHtcbiAgICAgIHZhciBtb2R1bGVOYW1lID0gbGl0ZXJhbHNbZnJvbU5vZGVbMF1dO1xuICAgICAgdmFyIG1vZHVsZU5hbWVJZCA9IGdsb2JhbHMubGl0ZXJhbChtb2R1bGVOYW1lKTtcbiAgICAgIHZhciBpbXBvcnRlciA9IGdsb2JhbHMuYnVpbGRlcignaW1wb3J0ZXInLCBtb2R1bGVOYW1lSWQpO1xuXG4gICAgICB2YXIgYWxpYXNlcyA9IGZyb21Ob2RlWzFdO1xuICAgICAgaWYgKCAhaXNBcnJheShhbGlhc2VzKSApIHtcbiAgICAgICAgdmFyIG1vZHVsZUFsaWFzO1xuICAgICAgICBpZiAoIHR5cGVvZiBhbGlhc2VzID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICBtb2R1bGVBbGlhcyA9IGxpdGVyYWxzW2FsaWFzZXNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG1vZHVsZUFsaWFzID0gbW9kdWxlTmFtZS5zcGxpdCgnLycpLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2lnbnMucHVzaChbXG4gICAgICAgICAgbW9kdWxlQWxpYXMsXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZ2VuLmNhbGwoaW1wb3J0ZXIsIFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0b1Jlc29sdmUgPSBtYXAoYWxpYXNlcywgZnVuY3Rpb24gKGltcG9ydEluZm8pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBsaXRlcmFsc1tpbXBvcnRJbmZvWzBdXTtcbiAgICAgICAgdmFyIGFsaWFzID0gaW1wb3J0SW5mb1sxXSA/IGxpdGVyYWxzW2ltcG9ydEluZm9bMV1dIDogbmFtZTtcbiAgICAgICAgcmV0dXJuIFthbGlhcywgbmFtZV07XG4gICAgICB9KTtcblxuICAgICAgdmFyIGdldFByb3BlcnR5ID0gZ2xvYmFscy5ydW50aW1lSW1wb3J0KCdnZXRQcm9wZXJ0eScpO1xuICAgICAgdmFyIGFub24gPSBnZW4uYW5vbnltb3VzKCk7XG4gICAgICBhc3NpZ25zLnB1c2goW1xuICAgICAgICBhbm9uLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZ2VuLmNhbGwoaW1wb3J0ZXIsIFtdKTtcbiAgICAgICAgfVxuICAgICAgXSk7XG4gICAgICBlYWNoKHRvUmVzb2x2ZSwgZnVuY3Rpb24gKGFsaWFzTWFwKSB7XG4gICAgICAgIGFzc2lnbnMucHVzaChbXG4gICAgICAgICAgYWxpYXNNYXBbMF0sXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZ2VuLmNhbGwoXG4gICAgICAgICAgICAgIGdldFByb3BlcnR5LFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBnZW4uYW5vbnltb3VzKGFub24pOyB9LFxuICAgICAgICAgICAgICAgIGdsb2JhbHMubGl0ZXJhbChhbGlhc01hcFsxXSlcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIF0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZ2VuLmFzc2lnbm1lbnRzKGFzc2lnbnMpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYW4gZXZhbHVhdG9yIHRvIHJlcHJlc2VudCBhIHBhcnRpYWwgYW5kIGl0cyBhc3NvY2lhdGVkIGNsb3N1cmVcbiAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbEV2YWx1YXRvcihuYW1lTGl0ZXJhbCwgcGFyYW1EZWZzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudE5vZGVzLCBndWFyZE5vZGUpIHtcbiAgICB2YXIgYW5ub3RhdGlvbnMgPSBjcmVhdGVQYXJ0aWFsRXZhbHVhdG9yLmdldEFubm90YXRpb25zKGFyZ3VtZW50cyk7XG4gICAgdmFyIHBhcnRpYWxOYW1lID0gbGl0ZXJhbHNbbmFtZUxpdGVyYWxdO1xuICAgIHZhciBwYXJhbU5hbWVzID0gbWFwKHBhcmFtRGVmcywgZnVuY3Rpb24gKHBhcmFtRGVmKSB7XG4gICAgICByZXR1cm4gbGl0ZXJhbHNbcGFyYW1EZWZdO1xuICAgIH0pO1xuICAgIHZhciBjcmVhdGUgPSBndWFyZE5vZGUgPyBjcmVhdGVHdWFyZGVkUGFydGlhbCA6IGNyZWF0ZVVuZ3VhcmRlZFBhcnRpYWw7XG4gICAgY3JlYXRlKCk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVbmd1YXJkZWRQYXJ0aWFsKCkge1xuICAgICAgdmFyIGRlZmluZVBhcnRpYWwgPSBnbG9iYWxzLnJ1bnRpbWVJbXBvcnQoJ2RlZmluZVBhcnRpYWwnKTtcbiAgICAgIGdlbi5jYWxsKGRlZmluZVBhcnRpYWwsIFtcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGdlbi5mdW5jKFxuICAgICAgICAgICAgW2dlbi53cml0ZXIoKV0sXG4gICAgICAgICAgICBwYXJhbU5hbWVzLFxuICAgICAgICAgICAgZGVmZXIoY3JlYXRlU3RhdGVtZW50c0V2YWx1YXRvciwgc3RhdGVtZW50Tm9kZXMpLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICBdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVHdWFyZGVkUGFydGlhbCgpIHtcbiAgICAgIHZhciBkZWZpbmVQYXJ0aWFsID0gZ2xvYmFscy5ydW50aW1lSW1wb3J0KCdkZWZpbmVHdWFyZGVkUGFydGlhbCcpO1xuICAgICAgZ2VuLmNhbGwoZGVmaW5lUGFydGlhbCwgW1xuICAgICAgICBnZW4uY29kZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZ2VuLmdldHRlcihwYXJ0aWFsTmFtZSk7XG4gICAgICAgIH0pLFxuICAgICAgICBjcmVhdGVXcmFwcGVyXG4gICAgICBdKTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlcigpIHtcbiAgICAgICAgZ2VuLmZ1bmMoWydvJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBnZW4ucmV0dXJuU3RhdGVtZW50KGNyZWF0ZUZ1bmN0aW9uKTtcbiAgICAgICAgfSwgYW5ub3RhdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbigpIHtcbiAgICAgICAgZ2VuLmZ1bmMoXG4gICAgICAgICAgW2dlbi53cml0ZXIoKV0sXG4gICAgICAgICAgcGFyYW1OYW1lcyxcbiAgICAgICAgICBjcmVhdGVQcm9sb2csXG4gICAgICAgICAgZGVmZXIoY3JlYXRlU3RhdGVtZW50c0V2YWx1YXRvciwgc3RhdGVtZW50Tm9kZXMpLFxuICAgICAgICAgIGFubm90YXRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb2xvZygpIHtcbiAgICAgICAgZ2VuLmlmU3RhdGVtZW50KFxuICAgICAgICAgIGRlZmVyKGd1YXJkTm9kZSksXG4gICAgICAgICAgbnVsbCwgIC8vIHRoaXMgaXMgYW4gJ2Vsc2UnIGNhc2VcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnZW4ucmV0dXJuU3RhdGVtZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZ2VuLmNhbGwoJ28nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBhIGJvdW5kIGNhbGwgZXZhbHVhdG9yXG4gIGZ1bmN0aW9uIGNyZWF0ZUJpbmRFdmFsdWF0b3IobWVtYmVyTm9kZSwgYXJnTm9kZXMpIHtcbiAgICB2YXIgYmluZFBhcnRpYWwgPSBnbG9iYWxzLnJ1bnRpbWVJbXBvcnQoJ2JpbmRQYXJ0aWFsJyk7XG4gICAgdmFyIG1lbWJlciA9IGRlZmVyKG1lbWJlck5vZGUpO1xuICAgIHZhciBhcmdzID0gZGVmZXIoY3JlYXRlQXJyYXlFdmFsdWF0b3IsIGFyZ05vZGVzKTtcbiAgICBnZW4uY2FsbChiaW5kUGFydGlhbCwgW2dlbi5zZWxmLCBtZW1iZXIsIGFyZ3NdKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGFuIGV2YWx1YXRvciB0byBwZXJmb3JtIGEgZnVuY3Rpb24gb3IgcGFydGlhbCBjYWxsXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhbGxFdmFsdWF0b3IobWVtYmVyTm9kZSwgYXJnTm9kZXMpIHtcbiAgICB2YXIgZXhlYyA9IGdsb2JhbHMucnVudGltZUltcG9ydCgnZXhlYycpO1xuICAgIHZhciBtZW1iZXIgPSBkZWZlcihtZW1iZXJOb2RlKTtcblxuICAgIHZhciBhcmdzID0gW2dlbi53cml0ZXIoKV07XG4gICAgZWFjaChhcmdOb2RlcywgZnVuY3Rpb24gKGFyZ05vZGUpIHtcbiAgICAgIGFyZ3MucHVzaChkZWZlcihhcmdOb2RlKSk7XG4gICAgfSk7XG5cbiAgICBnZW4uY2FsbChleGVjLCBbZ2VuLnNlbGYsIG1lbWJlciwgZGVmZXIoZ2VuLnZlY3RvciwgYXJncyldKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGFuIGV2YWx1YXRvciB0byBwZXJmb3JtIGxvY2FsIHZhcmlhYmxlIGFzc2lnbm1lbnRcbiAgZnVuY3Rpb24gY3JlYXRlQXNzaWduRXZhbHVhdG9yKGFzc2lnbm1lbnREZWZzKSB7XG4gICAgdmFyIGRlY2xzID0gbWFwKGFzc2lnbm1lbnREZWZzLCBmdW5jdGlvbiAoYXNzaWdubWVudERlZikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgbGl0ZXJhbHNbYXNzaWdubWVudERlZlswXV0sXG4gICAgICAgIGRlZmVyKGFzc2lnbm1lbnREZWZbMV0pXG4gICAgICBdO1xuICAgIH0pO1xuICAgIGdlbi5hc3NpZ25tZW50cyhkZWNscyk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBhbiBldmFsdWF0b3IgdG8gd3JpdGUgYW4gaHRtbCBvcGVuaW5nIHRhZ1xuICBmdW5jdGlvbiBjcmVhdGVPcGVuVGFnRXZhbHVhdG9yKG5hbWVOb2RlLCBhdHRyaWJ1dGVEZWZzLCBzZWxmQ2xvc2UpIHtcbiAgICB2YXIgbmFtZSA9IGRlZmVyKG5hbWVOb2RlKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRlZmVyKGNyZWF0ZURpY3Rpb25hcnlFdmFsdWF0b3IsIGF0dHJpYnV0ZURlZnMsIHRydWUpO1xuICAgIHZhciBtZXRob2ROYW1lID0gc2VsZkNsb3NlID8gJ3NlbGZDbG9zZUVsZW1lbnQnIDogJ3N0YXJ0RWxlbWVudCc7XG4gICAgZ2VuLnN0YXRlbWVudChmdW5jdGlvbiAoKSB7XG4gICAgICBnZW4uY2FsbChnZW4ud3JpdGVyKG1ldGhvZE5hbWUpLCBbbmFtZSwgYXR0cmlidXRlc10pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYW4gZXZhbHVhdG9yIHRvIHdyaXRlIGFuIGh0bWwgY2xvc2luZyB0YWdcbiAgZnVuY3Rpb24gY3JlYXRlQ2xvc2VUYWdFdmFsdWF0b3IobmFtZU5vZGUpIHtcbiAgICBnZW4uc3RhdGVtZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgIGdlbi5jYWxsKGdlbi53cml0ZXIoJ2VuZEVsZW1lbnQnKSwgW2RlZmVyKG5hbWVOb2RlKV0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYW4gZXZhbHVhdG9yIHRvIHdyaXRlIGFuIGh0bWwgY29tbWVudFxuICBmdW5jdGlvbiBjcmVhdGVDb21tZW50VGFnRXZhbHVhdG9yKGNvbnRlbnRMaXRlcmFsKSB7XG4gICAgZ2VuLnN0YXRlbWVudChmdW5jdGlvbiAoKSB7XG4gICAgICBnZW4uY2FsbChnZW4ud3JpdGVyKCdjb21tZW50JyksIFtkZWZlcihjb250ZW50TGl0ZXJhbCldKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGFuIGV2YWx1YXRvciB0byB3cml0ZSBhbiBodG1sNSBkb2N0eXBlXG4gIGZ1bmN0aW9uIGNyZWF0ZURvY1R5cGVFdmFsdWF0b3Iocm9vdEVsZW1MaXRlcmFsKSB7XG4gICAgZ2VuLnN0YXRlbWVudChmdW5jdGlvbiAoKSB7XG4gICAgICBnZW4uY2FsbChnZW4ud3JpdGVyKCdkb2NUeXBlJyksIFtkZWZlcihyb290RWxlbUxpdGVyYWwpXSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBhbiBldmFsdWF0b3IgdGhhdCB3cml0ZXMgdGhlIHJlc3VsdCBvZiBhbiBleHByZXNzaW9uXG4gIGZ1bmN0aW9uIGNyZWF0ZU91dHB1dEV2YWx1YXRvcihleHByTm9kZSkge1xuICAgIGdlbi5zdGF0ZW1lbnQoZnVuY3Rpb24gKCkge1xuICAgICAgZ2VuLmNhbGwoZ2VuLndyaXRlcignY29udGVudCcpLCBbZGVmZXIoZXhwck5vZGUpXSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBhbiBldmFsdWF0b3IgdGhhdCB3cml0ZXMgdGhlIHJlc3VsdCBvZiBhblxuICAvLyBleHByZXNzaW9uIHdpdGhvdXQgZXNjYXBpbmdcbiAgZnVuY3Rpb24gY3JlYXRlUmF3T3V0cHV0RXZhbHVhdG9yKGV4cHJOb2RlKSB7XG4gICAgZ2VuLnN0YXRlbWVudChmdW5jdGlvbiAoKSB7XG4gICAgICBnZW4uY2FsbChnZW4ud3JpdGVyKCdyYXcnKSwgW2RlZmVyKGV4cHJOb2RlKV0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYW4gZXZhbHVhdG9yIHRoYXQgcGVyZm9ybXMgbGlzdCBjb21wcmVoZW5zaW9uc1xuICBmdW5jdGlvbiBjcmVhdGVMaXN0Q29tcEV2YWx1YXRvcihyYW5nZU5vZGVzLCB2YWx1ZU5vZGUsIG5hbWVOb2RlKSB7XG4gICAgdmFyIGFubm90YXRpb25zID0gY3JlYXRlTGlzdENvbXBFdmFsdWF0b3IuZ2V0QW5ub3RhdGlvbnMoYXJndW1lbnRzKTtcbiAgICB2YXIgaXNEaWN0aW9uYXJ5ID0gISFuYW1lTm9kZTtcbiAgICB2YXIgZ2VuQ29udGFpbmVyID0gaXNEaWN0aW9uYXJ5ID8gZ2VuLmRpY3Rpb25hcnkgOiBnZW4udmVjdG9yO1xuICAgIHZhciBjcmVhdGVCb2R5ID0gaXNEaWN0aW9uYXJ5ID8gY3JlYXRlTmFtZVZhbHVlQm9keTogY3JlYXRlVmFsdWVCb2R5O1xuICAgIHZhciBsaXN0VmFyO1xuXG4gICAgZ2VuLmNvbXBvdW5kRXhwcmVzc2lvbihmdW5jdGlvbiAoKSB7XG4gICAgICBsaXN0VmFyID0gZ2VuLmFub255bW91cygpO1xuICAgICAgZ2VuLmFzc2lnbm1lbnRzKFtcbiAgICAgICAgW2xpc3RWYXIsIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBnZW5Db250YWluZXIoW10pO1xuICAgICAgICB9KV1cbiAgICAgIF0pO1xuICAgICAgY3JlYXRlTG9vcEV2YWx1YXRvcihyYW5nZU5vZGVzLCBjcmVhdGVCb2R5KTtcbiAgICAgIGdlbi5yZXR1cm5TdGF0ZW1lbnQobGlzdFZhcik7XG4gICAgfSwgYW5ub3RhdGlvbnMpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVmFsdWVCb2R5KCkge1xuICAgICAgZ2VuLnZlY3RvckFwcGVuZChsaXN0VmFyLCBkZWZlcih2YWx1ZU5vZGUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVOYW1lVmFsdWVCb2R5KCkge1xuICAgICAgZ2VuLmRpY3Rpb25hcnlTZXQobGlzdFZhciwgZGVmZXIobmFtZU5vZGUpLCBkZWZlcih2YWx1ZU5vZGUpKTtcbiAgICB9XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBhbiBldmFsdWF0b3IgdGhhdCBwZXJmb3JtcyBmb3IgbG9vcGluZyBvdmVyIHJhbmdlc1xuICBmdW5jdGlvbiBjcmVhdGVGb3JFdmFsdWF0b3IocmFuZ2VOb2Rlcywgc3RhdGVtZW50Tm9kZXMsIGVsc2VOb2Rlcykge1xuICAgIHZhciBhbm5vdGF0aW9ucyA9IGNyZWF0ZUZvckV2YWx1YXRvci5nZXRBbm5vdGF0aW9ucyhhcmd1bWVudHMpO1xuICAgIHZhciBjcmVhdGVTdWIgPSBoYXNBbm5vdGF0aW9uKGFubm90YXRpb25zLCAnc2VsZicsICdyZWFkJyk7XG4gICAgdmFyIHN1Y2Nlc3NWYXI7XG5cbiAgICBpZiAoIGVsc2VOb2RlcyAmJiBlbHNlTm9kZXMubGVuZ3RoICkge1xuICAgICAgc3VjY2Vzc1ZhciA9IGdlbi5hbm9ueW1vdXMoKTtcbiAgICAgIGdlbi5hc3NpZ25tZW50cyhbXG4gICAgICAgIFtzdWNjZXNzVmFyLCBnbG9iYWxzLmxpdGVyYWwoZmFsc2UpXVxuICAgICAgXSk7XG4gICAgICBjcmVhdGVMb29wRXZhbHVhdG9yKHJhbmdlTm9kZXMsIGNyZWF0ZUJvZHksIGNyZWF0ZVN1Yiwgc3VjY2Vzc1Zhcik7XG4gICAgICBnZW4uaWZTdGF0ZW1lbnQoXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgZ2VuLmFub255bW91cyhzdWNjZXNzVmFyKTsgfSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZGVmZXIoY3JlYXRlU3RhdGVtZW50c0V2YWx1YXRvciwgZWxzZU5vZGVzKVxuICAgICAgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjcmVhdGVMb29wRXZhbHVhdG9yKHJhbmdlTm9kZXMsIGNyZWF0ZUJvZHksIGNyZWF0ZVN1Yik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQm9keSgpIHtcbiAgICAgIGNyZWF0ZVN0YXRlbWVudHNFdmFsdWF0b3Ioc3RhdGVtZW50Tm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvb3BFdmFsdWF0b3IocmFuZ2VOb2RlcywgY3JlYXRlQm9keSwgY3JlYXRlU3ViLCBzdWNjZXNzVmFyKSB7XG4gICAgaWYgKCAhY3JlYXRlU3ViICkge1xuICAgICAgcHJvY2Vzc1JhbmdlKDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdlbi5zdGF0ZW1lbnQoZnVuY3Rpb24gKCkge1xuICAgICAgZ2VuLnN1YmNvbnRleHQoXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwcm9jZXNzUmFuZ2UoMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFubm90YXRpb25zXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JhbmdlKGkpIHtcbiAgICAgIGlmICggaSA9PT0gcmFuZ2VOb2Rlcy5sZW5ndGggKSB7XG4gICAgICAgIGlmICggc3VjY2Vzc1ZhciApIHtcbiAgICAgICAgICBnZW4uYW5vbnltb3VzKHN1Y2Nlc3NWYXIsIGdsb2JhbHMubGl0ZXJhbCh0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlQm9keSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZU5vZGUgPSByYW5nZU5vZGVzW2ldO1xuICAgICAgdmFyIGl0ZW1OYW1lID0gbGl0ZXJhbHNbcmFuZ2VOb2RlWzBdXTtcbiAgICAgIHZhciBwcm9sb2c7XG5cbiAgICAgIGlmICggcmFuZ2VOb2RlWzJdICkge1xuICAgICAgICAvLyBXZSBoYXZlIGEgZ3VhcmRcbiAgICAgICAgcHJvbG9nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGdlbi5pZlN0YXRlbWVudChcbiAgICAgICAgICAgIGRlZmVyKHJhbmdlTm9kZVsyXSksXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBnZW4ucmV0dXJuU3RhdGVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZ2VuLmxvb3BTdGF0ZW1lbnQoXG4gICAgICAgIGl0ZW1OYW1lLFxuICAgICAgICBkZWZlcihyYW5nZU5vZGVbMV0pLFxuICAgICAgICBwcm9sb2csXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwcm9jZXNzUmFuZ2UoaSArIDEpO1xuICAgICAgICB9LFxuICAgICAgICBhbm5vdGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBhIGNvbmRpdGlvbmFsICh0ZXJuYXJ5KSBldmFsdWF0b3JcbiAgZnVuY3Rpb24gY3JlYXRlVGVybmFyeUV2YWx1YXRvcihjb25kaXRpb25Ob2RlLCB0cnVlTm9kZSwgZmFsc2VOb2RlKSB7XG4gICAgZ2VuLmNvbmRpdGlvbmFsT3BlcmF0b3IoXG4gICAgICBkZWZlcihjb25kaXRpb25Ob2RlKSxcbiAgICAgIGRlZmVyKHRydWVOb2RlKSxcbiAgICAgIGRlZmVyKGZhbHNlTm9kZSlcbiAgICApO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYW4gaWYgc3RhdGVtZW50IGV2YWx1YXRvclxuICBmdW5jdGlvbiBjcmVhdGVJZkV2YWx1YXRvcihjb25kaXRpb25Ob2RlLCB0cnVlTm9kZXMsIGZhbHNlTm9kZXMpIHtcbiAgICBnZW4uaWZTdGF0ZW1lbnQoXG4gICAgICBkZWZlcihjb25kaXRpb25Ob2RlKSxcbiAgICAgIHRydWVOb2Rlcy5sZW5ndGggPyBkZWZlcihjcmVhdGVTdGF0ZW1lbnRzRXZhbHVhdG9yLCB0cnVlTm9kZXMpIDogbnVsbCxcbiAgICAgIGZhbHNlTm9kZXMubGVuZ3RoID8gZGVmZXIoY3JlYXRlU3RhdGVtZW50c0V2YWx1YXRvciwgZmFsc2VOb2RlcykgOiBudWxsXG4gICAgKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGFuICdvcicgZXZhbHVhdG9yXG4gIGZ1bmN0aW9uIGNyZWF0ZU9yRXZhbHVhdG9yKGxlZnROb2RlLCByaWdodE5vZGUpIHtcbiAgICBjcmVhdGVUZXJuYXJ5RXZhbHVhdG9yKGxlZnROb2RlLCBsZWZ0Tm9kZSwgcmlnaHROb2RlKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGFuICdhbmQnIGV2YWx1YXRvclxuICBmdW5jdGlvbiBjcmVhdGVBbmRFdmFsdWF0b3IobGVmdE5vZGUsIHJpZ2h0Tm9kZSkge1xuICAgIGNyZWF0ZVRlcm5hcnlFdmFsdWF0b3IobGVmdE5vZGUsIHJpZ2h0Tm9kZSwgbGVmdE5vZGUpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYSBtYXRjaCBldmFsdWF0b3JcbiAgZnVuY3Rpb24gY3JlYXRlTWF0Y2hFdmFsdWF0b3IobGVmdE5vZGUsIHJpZ2h0Tm9kZSkge1xuICAgIHZhciBsZWZ0ID0gZGVmZXIobGVmdE5vZGUpO1xuICAgIHZhciByaWdodCA9IGRlZmVyKHJpZ2h0Tm9kZSk7XG4gICAgaWYgKCAhaXNBcnJheShyaWdodE5vZGUpICkge1xuICAgICAgdmFyIG1hdGNoZXIgPSBnbG9iYWxzLmJ1aWxkZXIoJ21hdGNoZXInLCBnZW4uY29kZShyaWdodCkpO1xuICAgICAgZ2VuLmNhbGwobWF0Y2hlciwgW2xlZnRdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXNNYXRjaGluZ09iamVjdCA9IGdsb2JhbHMucnVudGltZUltcG9ydCgnbWF0Y2hlcycpO1xuICAgIGdlbi5jYWxsKGlzTWF0Y2hpbmdPYmplY3QsIFtyaWdodCwgbGVmdF0pO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYW4gZXF1YWxpdHkgZXZhbHVhdG9yXG4gIGZ1bmN0aW9uIGNyZWF0ZUVxRXZhbHVhdG9yKGxlZnROb2RlLCByaWdodE5vZGUpIHtcbiAgICBjcmVhdGVCaW5hcnlFdmFsdWF0b3IoJ2VxJywgbGVmdE5vZGUsIHJpZ2h0Tm9kZSk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBhbiBpbmVxdWFsaXR5IGV2YWx1YXRvclxuICBmdW5jdGlvbiBjcmVhdGVOZXFFdmFsdWF0b3IobGVmdE5vZGUsIHJpZ2h0Tm9kZSkge1xuICAgIGNyZWF0ZUJpbmFyeUV2YWx1YXRvcignbmVxJywgbGVmdE5vZGUsIHJpZ2h0Tm9kZSk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBhIGdyZWF0ZXItdGhhbiBldmFsdWF0b3JcbiAgZnVuY3Rpb24gY3JlYXRlR3RFdmFsdWF0b3IobGVmdE5vZGUsIHJpZ2h0Tm9kZSkge1xuICAgIGNyZWF0ZUJpbmFyeUV2YWx1YXRvcignZ3QnLCBsZWZ0Tm9kZSwgcmlnaHROb2RlKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGEgZ3JlYXRlci10aGFuIG9yIGVxdWFsIHRvIGV2YWx1YXRvclxuICBmdW5jdGlvbiBjcmVhdGVHdGVFdmFsdWF0b3IobGVmdE5vZGUsIHJpZ2h0Tm9kZSkge1xuICAgIGNyZWF0ZUJpbmFyeUV2YWx1YXRvcignZ2UnLCBsZWZ0Tm9kZSwgcmlnaHROb2RlKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGEgbGVzcy10aGFuIGV2YWx1YXRvclxuICBmdW5jdGlvbiBjcmVhdGVMdEV2YWx1YXRvcihsZWZ0Tm9kZSwgcmlnaHROb2RlKSB7XG4gICAgY3JlYXRlQmluYXJ5RXZhbHVhdG9yKCdsdCcsIGxlZnROb2RlLCByaWdodE5vZGUpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYSBsZXNzLXRoYW4gb3IgZXF1YWwgdG8gZXZhbHVhdG9yXG4gIGZ1bmN0aW9uIGNyZWF0ZUx0ZUV2YWx1YXRvcihsZWZ0Tm9kZSwgcmlnaHROb2RlKSB7XG4gICAgY3JlYXRlQmluYXJ5RXZhbHVhdG9yKCdsZScsIGxlZnROb2RlLCByaWdodE5vZGUpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYW4gYWRkaXRpb24gZXZhbHVhdG9yXG4gIGZ1bmN0aW9uIGNyZWF0ZUFkZEV2YWx1YXRvcihsZWZ0Tm9kZSwgcmlnaHROb2RlKSB7XG4gICAgY3JlYXRlQmluYXJ5RXZhbHVhdG9yKCdhZGQnLCBsZWZ0Tm9kZSwgcmlnaHROb2RlKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGEgc3VidHJhY3Rpb24gZXZhbHVhdG9yXG4gIGZ1bmN0aW9uIGNyZWF0ZVN1YkV2YWx1YXRvcihsZWZ0Tm9kZSwgcmlnaHROb2RlKSB7XG4gICAgY3JlYXRlQmluYXJ5RXZhbHVhdG9yKCdzdWInLCBsZWZ0Tm9kZSwgcmlnaHROb2RlKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGEgbXVsdGlwbGljYXRpb24gZXZhbHVhdG9yXG4gIGZ1bmN0aW9uIGNyZWF0ZU11bEV2YWx1YXRvcihsZWZ0Tm9kZSwgcmlnaHROb2RlKSB7XG4gICAgY3JlYXRlQmluYXJ5RXZhbHVhdG9yKCdtdWwnLCBsZWZ0Tm9kZSwgcmlnaHROb2RlKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGEgZGl2aXNpb24gZXZhbHVhdG9yXG4gIGZ1bmN0aW9uIGNyZWF0ZURpdkV2YWx1YXRvcihsZWZ0Tm9kZSwgcmlnaHROb2RlKSB7XG4gICAgY3JlYXRlQmluYXJ5RXZhbHVhdG9yKCdkaXYnLCBsZWZ0Tm9kZSwgcmlnaHROb2RlKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGEgcmVtYWluZGVyIGV2YWx1YXRvclxuICBmdW5jdGlvbiBjcmVhdGVNb2RFdmFsdWF0b3IobGVmdE5vZGUsIHJpZ2h0Tm9kZSkge1xuICAgIGNyZWF0ZUJpbmFyeUV2YWx1YXRvcignbW9kJywgbGVmdE5vZGUsIHJpZ2h0Tm9kZSk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBhbiBpbnRlcnBvbGF0aW9uIGV2YWx1YXRvclxuICBmdW5jdGlvbiBjcmVhdGVGb3JtYXRFdmFsdWF0b3IoZm9ybWF0TGl0LCBzdXBwb3J0RGljdE5vZGUsIGV4cHJOb2RlKSB7XG4gICAgdmFyIGZvcm1hdFN0ciA9IGdlbi5jb2RlKGRlZmVyKGZvcm1hdExpdCkpO1xuICAgIHZhciBzdXBwb3J0RGljdCA9IGdlbi5jb2RlKGRlZmVyKHN1cHBvcnREaWN0Tm9kZSkpO1xuXG4gICAgdmFyIGRlZmVycmVkID0gIWV4cHJOb2RlO1xuICAgIHZhciBmdW5jTmFtZSA9IGRlZmVycmVkID8gJ2RlZmVycmVkRm9ybWF0dGVyJyA6ICdpbW1lZGlhdGVGb3JtYXR0ZXInO1xuICAgIHZhciBmb3JtYXR0ZXI7XG4gICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgIGlmICggIWlzQXJyYXkoc3VwcG9ydERpY3ROb2RlKSApIHtcbiAgICAgIC8vIE1lYW5pbmcgaXQgaGFzIGJlZW4gY3JlYXRlZCBnbG9iYWxseVxuICAgICAgZm9ybWF0dGVyID0gZ2xvYmFscy5idWlsZGVyKGZ1bmNOYW1lLCBmb3JtYXRTdHIsIHN1cHBvcnREaWN0KTtcbiAgICAgIGlmICggZGVmZXJyZWQgKSB7XG4gICAgICAgIGdlbi53cml0ZShmb3JtYXR0ZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gTWVhbmluZyB3ZSBoYXZlIHRvIGZlZWQgaXQgc3VwcG9ydEZ1bmN0aW9ucyBhdCBpbnN0YW50aWF0aW9uXG4gICAgICBmb3JtYXR0ZXIgPSBnbG9iYWxzLmJ1aWxkZXIoZnVuY05hbWUsIGZvcm1hdFN0cik7XG4gICAgICBhcmdzLnB1c2goc3VwcG9ydERpY3QpO1xuICAgICAgaWYgKCBkZWZlcnJlZCApIHtcbiAgICAgICAgZ2VuLmNhbGwoZm9ybWF0dGVyLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFyZ3MucHVzaChkZWZlcihleHByTm9kZSkpO1xuICAgIGdlbi5jYWxsKGZvcm1hdHRlciwgYXJncyk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBhIGxvZ2ljYWwgJ25vdCcgZXZhbHVhdG9yXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vdEV2YWx1YXRvcihub2RlKSB7XG4gICAgdmFyIGlzVHJ1dGh5ID0gZ2xvYmFscy5ydW50aW1lSW1wb3J0KCdpc1RydXRoeScpO1xuICAgIGdlbi51bmFyeU9wZXJhdG9yKCdub3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBnZW4uY2FsbChpc1RydXRoeSwgW2RlZmVyKG5vZGUpXSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBhIG1hdGhlbWF0aWNhbCBuZWdhdGlvbiBldmFsdWF0b3JcbiAgZnVuY3Rpb24gY3JlYXRlTmVnRXZhbHVhdG9yKG5vZGUpIHtcbiAgICBnZW4udW5hcnlPcGVyYXRvcignbmVnJywgZGVmZXIobm9kZSkpO1xuICB9XG4gIFxuICAvLyBnZW5lcmF0ZSBhIG1hdGhlbWF0aWNhbCBwb3NpdGl2ZSBldmFsdWF0b3JcbiAgZnVuY3Rpb24gY3JlYXRlUG9zRXZhbHVhdG9yKG5vZGUpIHtcbiAgICBnZW4udW5hcnlPcGVyYXRvcigncG9zJywgZGVmZXIobm9kZSkpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYW4gYXJyYXkgb3Igb2JqZWN0IG1lbWJlciBhY2Nlc3MgZXZhbHVhdG9yXG4gIGZ1bmN0aW9uIGNyZWF0ZU1lbWJlckV2YWx1YXRvcihwYXJlbnROb2RlLCBlbGVtTm9kZXMpIHtcbiAgICB2YXIgZ2V0TWVtYmVyID0gZWxlbU5vZGVzLmxlbmd0aCA9PT0gMSA/ICdnZXRQcm9wZXJ0eScgOiAnZ2V0UGF0aCc7XG4gICAgdmFyIGFyZ3MgPSBbZGVmZXIocGFyZW50Tm9kZSldLmNvbmNhdChtYXAoZWxlbU5vZGVzLCBkZWZlcikpO1xuICAgIGdlbi5jYWxsKGdsb2JhbHMucnVudGltZUltcG9ydChnZXRNZW1iZXIpLCBhcmdzKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGFuIGFycmF5IGV2YWx1YXRvclxuICBmdW5jdGlvbiBjcmVhdGVBcnJheUV2YWx1YXRvcihhcnJheU5vZGVzKSB7XG4gICAgZ2VuLnZlY3RvcihtYXAoYXJyYXlOb2RlcywgZGVmZXIpKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGEgZGljdGlvbmFyeSBldmFsdWF0b3JcbiAgZnVuY3Rpb24gY3JlYXRlRGljdGlvbmFyeUV2YWx1YXRvcihwcm9wZXJ0eURlZnMsIG9yZGVyZWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWFwKHByb3BlcnR5RGVmcywgZnVuY3Rpb24gKHByb3BlcnR5RGVmKSB7XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIGlmICggaXNBcnJheShwcm9wZXJ0eURlZlswXSkgKSB7XG4gICAgICAgIG5hbWUgPSBkZWZlcihwcm9wZXJ0eURlZlswXSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmFtZSA9IGxpdGVyYWxzW3Byb3BlcnR5RGVmWzBdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbmFtZSwgZGVmZXIocHJvcGVydHlEZWZbMV0pXTtcbiAgICB9KTtcbiAgICBnZW4uZGljdGlvbmFyeShyZXN1bHQsIG9yZGVyZWQpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgYSBsb2NhbCB2YXJpYWJsZSByZXRyaWV2YWwgZXZhbHVhdG9yXG4gIGZ1bmN0aW9uIGNyZWF0ZUlkRXZhbHVhdG9yKG5hbWVMaXRlcmFsKSB7XG4gICAgZ2VuLmdldHRlcihsaXRlcmFsc1tuYW1lTGl0ZXJhbF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2VsZkV2YWx1YXRvcigpIHtcbiAgICBnZW4uc2VsZigpO1xuICB9XG59XG5cbi8vIEV4cG9ydGVkIEZ1bmN0aW9uc1xuZXhwb3J0cy5nZW5lcmF0ZU1vZHVsZUJvZHkgPSBnZW5lcmF0ZU1vZHVsZUJvZHk7XG4iLCIvKlxuICogSW50ZXJwb2wgKExvZ2ljZnVsIEhUTUwgVGVtcGxhdGVzKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBzZWUgZG9jL0xJQ0VOU0UubWRcbiAqXG4gKiBAYXV0aG9yIFRob21hcyBTLiBCcmFkZm9yZCAoa29kZTRmb29kLml0KVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdm0gPSByZXF1aXJlKCd2bScpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciB0eXBlcyA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcbnZhciByZXdyaXRlciA9IHJlcXVpcmUoJy4vcmV3cml0ZXInKTtcbnZhciBjb2RlZ2VuID0gcmVxdWlyZSgnLi9jb2RlZ2VuJyk7XG52YXIgY29tcGlsZXJTdHViID0gcmVxdWlyZSgnLi9zdHViJyk7XG5cbnZhciBwYXJzZVRlbXBsYXRlID0gcGFyc2VyLnBhcnNlVGVtcGxhdGU7XG52YXIgcmV3cml0ZVN5bnRheFRyZWUgPSByZXdyaXRlci5yZXdyaXRlU3ludGF4VHJlZTtcbnZhciBnZW5lcmF0ZU1vZHVsZUJvZHkgPSBjb2RlZ2VuLmdlbmVyYXRlTW9kdWxlQm9keTtcblxudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG52YXIgbWl4aW4gPSB1dGlsLm1peGluO1xudmFyIHNlbGZNYXAgPSB1dGlsLnNlbGZNYXA7XG5cbnZhciBpc1N5bWJvbCA9IHBhcnNlci5pc1N5bWJvbDtcblxuZnVuY3Rpb24gY29tcGlsZU1vZHVsZSh0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICB2YXIgd2FybmluZ3MgPSBbXTtcbiAgdmFyIGxpdGVyYWxzID0gW107XG4gIHZhciByZXZlcnNlTGl0ZXJhbHMgPSB7fTtcblxuICB2YXIgcGFyc2VkID0gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIHZhciByZXdyaXR0ZW4gPSByZXdyaXRlU3ludGF4VHJlZShwYXJzZWQsIHdhcm5pbmdzKTtcbiAgdmFyIHN0cmlwcGVkID0gcmVwbGFjZVN5bWJvbHMocmV3cml0dGVuKTtcblxuICByZXR1cm4ge1xuICAgIHRlbXBsYXRlQm9keTogZ2VuZXJhdGVNb2R1bGVCb2R5KHN0cmlwcGVkLCBsaXRlcmFscywgb3B0aW9ucyksXG4gICAgZXJyOiB3YXJuaW5nc1xuICB9O1xuXG4gIC8vIGNvbnZlcnQgYWxsIHN5bWJvbCBwbGFjZWhvbGRlcnMgaW50byBsaXRlcmFsIHRhYmxlIGVudHJpZXNcbiAgZnVuY3Rpb24gcmVwbGFjZVN5bWJvbHMobm9kZSkge1xuICAgIGlmICggIWlzQXJyYXkobm9kZSkgKSB7XG4gICAgICBpZiAoIGlzU3ltYm9sKG5vZGUpICkge1xuICAgICAgICByZXR1cm4gbGl0KG5vZGUudmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgc2VsZk1hcChub2RlLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHJlcGxhY2VTeW1ib2xzKGl0ZW0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBsaXQodmFsdWUpIHtcbiAgICB2YXIgY2Fub25pY2FsID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHZhciBpZHggPSByZXZlcnNlTGl0ZXJhbHNbY2Fub25pY2FsXTtcbiAgICBpZiAoIHR5cGVvZiBpZHggPT09ICdudW1iZXInICkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gICAgaWR4ID0gbGl0ZXJhbHMucHVzaCh2YWx1ZSkgLSAxO1xuICAgIHJldmVyc2VMaXRlcmFsc1tjYW5vbmljYWxdID0gaWR4O1xuICAgIHJldHVybiBpZHg7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOb2RlTW9kdWxlKGdlbmVyYXRlZENvZGUpIHtcbiAgdmFyIGJ1ZmZlciA9IFtdO1xuICBidWZmZXIucHVzaChcIlxcXCJ1c2Ugc3RyaWN0XFxcIjtcIik7XG4gIGJ1ZmZlci5wdXNoKFwibW9kdWxlLmV4cG9ydHM9e1wiKTtcbiAgYnVmZmVyLnB1c2goXCJfX2ludE5vZGVNb2R1bGU6IHRydWUsXCIpO1xuICBidWZmZXIucHVzaChcImNyZWF0ZVRlbXBsYXRlOmZ1bmN0aW9uKHIpe1wiKTtcbiAgYnVmZmVyLnB1c2goZ2VuZXJhdGVkQ29kZSk7XG4gIGJ1ZmZlci5wdXNoKFwifX07XCIpO1xuICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xufVxuXG52YXIgZ2VuZXJhdGVGdW5jdGlvbjtcbmlmICggdHlwZW9mIHZtICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygdm0uY3JlYXRlQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgLy8gVGhlIHNhZmVyIHNhbmRib3hlZCBtZXRob2RcbiAgZ2VuZXJhdGVGdW5jdGlvbiA9IGZ1bmN0aW9uIF9zYW5kYm94ZWQoc2NyaXB0Q29kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm0uY3JlYXRlQ29udGV4dCh7XG4gICAgICBtb2R1bGU6IHsgZXhwb3J0czoge30gfVxuICAgIH0pO1xuICAgIHZtLnJ1bkluQ29udGV4dChnZW5lcmF0ZU5vZGVNb2R1bGUoc2NyaXB0Q29kZSksIGNvbnRleHQpO1xuICAgIHJldHVybiBjb250ZXh0Lm1vZHVsZS5leHBvcnRzLmNyZWF0ZVRlbXBsYXRlO1xuICB9O1xufVxuZWxzZSB7XG4gIC8vIFRoZSBzaGl0dHkgYnJvd3Nlci1iYXNlZCBhcHByb2FjaFxuICBnZW5lcmF0ZUZ1bmN0aW9uID0gZnVuY3Rpb24gX2Z1bmNDb25zdHJ1Y3RlZChzY3JpcHRDb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihbJ3InXSwgc2NyaXB0Q29kZSk7XG4gIH07XG59XG5cbi8vIEV4cG9ydGVkIEZ1bmN0aW9uc1xuZXhwb3J0cy5jb21waWxlTW9kdWxlID0gY29tcGlsZU1vZHVsZTtcbmV4cG9ydHMuZ2VuZXJhdGVOb2RlTW9kdWxlID0gZ2VuZXJhdGVOb2RlTW9kdWxlO1xuZXhwb3J0cy5nZW5lcmF0ZUZ1bmN0aW9uID0gZ2VuZXJhdGVGdW5jdGlvbjtcblxubWl4aW4oY29tcGlsZXJTdHViLCBleHBvcnRzKTtcbiIsIi8qXG4gKiBJbnRlcnBvbCAoTG9naWNmdWwgSFRNTCBUZW1wbGF0ZXMpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIHNlZSBkb2MvTElDRU5TRS5tZFxuICpcbiAqIEBhdXRob3IgVGhvbWFzIFMuIEJyYWRmb3JkIChrb2RlNGZvb2QuaXQpXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHR5cGVzID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbnZhciBhbm5vdGF0aW9ucyA9IHJlcXVpcmUoJy4vYW5ub3RhdGlvbnMnKTtcblxudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG52YXIgZXh0ZW5kT2JqZWN0ID0gdXRpbC5leHRlbmRPYmplY3Q7XG52YXIgbWl4aW4gPSB1dGlsLm1peGluO1xudmFyIG9iamVjdEtleXMgPSB1dGlsLm9iamVjdEtleXM7XG52YXIgZWFjaCA9IHV0aWwuZWFjaDtcbnZhciBtYXAgPSB1dGlsLm1hcDtcbnZhciBmaWx0ZXIgPSB1dGlsLmZpbHRlcjtcbnZhciBhbm5vdGF0ZSA9IGFubm90YXRpb25zLmFubm90YXRlO1xudmFyIGhhc0Fubm90YXRpb24gPSBhbm5vdGF0aW9ucy5oYXNBbm5vdGF0aW9uO1xuXG52YXIganNvblN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vLyBwcmVzZW50ZWQgb3BlcmF0b3JzIGFyZSBzeW1ib2xpY1xudmFyIG9wZXJhdG9yTWFwID0ge1xuICAnZXEnOiAgJz09PScsXG4gICduZXEnOiAnIT09JyxcbiAgJ2d0JzogICc+JyxcbiAgJ2x0JzogICc8JyxcbiAgJ2dlJzogICc+PScsXG4gICdsZSc6ICAnPD0nLFxuICAnYWRkJzogJysnLFxuICAnc3ViJzogJy0nLFxuICAnbXVsJzogJyonLFxuICAnZGl2JzogJy8nLFxuICAnbW9kJzogJyUnLFxuICAnbm90JzogJyEnLFxuICAnbmVnJzogJy0nLFxuICAncG9zJzogJysnXG59O1xuXG4vLyBnbG9iYWxzIGNhbiBlaXRoZXIgYmUgZ2VuZXJhdGVkIHBlciB0ZW1wbGF0ZSBmdW5jdGlvbiBvciBjYW4gYmUgc2hhcmVkXG4vLyBhbW9uZ3N0IHNldmVyYWwgdGVtcGxhdGUgZnVuY3Rpb25zIChmb3IgYnVuZGxlcylcbmZ1bmN0aW9uIGNyZWF0ZUdsb2JhbHMoKSB7XG4gIHZhciBnbG9iYWxzID0ge307ICAgICAgICAgICAgLy8gcHJlZml4IC0+IG5leHRJZFxuICB2YXIgZ2VuZXJhdGVkTGl0ZXJhbHMgPSB7fTsgIC8vIGxpdGVyYWwgLT4gZ2xvYmFsSWRcbiAgdmFyIGdlbmVyYXRlZEltcG9ydHMgPSB7fTsgICAvLyBmdW5jTmFtZSAtPiBnbG9iYWxJZFxuICB2YXIgZ2VuZXJhdGVkQnVpbGRlcnMgPSB7fTsgIC8vIGZ1bmNOYW1lSWQsbGl0ZXJhbElkIC0+IGdsb2JhbElkXG4gIHZhciBnbG9iYWxWYXJzID0gW107XG5cbiAgcmV0dXJuIHtcbiAgICBuZXh0SWQ6IG5leHRJZCxcbiAgICBsaXRlcmFsOiBsaXRlcmFsLFxuICAgIHJ1bnRpbWVJbXBvcnQ6IHJ1bnRpbWVJbXBvcnQsXG4gICAgYnVpbGRlcjogYnVpbGRlcixcbiAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgfTtcblxuICBmdW5jdGlvbiBuZXh0SWQocHJlZml4KSB7XG4gICAgdmFyIG5leHQgPSBnbG9iYWxzW3ByZWZpeF07XG4gICAgaWYgKCB0eXBlb2YgbmV4dCAhPT0gJ251bWJlcicgKSB7XG4gICAgICBuZXh0ID0gMDsgIC8vIHNlZWQgaXRcbiAgICB9XG4gICAgdmFyIGlkID0gcHJlZml4ICsgbmV4dDtcbiAgICBnbG9iYWxzW3ByZWZpeF0gPSBuZXh0ICsgMTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICBmdW5jdGlvbiBsaXRlcmFsKGxpdGVyYWxWYWx1ZSkge1xuICAgIHZhciBjYW5vbmljYWwgPSBqc29uU3RyaW5naWZ5KGxpdGVyYWxWYWx1ZSk7XG4gICAgdmFyIGlkID0gZ2VuZXJhdGVkTGl0ZXJhbHNbY2Fub25pY2FsXTtcbiAgICBpZiAoIGlkICkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBpZCA9IGdlbmVyYXRlZExpdGVyYWxzW2Nhbm9uaWNhbF0gPSBuZXh0SWQoJ2wnKTtcblxuICAgIGdsb2JhbFZhcnMucHVzaChpZCArIFwiPVwiICsgY2Fub25pY2FsKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICBmdW5jdGlvbiBydW50aW1lSW1wb3J0KGZ1bmNOYW1lKSB7XG4gICAgdmFyIGlkID0gZ2VuZXJhdGVkSW1wb3J0c1tmdW5jTmFtZV07XG4gICAgaWYgKCBpZCApIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgaWQgPSBnZW5lcmF0ZWRJbXBvcnRzW2Z1bmNOYW1lXSA9IG5leHRJZCgnaScpO1xuICAgIGdsb2JhbFZhcnMucHVzaChbaWQsIFwiPXIuXCIsIGZ1bmNOYW1lXS5qb2luKCcnKSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRlcihmdW5jTmFtZSkge1xuICAgIHZhciBmdW5jSWQgPSBydW50aW1lSW1wb3J0KGZ1bmNOYW1lKTtcbiAgICB2YXIgbGl0ZXJhbElkcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBrZXkgPSBmdW5jSWQgKyBcIi9cIiArIGxpdGVyYWxJZHMuam9pbignLycpO1xuICAgIHZhciBpZCA9IGdlbmVyYXRlZEJ1aWxkZXJzW2tleV07XG4gICAgaWYgKCBpZCApIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgaWQgPSBnZW5lcmF0ZWRCdWlsZGVyc1trZXldID0gbmV4dElkKCdiJyk7XG4gICAgZ2xvYmFsVmFycy5wdXNoKGlkICsgXCI9XCIgKyBmdW5jSWQgKyBcIihcIiArIGxpdGVyYWxJZHMuam9pbignLCcpICsgXCIpXCIpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIGlmICggZ2xvYmFsVmFycy5sZW5ndGggKSB7XG4gICAgICByZXR1cm4gJ3ZhciAnICsgZ2xvYmFsVmFycy5qb2luKCcsJykgKyAnOyc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVNb2R1bGUoZ2xvYmFscykge1xuICBpZiAoIGdsb2JhbHMgPT09IHVuZGVmaW5lZCApIHtcbiAgICBnbG9iYWxzID0gY3JlYXRlR2xvYmFscygpO1xuICB9XG5cbiAgLy8gS2VlcHMgdHJhY2sgb2YgbmFtZSAtPiBsb2NhbCBtYXBwaW5ncyB0aHJvdWdob3V0IHRoZSBuZXN0aW5nXG4gIHZhciBsb2NhbHMgPSB7fTsgICAgICAgLy8gcHJlZml4IC0+IG5leHRJZFxuICB2YXIgbmFtZXMgPSB7fTsgICAgICAgIC8vIG5hbWUgLT4gbG9jYWxJZFxuICB2YXIgc2NvcGVJbmZvID0gY3JlYXRlU2NvcGVJbmZvKCk7XG4gIHZhciBuYW1lU3RhY2sgPSBbXTtcbiAgdmFyIHNlbGZOYW1lID0gJ2MnO1xuXG4gIHZhciB3cml0ZXJTdGFjayA9IFtdO1xuICB2YXIgYm9keSA9IFtdO1xuXG4gIHJldHVybiB7XG4gICAgbG9jYWxGb3JOYW1lOiBsb2NhbEZvck5hbWUsXG4gICAgYW5vbnltb3VzOiBhbm9ueW1vdXMsXG4gICAgc2VsZjogc2VsZixcbiAgICB3cml0ZXI6IHdyaXRlcixcbiAgICB3cml0ZTogd3JpdGUsXG4gICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgYXNzaWdubWVudHM6IGFzc2lnbm1lbnRzLFxuICAgIHVuYXJ5T3BlcmF0b3I6IHVuYXJ5T3BlcmF0b3IsXG4gICAgYmluYXJ5T3BlcmF0b3I6IGJpbmFyeU9wZXJhdG9yLFxuICAgIGNvbmRpdGlvbmFsT3BlcmF0b3I6IGNvbmRpdGlvbmFsT3BlcmF0b3IsXG4gICAgc3RhdGVtZW50OiBzdGF0ZW1lbnQsXG4gICAgaWZTdGF0ZW1lbnQ6IGlmU3RhdGVtZW50LFxuICAgIGxvb3BTdGF0ZW1lbnQ6IGxvb3BTdGF0ZW1lbnQsXG4gICAgZnVuYzogZnVuYyxcbiAgICBzdWJjb250ZXh0OiBzdWJjb250ZXh0LFxuICAgIGNvbXBvdW5kRXhwcmVzc2lvbjogY29tcG91bmRFeHByZXNzaW9uLFxuICAgIHJldHVyblN0YXRlbWVudDogcmV0dXJuU3RhdGVtZW50LFxuICAgIGNhbGw6IGNhbGwsXG4gICAgdmVjdG9yOiB2ZWN0b3IsXG4gICAgdmVjdG9yQXBwZW5kOiB2ZWN0b3JBcHBlbmQsXG4gICAgZGljdGlvbmFyeTogZGljdGlvbmFyeSxcbiAgICBkaWN0aW9uYXJ5U2V0OiBkaWN0aW9uYXJ5U2V0LFxuICAgIGNvZGU6IGNvZGUsXG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gIH07XG5cbiAgZnVuY3Rpb24gbmV4dElkKHByZWZpeCkge1xuICAgIHZhciBuZXh0ID0gbG9jYWxzW3ByZWZpeF07XG4gICAgaWYgKCB0eXBlb2YgbmV4dCAhPT0gJ251bWJlcicgKSB7XG4gICAgICBuZXh0ID0gMDsgIC8vIHNlZWQgaXRcbiAgICB9XG4gICAgdmFyIGlkID0gcHJlZml4ICsgbmV4dDtcbiAgICBsb2NhbHNbcHJlZml4XSA9IG5leHQgKyAxO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNjb3BlSW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZGl0aW9uRGVwdGg6IDAsXG4gICAgICBhc3NpZ25lZEVhcmx5OiB7fSxcbiAgICAgIHNuYXBzaG90OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtaXhpbih7fSwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hMb2NhbFNjb3BlKCkge1xuICAgIG5hbWVTdGFjay5wdXNoKHsgbmFtZXM6IG5hbWVzLCBzY29wZUluZm86IHNjb3BlSW5mbywgc2VsZk5hbWU6IHNlbGZOYW1lIH0pO1xuICAgIG5hbWVzID0gZXh0ZW5kT2JqZWN0KG5hbWVzKTtcbiAgICBzY29wZUluZm8gPSBjcmVhdGVTY29wZUluZm8oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcExvY2FsU2NvcGUoKSB7XG4gICAgdmFyIGluZm8gPSBuYW1lU3RhY2sucG9wKCk7XG4gICAgbmFtZXMgPSBpbmZvLm5hbWVzO1xuICAgIHNjb3BlSW5mbyA9IGluZm8uc2NvcGVJbmZvO1xuICAgIHNlbGZOYW1lID0gaW5mby5zZWxmTmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvY2FsRm9yTmFtZShuYW1lLCBmb3JBc3NpZ25tZW50KSB7XG4gICAgdmFyIHdpbGxNdXRhdGUgPSBoYXNBbm5vdGF0aW9uKHNjb3BlSW5mbywgJ211dGF0aW9ucycsIG5hbWUpO1xuXG4gICAgdmFyIGlkID0gbmFtZXNbbmFtZV07XG4gICAgaWYgKCBpZCAmJiAobmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgIXdpbGxNdXRhdGUpICkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIHZhciBpbkNvbmRpdGlvbiA9ICEhc2NvcGVJbmZvLmNvbmRpdGlvbkRlcHRoO1xuICAgIHNjb3BlSW5mby5hc3NpZ25lZEVhcmx5W25hbWVdID0gZm9yQXNzaWdubWVudCAmJiAhaW5Db25kaXRpb247XG4gICAgaWQgPSBuYW1lc1tuYW1lXSA9IG5leHRJZCgndicpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGYocHJvcGVydHlOYW1lKSB7XG4gICAgaWYgKCBwcm9wZXJ0eU5hbWUgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHdyaXRlKHNlbGZOYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd3JpdGUoc2VsZk5hbWUsICdbJywgZ2xvYmFscy5saXRlcmFsKHByb3BlcnR5TmFtZSksICddJyk7XG4gIH1cblxuICBmdW5jdGlvbiBhbm9ueW1vdXMobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHZhciBpZCA9IG5leHRJZCgnaCcpO1xuICAgICAgbmFtZSA9ICcgJyArIGlkOyAgLy8gc3BhY2UgYWxsb3dzIGFub255bW91cyBsb2NhbHNcbiAgICAgIG5hbWVzW25hbWVdID0gaWQ7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgd3JpdGUobmFtZXNbbmFtZV0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3cml0ZShuYW1lc1tuYW1lXSwgJz0nLCB2YWx1ZSwgJzsnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQW5vbnltb3VzKG5hbWUpIHtcbiAgICByZXR1cm4gKC8gaFswLTldKy8pLnRlc3QobmFtZSk7XG4gIH1cblxuICBmdW5jdGlvbiB1c2VDb250ZXh0KCkge1xuICAgIHJldHVybiBoYXNBbm5vdGF0aW9uKHNjb3BlSW5mbywgJ3NlbGYnLCAncmVhZCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVyKGZ1bmN0aW9uTmFtZSkge1xuICAgIGlmICggZnVuY3Rpb25OYW1lID09PSB1bmRlZmluZWQgKSB7XG4gICAgICByZXR1cm4gJ3cnO1xuICAgIH1cbiAgICByZXR1cm4gJ3cuJyArIGZ1bmN0aW9uTmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hXcml0ZXIoKSB7XG4gICAgd3JpdGVyU3RhY2sucHVzaChib2R5KTtcbiAgICBib2R5ID0gW107XG4gIH1cblxuICBmdW5jdGlvbiBwb3BXcml0ZXIoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJvZHk7XG4gICAgYm9keSA9IHdyaXRlclN0YWNrLnBvcCgpO1xuICAgIHJldHVybiBjb2RlKHJlc3VsdCk7XG4gIH1cblxuICBmdW5jdGlvbiBjYXB0dXJlU3RhdGUoY2FwdHVyZWRCb2R5KSB7XG4gICAgdmFyIG15U2NvcGVJbmZvID0gc2NvcGVJbmZvLnNuYXBzaG90KCk7XG4gICAgdmFyIG15TmFtZXMgPSBuYW1lcztcbiAgICB2YXIgbXlTZWxmTmFtZSA9IHNlbGZOYW1lO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHB1c2hMb2NhbFNjb3BlKCk7XG4gICAgICBzY29wZUluZm8gPSBteVNjb3BlSW5mbztcbiAgICAgIG5hbWVzID0gbXlOYW1lcztcbiAgICAgIHNlbGZOYW1lID0gbXlTZWxmTmFtZTtcbiAgICAgIGNhcHR1cmVkQm9keSgpO1xuICAgICAgcG9wTG9jYWxTY29wZSgpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZSgpIHtcbiAgICB2YXIgYXJncyA9IGZpbHRlcihhcmd1bWVudHMsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmcgIT09IHVuZGVmaW5lZCAmJiBhcmcgIT09IG51bGw7XG4gICAgfSk7XG4gICAgZWFjaChhcmdzLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICBpZiAoIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgIGJvZHkucHVzaChjYXB0dXJlU3RhdGUoYXJnKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYm9keS5wdXNoKGFyZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZURlbGltaXRlZChpdGVtcywgZGVsaW1pdGVyKSB7XG4gICAgaWYgKCBkZWxpbWl0ZXIgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGRlbGltaXRlciA9ICcsJztcbiAgICB9XG4gICAgZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgIGlmICggaSA+IDAgKSB7XG4gICAgICAgIHdyaXRlKGRlbGltaXRlcik7XG4gICAgICB9XG4gICAgICB3cml0ZShpdGVtKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlKHZhbHVlKSB7XG4gICAgaWYgKCB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgKSB7XG4gICAgICB3cml0ZSh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhbHVlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXR0ZXIobmFtZSkge1xuICAgIHdyaXRlKGxvY2FsRm9yTmFtZShuYW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb250ZXh0QXNzaWdubWVudHMobmFtZXMpIHtcbiAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGxvY2FsTmFtZSA9IGxvY2FsRm9yTmFtZShuYW1lKTtcbiAgICAgIHNlbGYobmFtZSk7XG4gICAgICB3cml0ZSgnPScsIGxvY2FsTmFtZSwgJzsnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnbm1lbnRzKGl0ZW1zKSB7XG4gICAgZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBuYW1lID0gaXRlbVswXTtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZW1bMV07XG5cbiAgICAgIC8vIEV2YWx1YXRlIHRoaXMgZmlyc3RcbiAgICAgIHZhciBsb2NhbE5hbWUgPSBsb2NhbEZvck5hbWUobmFtZSwgdHJ1ZSk7XG4gICAgICB3cml0ZShsb2NhbE5hbWUsICc9Jyk7XG4gICAgICBpZiAoICFpc0Fub255bW91cyhuYW1lKSAmJiB1c2VDb250ZXh0KCkgKSB7XG4gICAgICAgIHNlbGYobmFtZSk7XG4gICAgICAgIHdyaXRlKCc9Jyk7XG4gICAgICB9XG4gICAgICB3cml0ZSh2YWx1ZSwgJzsnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuYXJ5T3BlcmF0b3Iob3BlcmF0b3IsIG9wZXJhbmQpIHtcbiAgICB3cml0ZSgnKCcsIG9wZXJhdG9yTWFwW29wZXJhdG9yXSwgJygnLCBjb2RlKG9wZXJhbmQpLCAnKSknKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeU9wZXJhdG9yKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgIHdyaXRlKCcoJywgY29kZShsZWZ0KSwgb3BlcmF0b3JNYXBbb3BlcmF0b3JdLCBjb2RlKHJpZ2h0KSwgJyknKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmRpdGlvbmFsT3BlcmF0b3IoY29uZGl0aW9uLCB0cnVlVmFsLCBmYWxzZVZhbCkge1xuICAgIHZhciBpc1RydXRoeSA9IGdsb2JhbHMucnVudGltZUltcG9ydCgnaXNUcnV0aHknKTtcbiAgICB2YXIgY29uZENvZGUgPSBjb2RlKGNvbmRpdGlvbik7XG4gICAgdmFyIHRydWVDb2RlID0gY29kZSh0cnVlVmFsKTtcbiAgICB2YXIgZmFsc2VDb2RlID0gY29kZShmYWxzZVZhbCk7XG4gICAgd3JpdGUoJygnLCBpc1RydXRoeSwgJygnLCBjb25kQ29kZSwgJyk/JywgdHJ1ZUNvZGUsICc6JywgZmFsc2VDb2RlLCAnKScpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhdGVtZW50KGJvZHlDYWxsYmFjaykge1xuICAgIHdyaXRlKGNvZGUoYm9keUNhbGxiYWNrKSwgJzsnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlmU3RhdGVtZW50KGNvbmRpdGlvbiwgdGhlbkJyYW5jaCwgZWxzZUJyYW5jaCkge1xuICAgIHZhciBjb25kV3JhcHBlck5hbWUgPSAnaXNUcnV0aHknO1xuICAgIGlmICggIXRoZW5CcmFuY2ggKSB7XG4gICAgICBjb25kV3JhcHBlck5hbWUgPSAnaXNGYWxzeSc7XG4gICAgICB0aGVuQnJhbmNoID0gZWxzZUJyYW5jaDtcbiAgICAgIGVsc2VCcmFuY2ggPSBudWxsO1xuICAgIH1cbiAgICBzY29wZUluZm8uY29uZGl0aW9uRGVwdGggKz0gMTtcbiAgICB2YXIgY29uZFdyYXBwZXIgPSBnbG9iYWxzLnJ1bnRpbWVJbXBvcnQoY29uZFdyYXBwZXJOYW1lKTtcbiAgICB2YXIgY29uZENvZGUgPSBjb2RlKGNvbmRpdGlvbik7XG4gICAgdmFyIHRoZW5Db2RlID0gY29kZSh0aGVuQnJhbmNoKTtcbiAgICB3cml0ZSgnaWYoJywgY29uZFdyYXBwZXIsICcoJywgY29uZENvZGUsICcpKXsnLCB0aGVuQ29kZSwgJ30nKTtcbiAgICBpZiAoIGVsc2VCcmFuY2ggKSB7XG4gICAgICB3cml0ZSgnZWxzZXsnLCBjb2RlKGVsc2VCcmFuY2gpLCAnfScpO1xuICAgIH1cbiAgICBzY29wZUluZm8uY29uZGl0aW9uRGVwdGggLT0gMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvb3BTdGF0ZW1lbnQoaXRlbU5hbWUsIGNvbGxlY3Rpb24sIGxvb3BHdWFyZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBsb29wQm9keSwgYW5ub3RhdGlvbnMpIHtcbiAgICB2YXIgbG9vcCA9IGdsb2JhbHMucnVudGltZUltcG9ydCgnbG9vcCcpO1xuICAgIGFubm90YXRlKGFubm90YXRpb25zLCAnamF2YXNjcmlwdCcsICdieXBhc3NDbGVhbnNlJyk7XG5cbiAgICBzdGF0ZW1lbnQoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbChsb29wLCBbXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmdW5jKFtdLCBbaXRlbU5hbWVdLCBsb29wR3VhcmQsIGxvb3BCb2R5LCBhbm5vdGF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnVuYyhpbnRlcm5hbEFyZ3MsIGNvbnRleHRBcmdzLCBmdW5jUHJvbG9nLCBmdW5jQm9keSwgYW5ub3RhdGlvbnMpIHtcbiAgICBpZiAoICFpc0FycmF5KGNvbnRleHRBcmdzKSApIHtcbiAgICAgIGFubm90YXRpb25zID0gZnVuY0JvZHk7XG4gICAgICBmdW5jQm9keSA9IGZ1bmNQcm9sb2c7XG4gICAgICBmdW5jUHJvbG9nID0gY29udGV4dEFyZ3M7XG4gICAgICBjb250ZXh0QXJncyA9IFtdO1xuICAgIH1cblxuICAgIGlmICggdHlwZW9mIGZ1bmNCb2R5ICE9PSAnZnVuY3Rpb24nICkge1xuICAgICAgYW5ub3RhdGlvbnMgPSBmdW5jQm9keTtcbiAgICAgIGZ1bmNCb2R5ID0gZnVuY1Byb2xvZztcbiAgICAgIGZ1bmNQcm9sb2cgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnROYW1lcyA9IG5hbWVzO1xuICAgIHB1c2hMb2NhbFNjb3BlKCk7XG4gICAgc2NvcGVJbmZvLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgdmFyIHN1YiA9IGNvbnRleHRBcmdzLmxlbmd0aCAmJiB1c2VDb250ZXh0KCk7XG4gICAgdmFyIGNsZWFuc2UgPSAhaGFzQW5ub3RhdGlvbihhbm5vdGF0aW9ucywgJ2phdmFzY3JpcHQnLCAnYnlwYXNzQ2xlYW5zZScpO1xuXG4gICAgdmFyIGxvY2FsTmFtZXMgPSBtYXAoY29udGV4dEFyZ3MsIGxvY2FsRm9yTmFtZSk7XG5cbiAgICB2YXIgYm9keUNvbnRlbnQgPSBjb2RlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICggIXN1YiApIHtcbiAgICAgICAgZ2VuZXJhdGUoZnVuY0JvZHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN0YXRlbWVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN1YmNvbnRleHQoXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29udGV4dEFzc2lnbm1lbnRzKGNvbnRleHRBcmdzKTtcbiAgICAgICAgICAgIGdlbmVyYXRlKGZ1bmNCb2R5KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFubm90YXRpb25zXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBwcm9sb2dDb250ZW50ID0gY29kZShmdW5jdGlvbiAoKSB7XG4gICAgICBnZW5lcmF0ZShmdW5jUHJvbG9nKTtcbiAgICB9KTtcblxuICAgIHZhciBhcmdOYW1lcyA9IGludGVybmFsQXJncy5jb25jYXQobG9jYWxOYW1lcyk7XG4gICAgd3JpdGUoJ2Z1bmN0aW9uKCcsIGFyZ05hbWVzLmpvaW4oJywnKSwgJyl7Jyk7XG5cbiAgICBpZiAoIGNvbnRleHRBcmdzLmxlbmd0aCAmJiBjbGVhbnNlICkge1xuICAgICAgdmFyIGNsZWFuc2VBcmd1bWVudHMgPSBnbG9iYWxzLnJ1bnRpbWVJbXBvcnQoJ2NsZWFuc2VBcmd1bWVudHMnKTtcbiAgICAgIHdyaXRlKGNsZWFuc2VBcmd1bWVudHMsICcoYXJndW1lbnRzLCAnLCBpbnRlcm5hbEFyZ3MubGVuZ3RoLCAnKTsnKTtcbiAgICB9XG5cbiAgICB3cml0ZShwcm9sb2dDb250ZW50KTtcbiAgICB3cml0ZUxvY2FsVmFyaWFibGVzKHBhcmVudE5hbWVzLCBhcmdOYW1lcyk7XG5cbiAgICB3cml0ZShib2R5Q29udGVudCwgJ30nKTtcbiAgICBwb3BMb2NhbFNjb3BlKCk7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZUxvY2FsVmFyaWFibGVzKHBhcmVudE5hbWVzLCBhcmdOYW1lcykge1xuICAgIGlmICggYXJnTmFtZXMgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGFyZ05hbWVzID0gW107XG4gICAgfVxuXG4gICAgdmFyIHVuZGVmaW5lZFZhcnMgPSBbXTtcbiAgICBlYWNoKG9iamVjdEtleXMobmFtZXMpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGxvY2FsTmFtZSA9IG5hbWVzW25hbWVdO1xuICAgICAgaWYgKCBhcmdOYW1lcy5pbmRleE9mKGxvY2FsTmFtZSkgIT09IC0xICkge1xuICAgICAgICAvLyB3YXMgYW4gYXJndW1lbnQsIHNraXAgaXRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIGlzQW5vbnltb3VzKG5hbWUpIHx8IHNjb3BlSW5mby5hc3NpZ25lZEVhcmx5W25hbWVdICkge1xuICAgICAgICB1bmRlZmluZWRWYXJzLnB1c2gobG9jYWxOYW1lKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCBwYXJlbnROYW1lc1tuYW1lXSApIHtcbiAgICAgICAgLy8gTG9jYWwgQXNzaWdubWVudHMgKGluaGVyaXQgZnJvbSBwYXJlbnQpXG4gICAgICAgIHdyaXRlKCd2YXIgJywgbG9jYWxOYW1lLCAnPScsIHBhcmVudE5hbWVzW25hbWVdLCAnOycpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnZXRQcm9wZXJ0eSA9IGdsb2JhbHMucnVudGltZUltcG9ydCgnZ2V0UHJvcGVydHknKTtcbiAgICAgICAgd3JpdGUoJ3ZhciAnLCBsb2NhbE5hbWUsICc9Jyk7XG4gICAgICAgIGNhbGwoZ2V0UHJvcGVydHksIFtcbiAgICAgICAgICBzZWxmLFxuICAgICAgICAgIGdsb2JhbHMubGl0ZXJhbChuYW1lKVxuICAgICAgICBdKTtcbiAgICAgICAgd3JpdGUoJzsnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICggdW5kZWZpbmVkVmFycy5sZW5ndGggKSB7XG4gICAgICB3cml0ZSgndmFyICcsIHVuZGVmaW5lZFZhcnMuam9pbignLCcpLCAnOycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN1YmNvbnRleHQoYm9keUNhbGxiYWNrLCBhbm5vdGF0aW9ucykge1xuICAgIHZhciBwYXJlbnROYW1lcyA9IG5hbWVzO1xuICAgIHZhciBwYXJlbnRTZWxmTmFtZSA9IHNlbGZOYW1lO1xuXG4gICAgcHVzaExvY2FsU2NvcGUoKTtcbiAgICBzY29wZUluZm8uYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICBzZWxmTmFtZSA9IG5leHRJZCgnYycpO1xuXG4gICAgdmFyIGV4dGVuZE9iamVjdCA9IGdsb2JhbHMucnVudGltZUltcG9ydCgnZXh0ZW5kT2JqZWN0Jyk7XG4gICAgc3RhdGVtZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgIHdyaXRlKCd2YXIgJywgc2VsZk5hbWUsICc9Jyk7XG4gICAgICBjYWxsKGV4dGVuZE9iamVjdCwgW3BhcmVudFNlbGZOYW1lXSk7XG4gICAgfSk7XG5cbiAgICB2YXIgYm9keUNvbnRlbnQgPSBjb2RlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdlbmVyYXRlKGJvZHlDYWxsYmFjayk7XG4gICAgfSk7XG5cbiAgICB3cml0ZUxvY2FsVmFyaWFibGVzKHBhcmVudE5hbWVzKTtcbiAgICB3cml0ZShib2R5Q29udGVudCk7XG4gICAgcG9wTG9jYWxTY29wZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcG91bmRFeHByZXNzaW9uKGJvZHlDYWxsYmFjaywgYW5ub3RhdGlvbnMpIHtcbiAgICB2YXIgcGFyZW50TmFtZXMgPSBuYW1lcztcblxuICAgIHB1c2hMb2NhbFNjb3BlKCk7XG4gICAgc2NvcGVJbmZvLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG5cbiAgICB2YXIgYm9keUNvbnRlbnQgPSBjb2RlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdlbmVyYXRlKGJvZHlDYWxsYmFjayk7XG4gICAgfSk7XG5cbiAgICB3cml0ZSgnKGZ1bmN0aW9uKCl7Jyk7XG4gICAgd3JpdGVMb2NhbFZhcmlhYmxlcyhwYXJlbnROYW1lcyk7XG4gICAgd3JpdGUoYm9keUNvbnRlbnQpO1xuICAgIHBvcExvY2FsU2NvcGUoKTtcbiAgICB3cml0ZSgnfSgpKScpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0dXJuU3RhdGVtZW50KGJvZHlDYWxsYmFjaykge1xuICAgIGlmICggYm9keUNhbGxiYWNrID09PSB1bmRlZmluZWQgKSB7XG4gICAgICB3cml0ZSgncmV0dXJuOycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3cml0ZSgncmV0dXJuICcsIGJvZHlDYWxsYmFjaywgJzsnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGwoZnVuY0lkLCBhcmdzKSB7XG4gICAgaWYgKCAhYXJncyApIHtcbiAgICAgIC8vIFBhc3MgdGhyb3VnaCBsb2NhbCBhcmd1bWVudHMgKGZvciBwYXJ0aWFsIGNoYWluaW5nKVxuICAgICAgd3JpdGUoZnVuY0lkLCAnLmFwcGx5KG51bGwsYXJndW1lbnRzKScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3cml0ZShmdW5jSWQsICcoJyk7XG4gICAgd3JpdGVEZWxpbWl0ZWQoYXJncyk7XG4gICAgd3JpdGUoJyknKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZlY3RvcihpdGVtcykge1xuICAgIHdyaXRlKCdbJyk7XG4gICAgd3JpdGVEZWxpbWl0ZWQoaXRlbXMpO1xuICAgIHdyaXRlKCddJyk7XG4gIH1cblxuICBmdW5jdGlvbiB2ZWN0b3JBcHBlbmQodmVjdG9yLCB2YWx1ZSkge1xuICAgIHN0YXRlbWVudChmdW5jdGlvbiAoKSB7XG4gICAgICB3cml0ZSh2ZWN0b3IsICcucHVzaCgnLCB2YWx1ZSwgJyknKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpY3Rpb25hcnkoaXRlbXMsIG9yZGVyZWQpIHtcbiAgICBpdGVtcyA9IG1hcChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmNvbmNhdCh0eXBlb2YgaXRlbVswXSA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgfSk7XG5cbiAgICB2YXIgbGl0ZXJhbHMgPSBbXTtcbiAgICB2YXIgZXhwcmVzc2lvbnMgPSBpdGVtcztcblxuICAgIGlmICggIW9yZGVyZWQgKSB7XG4gICAgICBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGl0ZW1bMl0gPyBleHByZXNzaW9ucyA6IGxpdGVyYWxzO1xuICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICggZXhwcmVzc2lvbnMubGVuZ3RoICkge1xuICAgICAgd3JpdGUoJyhmdW5jdGlvbihvKXsnKTtcbiAgICAgIGVhY2goZXhwcmVzc2lvbnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBuYW1lID0gaXRlbVsyXSA/IGl0ZW1bMF0gOiBnbG9iYWxzLmxpdGVyYWwoaXRlbVswXSk7XG4gICAgICAgIHdyaXRlKCdvWycsIG5hbWUsICddPScsIGl0ZW1bMV0sICc7Jyk7XG4gICAgICB9KTtcbiAgICAgIHdyaXRlKCdyZXR1cm4gbzt9KCcpO1xuICAgICAgd3JpdGVMaXRlcmFscygpO1xuICAgICAgd3JpdGUoJykpJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgd3JpdGVMaXRlcmFscygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyaXRlTGl0ZXJhbHMoKSB7XG4gICAgICB3cml0ZSgneycpO1xuICAgICAgZWFjaChsaXRlcmFscywgZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgaWYgKCBpID4gMCApIHtcbiAgICAgICAgICB3cml0ZSgnLCcpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlKGpzb25TdHJpbmdpZnkoaXRlbVswXSksICc6JywgaXRlbVsxXSk7XG4gICAgICB9KTtcbiAgICAgIHdyaXRlKCd9Jyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGljdGlvbmFyeVNldChkaWN0LCBuYW1lLCB2YWx1ZSkge1xuICAgIHN0YXRlbWVudChmdW5jdGlvbiAoKSB7XG4gICAgICB3cml0ZShkaWN0LCAnWycsIG5hbWUsICddPScsIHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvZGUodmFsdWUpIHtcbiAgICBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICByZXR1cm4gY29kZShib2R5KTtcbiAgICB9XG5cbiAgICBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgIHB1c2hXcml0ZXIoKTtcbiAgICAgIHZhbHVlKCk7XG4gICAgICByZXR1cm4gcG9wV3JpdGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKCBpc0FycmF5KHZhbHVlKSApIHtcbiAgICAgIHJldHVybiBtYXAodmFsdWUsIGNvZGUpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBjb2RlKCk7XG4gIH1cbn1cblxuLy8gRXhwb3J0ZWQgRnVuY3Rpb25zXG5leHBvcnRzLmNyZWF0ZUdsb2JhbHMgPSBjcmVhdGVHbG9iYWxzO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGUgPSBjcmVhdGVNb2R1bGU7XG4iLCIvKlxuICogSW50ZXJwb2wgKExvZ2ljZnVsIEhUTUwgVGVtcGxhdGVzKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBzZWUgZG9jL0xJQ0VOU0UubWRcbiAqXG4gKiBAYXV0aG9yIFRob21hcyBTLiBCcmFkZm9yZCAoa29kZTRmb29kLml0KVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBmb3JtYXR0ZXIgPSByZXF1aXJlKCcuLi9mb3JtYXQnKTtcbnZhciBnZW5lcmF0ZWRQYXJzZXIgPSByZXF1aXJlKCcuLi8uLi9idWlsZC9wYXJzZXInKTtcblxudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG52YXIgbWl4aW4gPSB1dGlsLm1peGluO1xudmFyIGVhY2ggPSB1dGlsLmVhY2g7XG52YXIgYnVpbGRGb3JtYXR0ZXIgPSBmb3JtYXR0ZXIuYnVpbGRGb3JtYXR0ZXI7XG5cbnZhciBmb3JtYXR0ZXJDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gIHZhciByZXN1bHQgPSBnZW5lcmF0ZWRQYXJzZXIucGFyc2UodGVtcGxhdGUpO1xuICBmb3JtYXR0ZXJDYWNoZSA9IHt9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBidWlsZEJpbmFyeUNoYWluKGhlYWQsIHRhaWwpIHtcbiAgaWYgKCAhdGFpbCB8fCAhdGFpbC5sZW5ndGggKSB7XG4gICAgcmV0dXJuIGhlYWQ7XG4gIH1cblxuICBlYWNoKHRhaWwsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaGVhZCA9IFsgaXRlbVswXSwgaGVhZCwgaXRlbVsxXSBdO1xuICB9KTtcblxuICByZXR1cm4gaGVhZDtcbn1cblxuZnVuY3Rpb24gc3ltKHZhbHVlLCB0eXBlLCB0ZW1wbGF0ZSkge1xuICBpZiAoIHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyApIHtcbiAgICB0ZW1wbGF0ZSA9IHR5cGU7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIG1peGluKHt9LCB0ZW1wbGF0ZSB8fCB7fSwgeyB2YWx1ZTogdmFsdWUsIHR5cGU6IHR5cGUgfHwgJ29wJyB9KTtcbn1cblxuZnVuY3Rpb24gc3RtdHMoc3RhdGVtZW50cykge1xuICBzdGF0ZW1lbnRzLnN0bXRzID0gdHJ1ZTtcbiAgcmV0dXJuIHN0YXRlbWVudHM7XG59XG5cbmZ1bmN0aW9uIHN5bUludGVycG9sYXRlKHZhbHVlLCBhdXRvKSB7XG4gIHZhciB0ZXN0Rm9ybWF0dGVyID0gZm9ybWF0dGVyQ2FjaGVbdmFsdWVdO1xuICBpZiAoICF0ZXN0Rm9ybWF0dGVyICkge1xuICAgIHRlc3RGb3JtYXR0ZXIgPSBmb3JtYXR0ZXJDYWNoZVt2YWx1ZV0gPSBidWlsZEZvcm1hdHRlcih2YWx1ZSk7XG4gIH1cbiAgdmFyIHJlcXVpcmVkSW5kZXhlcyA9IHRlc3RGb3JtYXR0ZXIuX19pbnRSZXF1aXJlZEluZGV4ZXMgfHwgW107XG4gIGlmICggIXJlcXVpcmVkSW5kZXhlcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuIHN5bSh2YWx1ZSwgJ2xpdCcpO1xuICB9XG4gIHZhciByZXN1bHQgPSBzeW0odmFsdWUsIGF1dG8gPyAnYXV0byc6ICdpbnQnKTtcbiAgcmVzdWx0LmZvcm1hdHRlciA9IHRlc3RGb3JtYXR0ZXI7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNTeW1ib2wobm9kZSkge1xuICByZXR1cm4gaXNEZWZpbmVkKG5vZGUpICYmXG4gICAgICAgICB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIG5vZGUgIT09IG51bGwgJiZcbiAgICAgICAgIG5vZGUudmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgbm9kZS50eXBlICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGVtZW50cyhub2RlKSB7XG4gIHJldHVybiBpc0RlZmluZWQobm9kZSkgJiZcbiAgICAgICAgIGlzQXJyYXkobm9kZSkgJiZcbiAgICAgICAgIG5vZGUuc3RtdHMgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGhhc09wZXJhdG9yKG5vZGUsIG9wZXJhdG9yKSB7XG4gIGlmICggIWlzQXJyYXkobm9kZSkgfHwgaXNTdGF0ZW1lbnRzKG5vZGUpICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpdGVtID0gbm9kZVswXTtcbiAgaWYgKCAhaXNTeW1ib2woaXRlbSkgfHwgaXRlbS50eXBlICE9PSAnb3AnICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICggIW9wZXJhdG9yICkge1xuICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICB9XG5cbiAgaWYgKCAhaXNBcnJheShvcGVyYXRvcikgKSB7XG4gICAgb3BlcmF0b3IgPSBbb3BlcmF0b3JdO1xuICB9XG5cbiAgdmFyIGlkeCA9IG9wZXJhdG9yLmluZGV4T2YoaXRlbS52YWx1ZSk7XG4gIGlmICggaWR4ID09PSAtMSApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wZXJhdG9yW2lkeF07XG59XG5cbmZ1bmN0aW9uIGNoYW5nZU9wZXJhdG9yKG5vZGUsIG9wZXJhdG9yKSB7XG4gIHZhciBpdGVtID0gbm9kZVswXTtcbiAgLy8gYXNzZXJ0KGlzU3ltYm9sKGl0ZW0pICYmIGl0ZW0udHlwZSA9PT0gJ29wJyk7XG4gIGl0ZW0udmFsdWUgPSBvcGVyYXRvcjtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJwb2xhdGVkKG5vZGUpIHtcbiAgcmV0dXJuIGlzU3ltYm9sKG5vZGUpICYmXG4gICAgICAgICAobm9kZS50eXBlID09PSAnYXV0bycgfHwgbm9kZS50eXBlID09PSAnaW50Jyk7XG59XG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihub2RlKSB7XG4gIHJldHVybiBpc1N5bWJvbChub2RlKSAmJlxuICAgICAgICAgbm9kZS50eXBlID09PSAnaWQnO1xufVxuXG5mdW5jdGlvbiBpc0xpdGVyYWwobm9kZSkge1xuICByZXR1cm4gaXNTeW1ib2wobm9kZSkgJiZcbiAgICAgICAgIG5vZGUudHlwZSA9PT0gJ2xpdCc7XG59XG5cbi8vIEV4Y2VwdGlvbnNcblxuLyoqXG4gKiBJbnRlcmNlcHRzIGEgUEVHLmpzIEV4Y2VwdGlvbiBhbmQgZ2VuZXJhdGUgYSBodW1hbi1yZWFkYWJsZSBlcnJvciBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7RXhjZXB0aW9ufSBlcnIgdGhlIEV4Y2VwdGlvbiB0aGF0IHdhcyByYWlzZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmlsZVBhdGhdIHBhdGggdG8gdGhlIGZpbGUgdGhhdCB3YXMgYmVpbmcgcGFyc2VkXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFN5bnRheEVycm9yKGVyciwgZmlsZVBhdGgpIHtcbiAgaWYgKCAhZXJyLm5hbWUgfHwgZXJyLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWQgPSBlcnIuZm91bmQgPyBcIidcIiArIGVyci5mb3VuZCArIFwiJ1wiIDogXCJlbmQgb2YgZmlsZVwiO1xuICB2YXIgZXJyU3RyaW5nID0gXCJVbmV4cGVjdGVkIFwiICsgdW5leHBlY3RlZDtcbiAgdmFyIGxpbmVJbmZvID0gXCI6XCIgKyBlcnIubGluZSArIFwiOlwiICsgZXJyLmNvbHVtbjtcblxuICByZXR1cm4gbmV3IEVycm9yKChmaWxlUGF0aCB8fCAnc3RyaW5nJykgKyBsaW5lSW5mbyArIFwiOiBcIiArIGVyclN0cmluZyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdhcm5pbmcod2FybmluZywgZmlsZVBhdGgpIHtcbiAgdmFyIGxpbmVJbmZvID0gXCI6XCIgKyB3YXJuaW5nLmxpbmUgKyBcIjpcIiArIHdhcm5pbmcuY29sdW1uO1xuICB2YXIgd2FybmluZ1N0cmluZyA9IHdhcm5pbmcubWVzc2FnZTtcblxuICBmaWxlUGF0aCA9IGZpbGVQYXRoIHx8IHdhcm5pbmcuZmlsZVBhdGggfHwgJ3N0cmluZyc7XG4gIHJldHVybiBmaWxlUGF0aCArIGxpbmVJbmZvICsgXCI6IFwiICsgd2FybmluZ1N0cmluZztcbn1cblxuLy8gRXhwb3J0ZWQgRnVuY3Rpb25zXG5leHBvcnRzLnBhcnNlVGVtcGxhdGUgPSBwYXJzZVRlbXBsYXRlO1xuZXhwb3J0cy5idWlsZEJpbmFyeUNoYWluID0gYnVpbGRCaW5hcnlDaGFpbjtcbmV4cG9ydHMuc3ltID0gc3ltO1xuZXhwb3J0cy5zdG10cyA9IHN0bXRzO1xuZXhwb3J0cy5zeW1JbnRlcnBvbGF0ZSA9IHN5bUludGVycG9sYXRlO1xuZXhwb3J0cy5pc0RlZmluZWQgPSBpc0RlZmluZWQ7XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5leHBvcnRzLmlzU3RhdGVtZW50cyA9IGlzU3RhdGVtZW50cztcbmV4cG9ydHMuaGFzT3BlcmF0b3IgPSBoYXNPcGVyYXRvcjtcbmV4cG9ydHMuY2hhbmdlT3BlcmF0b3IgPSBjaGFuZ2VPcGVyYXRvcjtcbmV4cG9ydHMuaXNJbnRlcnBvbGF0ZWQgPSBpc0ludGVycG9sYXRlZDtcbmV4cG9ydHMuaXNJZGVudGlmaWVyID0gaXNJZGVudGlmaWVyO1xuZXhwb3J0cy5pc0xpdGVyYWwgPSBpc0xpdGVyYWw7XG5leHBvcnRzLmZvcm1hdFN5bnRheEVycm9yID0gZm9ybWF0U3ludGF4RXJyb3I7XG5leHBvcnRzLmZvcm1hdFdhcm5pbmcgPSBmb3JtYXRXYXJuaW5nO1xuIiwiLypcbiAqIEludGVycG9sIChMb2dpY2Z1bCBIVE1MIFRlbXBsYXRlcylcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogc2VlIGRvYy9MSUNFTlNFLm1kXG4gKlxuICogQGF1dGhvciBUaG9tYXMgUy4gQnJhZGZvcmQgKGtvZGU0Zm9vZC5pdClcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludGVycG9sID0gcmVxdWlyZSgnLi4vaW50ZXJwb2wnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHR5cGVzID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xudmFyIGZvcm1hdCA9IHJlcXVpcmUoJy4uL2Zvcm1hdCcpO1xudmFyIG1hdGNoID0gcmVxdWlyZSgnLi4vbWF0Y2gnKTtcbnZhciBhbm5vdGF0aW9ucyA9IHJlcXVpcmUoJy4vYW5ub3RhdGlvbnMnKTtcblxudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG52YXIgb2JqZWN0S2V5cyA9IHV0aWwub2JqZWN0S2V5cztcbnZhciBlYWNoID0gdXRpbC5lYWNoO1xudmFyIG1hcCA9IHV0aWwubWFwO1xudmFyIHNlbGZNYXAgPSB1dGlsLnNlbGZNYXA7XG5cbnZhciBlc2NhcGVDb250ZW50ID0gdHlwZXMuZXNjYXBlQ29udGVudDtcbnZhciBlc2NhcGVBdHRyaWJ1dGUgPSB0eXBlcy5lc2NhcGVBdHRyaWJ1dGU7XG52YXIgc3RyaW5naWZ5ID0gdHlwZXMuc3RyaW5naWZ5O1xudmFyIGlzVHJ1dGh5ID0gdHlwZXMuaXNUcnV0aHk7XG5cbnZhciBzeW0gPSBwYXJzZXIuc3ltO1xudmFyIGlzU3RhdGVtZW50cyA9IHBhcnNlci5pc1N0YXRlbWVudHM7XG52YXIgc3RtdHMgPSBwYXJzZXIuc3RtdHM7XG52YXIgaXNTeW1ib2wgPSBwYXJzZXIuaXNTeW1ib2w7XG52YXIgaGFzT3BlcmF0b3IgPSBwYXJzZXIuaGFzT3BlcmF0b3I7XG52YXIgaXNJZGVudGlmaWVyID0gcGFyc2VyLmlzSWRlbnRpZmllcjtcbnZhciBpc0xpdGVyYWwgPSBwYXJzZXIuaXNMaXRlcmFsO1xudmFyIGlzSW50ZXJwb2xhdGVkID0gcGFyc2VyLmlzSW50ZXJwb2xhdGVkO1xuXG52YXIgaXNNYXRjaGluZ09iamVjdCA9IG1hdGNoLm1hdGNoZXM7XG52YXIgYW5ub3RhdGUgPSBhbm5vdGF0aW9ucy5hbm5vdGF0ZTtcblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG52YXIgaW52ZXJzZU9wZXJhdG9ycyA9IHtcbiAgJ2VxJzogJ25xJywgJ25xJzogJ2VxJyxcbiAgJ2x0JzogJ2dlJywgJ2dlJzogJ2x0JyxcbiAgJ2d0JzogJ2xlJywgJ2xlJzogJ2d0J1xufTtcblxudmFyIGNyZWF0ZVRhZyA9IHtcbiAgJ29wJzogY3JlYXRlT3BlblRhZyxcbiAgJ2NsJzogY3JlYXRlQ2xvc2VUYWcsXG4gICdjdCc6IGNyZWF0ZUNvbW1lbnRUYWdcbn07XG5cbnZhciBjb25zdGFudEZvbGRlcnMgPSB7XG4gICdubyc6IGZ1bmN0aW9uICh2KSB7IHJldHVybiAhaXNUcnV0aHkodik7IH0sXG4gICduZSc6IGZ1bmN0aW9uICh2KSB7IHJldHVybiAtdjsgfSxcbiAgJ2FkJzogZnVuY3Rpb24gKGwsIHIpIHsgcmV0dXJuIGwgKyByOyB9LFxuICAnc3UnOiBmdW5jdGlvbiAobCwgcikgeyByZXR1cm4gbCAtIHI7IH0sXG4gICdtdSc6IGZ1bmN0aW9uIChsLCByKSB7IHJldHVybiBsICogcjsgfSxcbiAgJ2RpJzogZnVuY3Rpb24gKGwsIHIpIHsgcmV0dXJuIGwgLyByOyB9LFxuICAnZXEnOiBmdW5jdGlvbiAobCwgcikgeyByZXR1cm4gbCA9PT0gcjsgfSxcbiAgJ25xJzogZnVuY3Rpb24gKGwsIHIpIHsgcmV0dXJuIGwgIT09IHI7IH0sXG4gICdndCc6IGZ1bmN0aW9uIChsLCByKSB7IHJldHVybiBsID4gcjsgfSxcbiAgJ2x0JzogZnVuY3Rpb24gKGwsIHIpIHsgcmV0dXJuIGwgPCByOyB9LFxuICAnZ2UnOiBmdW5jdGlvbiAobCwgcikgeyByZXR1cm4gbCA+PSByOyB9LFxuICAnbGUnOiBmdW5jdGlvbiAobCwgcikgeyByZXR1cm4gbCA8PSByOyB9LFxuICAnbW8nOiBmdW5jdGlvbiAobCwgcikgeyByZXR1cm4gbCAlIHI7IH0sXG4gICdtYSc6IGZ1bmN0aW9uIChsLCByKSB7IHJldHVybiBpc01hdGNoaW5nT2JqZWN0KHIsIGwpOyB9LFxuICAnbWInOiBmdW5jdGlvbiAobCwgcikge1xuICAgICAgICAgIGlmICggbCA9PT0gdW5kZWZpbmVkICkgeyByZXR1cm4gbDsgfVxuICAgICAgICAgIHZhciByZXMgPSBsW3JdO1xuICAgICAgICAgIHJldHVybiByZXMgPT09IG51bGwgPyB1bmRlZmluZWQgOiByZXM7XG4gICAgICAgIH1cbn07XG5cbnZhciBzaG9ydENpcmN1aXRGb2xkZXJzID0ge1xuICAnb3InOiBmdW5jdGlvbiAobCwgcikgeyByZXR1cm4gaXNUcnV0aHkobC52YWx1ZSkgPyBsIDogcjsgfSxcbiAgJ2FuJzogZnVuY3Rpb24gKGwsIHIpIHsgcmV0dXJuIGlzVHJ1dGh5KGwudmFsdWUpID8gciA6IGw7IH0sXG4gICdjbic6IGZ1bmN0aW9uIChjLCB0LCBmKSB7IHJldHVybiBpc1RydXRoeShjLnZhbHVlKSA/IHQgOiBmOyB9XG59O1xuXG52YXIgY29uc3RhbnRGb2xkZXJLZXlzID0gb2JqZWN0S2V5cyhjb25zdGFudEZvbGRlcnMpO1xudmFyIHNob3J0Q2lyY3VpdEZvbGRlcktleXMgPSBvYmplY3RLZXlzKHNob3J0Q2lyY3VpdEZvbGRlcnMpO1xuXG5mdW5jdGlvbiByZXdyaXRlU3ludGF4VHJlZShzeW50YXhUcmVlLCB3YXJuaW5ncykge1xuICB3YXJuaW5ncyA9IHdhcm5pbmdzIHx8IFtdO1xuICB2YXIgbm9kZVN0YWNrID0gW107XG5cbiAgdmFyIHBpcGVsaW5lID0gW1xuICAgIHN5bWJvbHMoY3JlYXRlRm9ybWF0dGVyTm9kZXMsIGlzSW50ZXJwb2xhdGVkKSxcbiAgICBvcGVyYXRvcnMoZm9sZFNob3J0Q2lyY3VpdHMsIG1hdGNoT3BzKHNob3J0Q2lyY3VpdEZvbGRlcktleXMpKSxcbiAgICBvcGVyYXRvcnMoZm9sZENvbnN0YW50cywgbWF0Y2hPcHMoY29uc3RhbnRGb2xkZXJLZXlzKSksXG4gICAgb3BlcmF0b3JzKGZsaXBDb25kaXRpb25hbHMsIG1hdGNoT3BzKCdjbicsICdpZicpKSxcbiAgICBvcGVyYXRvcnMoZmxpcEVxdWFsaXR5LCBtYXRjaE9wcygnbm8nKSksXG4gICAgb3BlcmF0b3JzKHByb21vdGVOb3QsIG1hdGNoT3BzKCdhbicsICdvcicpKSxcbiAgICBvcGVyYXRvcnMobGl0ZXJhbEZyb21BcnJheSwgbWF0Y2hPcHMoJ2FyJykpLFxuICAgIG9wZXJhdG9ycyhsaXRlcmFsRnJvbURpY3Rpb25hcnksIG1hdGNoT3BzKCdkYycpKSxcbiAgICBvcGVyYXRvcnMoaW1tZWRpYXRlSW50ZXJwb2xhdGlvbiwgbWF0Y2hPcHMoJ2NhJykpLFxuICAgIG9wZXJhdG9ycyhzZWxmRm9ybWF0RnJvbURpY3Rpb25hcnksIG1hdGNoT3BzKCdmbScpKSxcbiAgICBzdGF0ZW1lbnRzKGZvbGRJZlN0YXRlbWVudHMpLFxuICAgIHN0YXRlbWVudHMoaG9pc3RQYXJ0aWFscyksXG5cbiAgICBncm91cHMobWVyZ2VQYXJ0aWFscywgbWF0Y2hPcHMoJ2RlJykpLFxuICAgIG9wZXJhdG9ycyhyb2xsVXBGb3JMb29wcywgbWF0Y2hPcHMoJ2ZyJykpLFxuICAgIG9wZXJhdG9ycyhyb2xsVXBNZW1iZXJQYXRocywgbWF0Y2hPcHMoJ21iJykpLFxuICAgIG9wZXJhdG9ycyhwcm9tb3RlUmF3TGl0ZXJhbE91dHB1dCwgbWF0Y2hPcHMoJ291JykpLFxuICAgIG9wZXJhdG9ycyhjb252ZXJ0TGl0ZXJhbEhUTUwsIG1hdGNoT3BzKCdvcCcsICdjbCcsICdjdCcpKSxcbiAgICBncm91cHMobWVyZ2VSYXdPdXRwdXQsIG1hdGNoT3BzKCdyYScpKSxcblxuICAgIG9wZXJhdG9ycyhhc3NpZ25QYXJ0aWFscywgbWF0Y2hPcHMoJ2RlJykpLFxuXG4gICAgb3BlcmF0b3JzKGFubm90YXRlU2VsZlJlZmVyZW5jZXMsIG1hdGNoT3BzKCdzZScpKSxcbiAgICBvcGVyYXRvcnMoYW5ub3RhdGVNdXRhdGlvbnMsIG1hdGNoT3BzKCdhcycpKSxcblxuICAgIGZpbmFsaXplUm9vdFxuICBdO1xuXG4gIGVhY2gocGlwZWxpbmUsIGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgLy8gTWFyayB0aGUgcm9vdCBmb3IgbWF0Y2hpbmdcbiAgICBzeW50YXhUcmVlLnJvb3QgPSB0cnVlO1xuICAgIHN5bnRheFRyZWUgPSBmdW5jKHN5bnRheFRyZWUpO1xuICB9KTtcblxuICByZXR1cm4gc3ludGF4VHJlZTtcblxuICBmdW5jdGlvbiBmaW5hbGl6ZVJvb3Qobm9kZSkge1xuICAgIGFubm90YXRlKG5vZGUsICdzZWxmJywgJ3JlYWQnKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFubm90YXRlTmVhcmVzdFBhcmVudChncm91cCwgbmFtZSwgbWF0Y2hlcikge1xuICAgIGZvciAoIHZhciBpID0gbm9kZVN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuICAgICAgdmFyIG5vZGUgPSBub2RlU3RhY2tbaV07XG4gICAgICBpZiAoIG1hdGNoZXIobm9kZSkgKSB7XG4gICAgICAgIGFubm90YXRlKG5vZGUsIGdyb3VwLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFubm90YXRlVXBUcmVlKGdyb3VwLCBuYW1lLCBtYXRjaGVyKSB7XG4gICAgdmFyIG1hdGNoZWQgPSBmYWxzZTtcbiAgICBlYWNoKG5vZGVTdGFjaywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoIG1hdGNoZXIoY2hpbGQpICkge1xuICAgICAgICBhbm5vdGF0ZShjaGlsZCwgZ3JvdXAsIG5hbWUpO1xuICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV3cml0ZU5vZGVzKG5vZGUsIHByb2Nlc3NvciwgbWF0Y2hlcikge1xuICAgIHJldHVybiByZXdyaXRlKG5vZGUpO1xuXG4gICAgZnVuY3Rpb24gcmV3cml0ZShub2RlKSB7XG4gICAgICBpZiAoIGlzQXJyYXkobm9kZSkgKSB7XG4gICAgICAgIC8vIERlcHRoLWZpcnN0IFByb2Nlc3NpbmdcbiAgICAgICAgbm9kZVN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgIHNlbGZNYXAobm9kZSwgcmV3cml0ZSk7XG4gICAgICAgIG5vZGVTdGFjay5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93IHRoZSByZWFsIHdvcmtcbiAgICAgIGlmICggbWF0Y2hlcihub2RlKSApIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3Nvcihub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bWJvbHMocHJvY2Vzc29yLCBtYXRjaGVyKSB7XG4gICAgcmV0dXJuIHJld3JpdGU7XG5cbiAgICBmdW5jdGlvbiByZXdyaXRlKG5vZGUpIHtcbiAgICAgIHJldHVybiByZXdyaXRlTm9kZXMobm9kZSwgcHJvY2Vzc29yLCBzeW1ib2xNYXRjaGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzeW1ib2xNYXRjaGVyKG5vZGUpIHtcbiAgICAgIHJldHVybiBpc1N5bWJvbChub2RlKSAmJiBtYXRjaGVyKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZXJhdG9ycyhwcm9jZXNzb3IsIG1hdGNoZXIpIHtcbiAgICByZXR1cm4gcmV3cml0ZTtcblxuICAgIGZ1bmN0aW9uIHJld3JpdGUobm9kZSkge1xuICAgICAgcmV0dXJuIHJld3JpdGVOb2Rlcyhub2RlLCBwcm9jZXNzb3IsIG9wZXJhdG9yTWF0Y2hlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3BlcmF0b3JNYXRjaGVyKG5vZGUpIHtcbiAgICAgIHJldHVybiBoYXNPcGVyYXRvcihub2RlKSAmJiBtYXRjaGVyKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRlbWVudHMocHJvY2Vzc29yKSB7XG4gICAgcmV0dXJuIHJld3JpdGU7XG5cbiAgICBmdW5jdGlvbiByZXdyaXRlKG5vZGUpIHtcbiAgICAgIHJldHVybiByZXdyaXRlTm9kZXMobm9kZSwgc3RhdGVtZW50c1Byb2Nlc3NvciwgaXNTdGF0ZW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGF0ZW1lbnRzUHJvY2Vzc29yKG5vZGUpIHtcbiAgICAgIHJldHVybiBzdG10cyhwcm9jZXNzb3Iobm9kZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEl0ZXJhdGVzIG92ZXIgYSBzZXQgb2Ygc3RhdGVtZW50cyBhbmQgcHJlc2VudHMgYWRqYWNlbnQgZ3JvdXBzXG4gIC8vIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgcmVwbGFjZW1lbnRcbiAgZnVuY3Rpb24gZ3JvdXBzKHByb2Nlc3NvciwgbWF0Y2hlcikge1xuICAgIHJldHVybiBzdGF0ZW1lbnRzKGdyb3VwUHJvY2Vzc29yKTtcblxuICAgIGZ1bmN0aW9uIGdyb3VwUHJvY2Vzc29yKHN0YXRlbWVudHMpIHtcbiAgICAgIHZhciBncm91cCA9IFtdO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgICBlYWNoKHN0YXRlbWVudHMsIGZ1bmN0aW9uIChzdGF0ZW1lbnQpIHtcbiAgICAgICAgaWYgKCBtYXRjaGVyKHN0YXRlbWVudCkgKSB7XG4gICAgICAgICAgZ3JvdXAucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3NNYXRjaGVzKCk7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHByb2Nlc3NNYXRjaGVzKCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzTWF0Y2hlcygpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdyb3VwLmxlbmd0aCA8IDIgPyBncm91cCA6IHByb2Nlc3Nvcihncm91cCk7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5jb25jYXQocmVzdWx0KTtcbiAgICAgICAgZ3JvdXAgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXJOb2Rlcyhub2RlKSB7XG4gICAgdmFyIGZvcm1hdHRlciA9IG5vZGUuZm9ybWF0dGVyO1xuICAgIHZhciByZXN1bHQgPSBbc3ltKCdmbScsIG5vZGUpLCBub2RlXTtcblxuICAgIHZhciByZXF1aXJlZEZ1bmN0aW9ucyA9IGZvcm1hdHRlci5fX2ludFJlcXVpcmVkRnVuY3Rpb25zIHx8IFtdO1xuICAgIHZhciByZXF1aXJlZEluZGV4ZXMgPSBub2RlLmZvcm1hdHRlci5fX2ludFJlcXVpcmVkSW5kZXhlcyB8fCBbXTtcblxuICAgIGlmICggIXJlcXVpcmVkSW5kZXhlcy5sZW5ndGggKSB7XG4gICAgICAvLyBIdWg/ICBJc3N1ZSBhIHdhcm5pbmchXG4gICAgICBpc3N1ZVdhcm5pbmcobm9kZVswXSxcbiAgICAgICAgXCJBdHRlbXB0IHRvIHBlcmZvcm0gaW50ZXJwb2xhdGlvbiBhZ2FpbnN0IHN0cmluZyB3aXRoIG5vIGVzY2FwaW5nXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBpZiAoIHJlcXVpcmVkRnVuY3Rpb25zLmxlbmd0aCApIHtcbiAgICAgIC8vIGJ1aWxkIGEgZGljdGlvbmFyeSBmcm9tIHRoZSBuYW1lc1xuICAgICAgdmFyIHN1cHBvcnRGdW5jRWxlbXMgPSBtYXAocmVxdWlyZWRGdW5jdGlvbnMsIGZ1bmN0aW9uIChmdW5jTmFtZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHN5bShmdW5jTmFtZSwgJ2lkJyksXG4gICAgICAgICAgW3N5bSgnaWQnKSwgc3ltKGZ1bmNOYW1lLCAnbGl0JyldXG4gICAgICAgIF07XG4gICAgICB9KTtcbiAgICAgIHJlc3VsdC5wdXNoKFtzeW0oJ2RjJyksIHN1cHBvcnRGdW5jRWxlbXNdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChzeW0oe30sICdsaXQnKSk7XG4gICAgfVxuXG4gICAgcmVzdWx0LmZvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYW4gJ2lmJyBzdGF0ZW1lbnQgaXMgZXZhbHVhdGluZyBhIGNvbnN0YW50LCB0aGVuIHdlIGNhbiBlbGltaW5hdGVcbiAgLy8gdGhlIGluYXBwbGljYWJsZSBicmFuY2ggYW5kIGp1c3QgaW5saW5lIHRoZSBtYXRjaGluZyBzdGF0ZW1lbnRzXG4gIGZ1bmN0aW9uIGZvbGRJZlN0YXRlbWVudHMoc3RhdGVtZW50cykge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICBlYWNoKHN0YXRlbWVudHMsIGZ1bmN0aW9uIChzdGF0ZW1lbnQpIHtcbiAgICAgIGlmICggIWhhc09wZXJhdG9yKHN0YXRlbWVudCwgJ2lmJykgfHwgIWlzTGl0ZXJhbChzdGF0ZW1lbnRbMV0pICkge1xuICAgICAgICBvdXRwdXQucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gaXNUcnV0aHkoc3RhdGVtZW50WzFdLnZhbHVlKSA/IHN0YXRlbWVudFsyXSA6IHN0YXRlbWVudFszXTtcbiAgICAgIG91dHB1dCA9IG91dHB1dC5jb25jYXQocmVzdWx0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgLy8gSG9pc3RpbmcgKm9ubHkqIG9jY3VycyB3aGVuIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlzIG1ldDpcbiAgLy9cbiAgLy8gICAoIXBhcnRpYWxfZGVmaW5pdGlvbikrXG4gIC8vICAgcGFydGlhbF9kZWZpbml0aW9uK1xuICAvL1xuICAvLyBtZWFuaW5nIHRoYXQgcGFydGlhbCBkZWZpbml0aW9ucyBjYW4ndCBiZSBpbnRlcnNwZXJzZWQgd2l0aFxuICAvLyByZWd1bGFyIHN0YXRlbWVudHMuICBJbiB0aGF0IGNhc2UsIHRoZSBsb2dpYyBpcyBhc3N1bWVkIHRvb1xuICAvLyBjb21wbGV4IHRvIG1ha2UgYSByZXNwb25zaWJsZSBndWVzcyBhcyB0byB0aGUgZGV2ZWxvcGVyJ3NcbiAgLy8gaW50ZW50aW9ucy5cbiAgZnVuY3Rpb24gaG9pc3RQYXJ0aWFscyhzdGF0ZW1lbnRzKSB7XG4gICAgaWYgKCBzdGF0ZW1lbnRzLmxlbmd0aCA8IDIgKSB7XG4gICAgICByZXR1cm4gc3RhdGVtZW50cztcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbHMgPSBbXTtcbiAgICB2YXIgb3RoZXJzID0gW107XG4gICAgdmFyIGludmFsaWQ7XG5cbiAgICBlYWNoKHN0YXRlbWVudHMsIGZ1bmN0aW9uIChzdGF0ZW1lbnQpIHtcbiAgICAgIGlmICggaGFzT3BlcmF0b3Ioc3RhdGVtZW50LCAnZGUnKSApIHtcbiAgICAgICAgaWYgKCAhaW52YWxpZCAmJiAhb3RoZXJzLmxlbmd0aCApIHtcbiAgICAgICAgICAvLyBFaXRoZXIgYWxsIHBhcnRpYWxzIG9yIHdlIGRvbid0IG1lZXQgaG9pc3RpbmcgY29uZGl0aW9uc1xuICAgICAgICAgIGludmFsaWQgPSBzdGF0ZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFydGlhbHMucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICggIWludmFsaWQgJiYgcGFydGlhbHMubGVuZ3RoICkge1xuICAgICAgICAgIC8vIFdlIGRvbid0IGhvaXN0IHVuZGVyIHRoZXNlIGNvbmRpdGlvbnNcbiAgICAgICAgICBpbnZhbGlkID0gcGFydGlhbHNbcGFydGlhbHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJzLnB1c2goc3RhdGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICggaW52YWxpZCApIHtcbiAgICAgIGlmICggb3RoZXJzLmxlbmd0aCApIHtcbiAgICAgICAgaXNzdWVXYXJuaW5nKGludmFsaWRbMF0sXG4gICAgICAgICAgXCJXaWxsIG9ubHkgcGVyZm9ybSAnaG9pc3RpbmcnIGlmIGFsbCBwYXJ0aWFscyBhcmUgcGxhY2VkIGFmdGVyIFwiICtcbiAgICAgICAgICBcIm90aGVyIHN0YXRlbWVudHNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWFscy5jb25jYXQob3RoZXJzKTtcbiAgfVxuXG4gIC8vIFdlIGNhbiBjb21iaW5lIG11bHRpcGxlIHNlcXVlbnRpYWwgY29tcGF0aWJsZSBwYXJ0aWFscyBpbnRvIGFcbiAgLy8gc2luZ2xlIGJyYW5jaGVkIHBhcnRpYWxcbiAgZnVuY3Rpb24gbWVyZ2VQYXJ0aWFscyhzdGF0ZW1lbnRzKSB7XG4gICAgdmFyIG5hbWVkRGVmcyA9IHt9O1xuICAgIGVhY2goc3RhdGVtZW50cywgZnVuY3Rpb24gKHN0YXRlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBzdGF0ZW1lbnRbMV0udmFsdWU7XG4gICAgICB2YXIgZ3JvdXAgPSBuYW1lZERlZnNbbmFtZV0gfHwgKCBuYW1lZERlZnNbbmFtZV0gPSBbXSApO1xuXG4gICAgICBpZiAoICFzdGF0ZW1lbnRbNF0gJiYgZ3JvdXAubGVuZ3RoICkge1xuICAgICAgICAvLyBpZiB3ZSBzZWUgYW4gdW5ndWFyZGVkLCBibG93IGF3YXkgcHJldmlvdXMgZGVmaW5pdGlvbnNcbiAgICAgICAgaXNzdWVXYXJuaW5nKHN0YXRlbWVudFswXSxcbiAgICAgICAgICBcIlRoZSB1bmd1YXJkZWQgUGFydGlhbCAnXCIgKyBuYW1lICsgXCInIHdpbGwgcmVwbGFjZSBcIiArXG4gICAgICAgICAgXCJhbnkgcHJldmlvdXMgZGVmaW5pdGlvbnNcIlxuICAgICAgICApO1xuICAgICAgICBncm91cCA9IFtdO1xuICAgICAgfVxuXG4gICAgICBncm91cC5wdXNoKHN0YXRlbWVudCk7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICggdmFyIGtleSBpbiBuYW1lZERlZnMgKSB7XG4gICAgICB2YXIgZGVmaW5pdGlvbnMgPSBuYW1lZERlZnNba2V5XTtcbiAgICAgIGlmICggZGVmaW5pdGlvbnMubGVuZ3RoID09PSAxICkge1xuICAgICAgICByZXN1bHQucHVzaChkZWZpbml0aW9uc1swXSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChtZXJnZURlZmluaXRpb25zKGtleSwgZGVmaW5pdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGZ1bmN0aW9uIG1lcmdlRGVmaW5pdGlvbnMobmFtZSwgZGVmaW5pdGlvbnMpIHtcbiAgICAgIHZhciBmaXJzdERlZmluaXRpb24gPSBkZWZpbml0aW9uc1swXTtcbiAgICAgIHZhciBvcmlnaW5hbEFyZ3MgPSBhcmd1bWVudHNTaWduYXR1cmUoZmlyc3REZWZpbml0aW9uWzJdKTtcbiAgICAgIHZhciBzdGF0ZW1lbnRzID0gZmlyc3REZWZpbml0aW9uWzNdO1xuICAgICAgdmFyIGd1YXJkID0gZmlyc3REZWZpbml0aW9uWzRdO1xuXG4gICAgICBpZiAoIGd1YXJkICkge1xuICAgICAgICBzdGF0ZW1lbnRzID0gW1xuICAgICAgICAgIFtzeW0oJ2lmJyksIGd1YXJkLCBzdGF0ZW1lbnRzLCBbXV1cbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGkgPSAxLCBsZW4gPSBkZWZpbml0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgdmFyIGRlZmluaXRpb24gPSBkZWZpbml0aW9uc1tpXTtcbiAgICAgICAgdmFyIHRoZXNlQXJncyA9IGFyZ3VtZW50c1NpZ25hdHVyZShkZWZpbml0aW9uWzJdKTtcbiAgICAgICAgaWYgKCBvcmlnaW5hbEFyZ3MgIT09IHRoZXNlQXJncyApIHtcbiAgICAgICAgICAvLyBTaG9ydC1jaXJjdWl0LCB3b24ndCBtYWtlIGFzc3VtcHRpb25zIGFib3V0IGxvY2FsIG5hbWVzXG4gICAgICAgICAgaXNzdWVXYXJuaW5nKGRlZmluaXRpb25bMF0sXG4gICAgICAgICAgICBcIlJlb3BlbmVkIHBhcnRpYWwgJ1wiICsgbmFtZSArIFwiJyBoYXMgZGlmZmVyZW50IFwiICtcbiAgICAgICAgICAgIFwiYXJndW1lbnQgbmFtZXMgdGhhbiB0aGUgb3JpZ2luYWwgZGVmaW5pdGlvblwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhlc2VTdGF0ZW1lbnRzID0gZGVmaW5pdGlvblszXTtcbiAgICAgICAgdmFyIHRoaXNHdWFyZCA9IGRlZmluaXRpb25bNF07XG5cbiAgICAgICAgc3RhdGVtZW50cyA9IFtcbiAgICAgICAgICBbc3ltKCdpZicpLCB0aGlzR3VhcmQsIHRoZXNlU3RhdGVtZW50cywgc3RhdGVtZW50c11cbiAgICAgICAgXTtcbiAgICAgICAgZ3VhcmQgPSBndWFyZCAmJiBbc3ltKCdvcicpLCB0aGlzR3VhcmQsIGd1YXJkXTtcbiAgICAgIH1cblxuICAgICAgZmlyc3REZWZpbml0aW9uWzNdID0gc3RhdGVtZW50cztcbiAgICAgIGlmICggZ3VhcmQgKSB7XG4gICAgICAgIGZpcnN0RGVmaW5pdGlvbls0XSA9IGd1YXJkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtmaXJzdERlZmluaXRpb25dO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoT3BzKG9wcykge1xuICAgIGlmICggIWlzQXJyYXkob3BzKSApIHtcbiAgICAgIG9wcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXI7XG5cbiAgICBmdW5jdGlvbiBtYXRjaGVyKG5vZGUpIHtcbiAgICAgIHJldHVybiBoYXNPcGVyYXRvcihub2RlLCBvcHMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoT3BzT3JSb290KG9wcykge1xuICAgIHZhciBvcHNNYXRjaGVyID0gbWF0Y2hPcHMob3BzKTtcbiAgICByZXR1cm4gbWF0Y2hlcjtcblxuICAgIGZ1bmN0aW9uIG1hdGNoZXIobm9kZSkge1xuICAgICAgdmFyIG9wID0gb3BzTWF0Y2hlcihub2RlKTtcbiAgICAgIGlmICggb3AgKSB7XG4gICAgICAgIHJldHVybiBvcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlLnJvb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gUGFydGlhbCBkZWNsYXJhdGlvbnMgYXJlIHJlYWxseSAnbGV0IG5hbWUgPSBwYXJ0aWFsJ1xuICBmdW5jdGlvbiBhc3NpZ25QYXJ0aWFscyhub2RlKSB7XG4gICAgcmV0dXJuIFsgc3ltKCdhcycpLCBbIFtub2RlWzFdLCBub2RlXSBdIF07XG4gIH1cblxuICAvLyBDb252ZXJ0IGxpdGVyYWwgb3V0cHV0IHRvIHByZS1lc2NhcGVkIHJhdyBvdXRwdXRcbiAgZnVuY3Rpb24gcHJvbW90ZVJhd0xpdGVyYWxPdXRwdXQobm9kZSkge1xuICAgIGlmICggIWlzTGl0ZXJhbChub2RlWzFdKSApIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICB2YXIgY29udGVudCA9IGVzY2FwZUNvbnRlbnQobm9kZVsxXS52YWx1ZSk7XG4gICAgcmV0dXJuIFtzeW0oJ3JhJyksIHN5bShjb250ZW50LCAnbGl0JyldO1xuICB9XG5cbiAgLy8gTGl0ZXJhbCBIVE1MIHRhZ3MgY2FuIGJlIGNvbnZlcnRlZCB0byByYXcgb3V0cHV0XG4gIGZ1bmN0aW9uIGNvbnZlcnRMaXRlcmFsSFRNTChub2RlKSB7XG4gICAgdmFyIG9wID0gaGFzT3BlcmF0b3Iobm9kZSk7XG4gICAgdmFyIHRhZyA9IGNyZWF0ZVRhZ1tvcF0obm9kZSk7XG4gICAgcmV0dXJuIHRhZyA/IFtzeW0oJ3JhJyksIHN5bSh0YWcsICdsaXQnKV0gOiBub2RlO1xuICB9XG5cbiAgLy8gV2UgY2FuIGNvbWJpbmUgc2VxdWVuY2VzIG9mIHJhdyBsaXRlcmFsIG91dHB1dFxuICBmdW5jdGlvbiBtZXJnZVJhd091dHB1dChzdGF0ZW1lbnRzKSB7XG4gICAgdmFyIGJ1ZmZlciA9IG1hcChzdGF0ZW1lbnRzLCBmdW5jdGlvbiAoc3RhdGVtZW50KSB7XG4gICAgICByZXR1cm4gc3RhdGVtZW50WzFdLnZhbHVlO1xuICAgIH0pLmpvaW4oJycpO1xuXG4gICAgcmV0dXJuIFsgW3N5bSgncmEnKSwgc3ltKGJ1ZmZlciwgJ2xpdCcpXSBdO1xuICB9XG5cbiAgZnVuY3Rpb24gYW5ub3RhdGVNdXRhdGlvbnMobm9kZSkge1xuICAgIGVhY2gobm9kZVsxXSwgZnVuY3Rpb24gKGFzc2lnbm1lbnQpIHtcbiAgICAgIGFubm90YXRlTmVhcmVzdFBhcmVudChcbiAgICAgICAgJ211dGF0aW9ucycsXG4gICAgICAgIGFzc2lnbm1lbnRbMF0udmFsdWUsXG4gICAgICAgIG1hdGNoT3BzT3JSb290KFsnZGUnLCAnZnInXSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyBXZSBjYW4gcm9sbCB1cCBhIHNpbmdsZSBuZXN0ZWQgZm9yIGxvb3AgaW50byBhIGNvbnRhaW5pbmcgZm9yXG4gIC8vIGxvb3Agc28gdGhhdCB0aGV5IHNoYXJlIHRoZSBzYW1lIGNvbnRleHRcbiAgZnVuY3Rpb24gcm9sbFVwRm9yTG9vcHMobm9kZSkge1xuICAgIHZhciBmb3JTdGF0ZW1lbnRzID0gbm9kZVsyXTtcblxuICAgIGlmICggZm9yU3RhdGVtZW50cy5sZW5ndGggIT09IDEgKSB7XG4gICAgICByZXR1cm4gbm9kZTsgIC8vIHNob3VsZCBvbmx5IGJlIG9uZSBjaGlsZFxuICAgIH1cbiAgICBpZiAoICFoYXNPcGVyYXRvcihmb3JTdGF0ZW1lbnRzWzBdLCAnZnInKSApIHtcbiAgICAgIHJldHVybiBub2RlOyAgLy8gc2hvdWxkIGhhdmUgYSBuZXN0ZWQgZm9yIGxvb3BcbiAgICB9XG5cbiAgICB2YXIgbmVzdGVkID0gZm9yU3RhdGVtZW50c1swXTtcbiAgICBpZiAoIG5vZGVbM10ubGVuZ3RoIHx8IG5lc3RlZFszXS5sZW5ndGggKSB7XG4gICAgICByZXR1cm4gbm9kZTsgIC8vIG5vIGVsc2UgY2xhdXNlc1xuICAgIH1cblxuICAgIG5vZGVbMV0gPSBub2RlWzFdLmNvbmNhdChuZXN0ZWRbMV0pO1xuICAgIG5vZGVbMl0gPSBuZXN0ZWRbMl07XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyBpZiBhIG1lbWJlciBvcGVyYXRvciBjb250YWlucyBhbm90aGVyIG1lbWJlciBvcGVyYXRvciwgaXQgY2FuIGJlIHJvbGxlZCBcbiAgLy8gdXAgaW50byBhIHNpbmdsZSBwYXRoIG9wZXJhdG9yXG4gIGZ1bmN0aW9uIHJvbGxVcE1lbWJlclBhdGhzKG5vZGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gbm9kZVsxXTtcbiAgICBpZiAoICFoYXNPcGVyYXRvcih0YXJnZXQsICdtYicpICkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHRhcmdldFsyXSA9IHRhcmdldFsyXS5jb25jYXQobm9kZVsyXSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8vIE9yLCBBbmQsIENvbmRpdGlvbmFsIEZvbGRpbmdcbiAgZnVuY3Rpb24gZm9sZFNob3J0Q2lyY3VpdHMobm9kZSkge1xuICAgIGlmICggIWlzTGl0ZXJhbChub2RlWzFdKSApIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICB2YXIgb3AgPSBoYXNPcGVyYXRvcihub2RlKTtcbiAgICB2YXIgYXJncyA9IG5vZGUuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHNob3J0Q2lyY3VpdEZvbGRlcnNbb3BdLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9XG4gIFxuICAvLyBTaW1wbGUgY29uc3RhbnQgZm9sZGluZ1xuICBmdW5jdGlvbiBmb2xkQ29uc3RhbnRzKG5vZGUpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAoIHZhciBpID0gMSwgbGVuID0gbm9kZS5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgIHZhciBhcmcgPSBub2RlW2ldO1xuICAgICAgaWYgKCAhaXNMaXRlcmFsKGFyZykgKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgYXJncy5wdXNoKGFyZy52YWx1ZSk7XG4gICAgfVxuICAgIHZhciBvcCA9IGhhc09wZXJhdG9yKG5vZGUpO1xuICAgIHZhciBvdXRwdXQgPSBjb25zdGFudEZvbGRlcnNbb3BdLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIHJldHVybiBzeW0ob3V0cHV0LCAnbGl0Jywgbm9kZVswXSk7XG4gIH1cbiAgXG4gIC8vIElmIHRoZSBjb25kaXRpb24gaXMgJ25vdCcgd2UgY2FuIHJvbGwgdXAgaXRzIGFyZ3VtZW50XG4gIC8vIGFuZCBmbGlwIHRoZSBicmFuY2hlcy5cbiAgZnVuY3Rpb24gZmxpcENvbmRpdGlvbmFscyhub2RlKSB7XG4gICAgdmFyIGNvbmQgPSBub2RlWzFdO1xuICAgIGlmICggIWhhc09wZXJhdG9yKGNvbmQsICdubycpICkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8vIE1ha2UgaXQgc29cbiAgICBub2RlWzFdID0gY29uZFsxXTtcbiAgICB2YXIgdG1wID0gbm9kZVsyXTtcbiAgICBub2RlWzJdID0gbm9kZVszXTtcbiAgICBub2RlWzNdID0gdG1wO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLy8gaWYgdGhlIG9wZXJhdG9yIGlzICdub3QnIGFuZCBpdCBjb250YWlucyBhbiBlcXVhbGl0eSxcbiAgLy8gdGhlbiB3ZSBjYW4gZmxpcCB0aGUgZXF1YWxpdHkgb3BlcmF0b3IgYW5kIHJvbGwgaXQgdXBcbiAgZnVuY3Rpb24gZmxpcEVxdWFsaXR5KG5vZGUpIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlWzFdO1xuICAgIHZhciBvcCA9IGhhc09wZXJhdG9yKGNoaWxkKTtcbiAgICB2YXIgbmV3T3AgPSBpbnZlcnNlT3BlcmF0b3JzW29wXTtcblxuICAgIGlmICggIW9wIHx8ICFuZXdPcCApIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGNoaWxkWzBdLnZhbHVlID0gbmV3T3A7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgLy8gSWYgbGVmdCBhbmQgcmlnaHQgb3BlcmFuZHMgb2YgYW4gJ2FuZCcgb3IgJ29yJyBhcmUgdXNpbmcgdGhlICdub3QnXG4gIC8vIHVuYXJ5LCB0aGVuIHByb21vdGUgaXQgdG8gdGhlIHRvcCBhbmQgZmxpcCB0aGUgYW5kL29yXG4gIGZ1bmN0aW9uIHByb21vdGVOb3Qobm9kZSkge1xuICAgIHZhciBsZWZ0ID0gbm9kZVsxXTtcbiAgICB2YXIgbGVmdE9wID0gaGFzT3BlcmF0b3IobGVmdCwgJ25vJyk7XG4gICAgdmFyIHJpZ2h0ID0gbm9kZVsyXTtcbiAgICB2YXIgcmlnaHRPcCA9IGhhc09wZXJhdG9yKHJpZ2h0LCAnbm8nKTtcblxuICAgIGlmICggIWxlZnRPcCB8fCAhcmlnaHRPcCApIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHZhciBvcCA9IGhhc09wZXJhdG9yKG5vZGUpO1xuICAgIHZhciBuZXdPcCA9IG9wID09PSAnYW4nICYmICdvcicgfHwgJ2FuJztcbiAgICByZXR1cm4gWyBzeW0oJ25vJywgbGVmdCksIFtzeW0obmV3T3AsIG5vZGUpLCBsZWZ0WzFdLCByaWdodFsxXV0gXTtcbiAgfVxuXG4gIC8vIElmIGFsbCB0aGUgZWxlbWVudHMgb2YgYW4gQXJyYXkgYXJlIGxpdGVyYWxzLCB0aGVuIHdlIGNhbiBjb252ZXJ0XG4gIC8vIHRoZSBsaXN0IHRvIGEgbGl0ZXJhbCBhcnJheSBmb3IgdGhlIGxpdGVyYWwgdGFibGVcbiAgZnVuY3Rpb24gbGl0ZXJhbEZyb21BcnJheShub2RlKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gbm9kZVsxXTtcbiAgICB2YXIgb3V0cHV0ID0gW107XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmICggIWlzTGl0ZXJhbChlbGVtZW50KSApIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBvdXRwdXQucHVzaChlbGVtZW50LnZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3ltKG91dHB1dCwgJ2xpdCcsIG5vZGVbMF0pO1xuICB9XG5cbiAgLy8gSWYgYWxsIHRoZSBlbGVtZW50cyBvZiBhIERpY3Rpb25hcnkgYXJlIGxpdGVyYWxzLCB0aGVuIHdlIGNhblxuICAvLyBjb252ZXJ0IHRoZSBsaXN0IHRvIGEgbGl0ZXJhbCBvYmplY3QgZm9yIHRoZSBsaXRlcmFsIHRhYmxlXG4gIGZ1bmN0aW9uIGxpdGVyYWxGcm9tRGljdGlvbmFyeShub2RlKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gbm9kZVsxXTtcbiAgICB2YXIgb3V0cHV0ID0ge307XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIHZhciBuYW1lID0gZWxlbWVudFswXTtcbiAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnRbMV07XG4gICAgICBpZiAoICghaXNJZGVudGlmaWVyKG5hbWUpICYmICFpc0xpdGVyYWwobmFtZSkpIHx8ICFpc0xpdGVyYWwodmFsdWUpICkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG91dHB1dFtuYW1lLnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBzeW0ob3V0cHV0LCAnbGl0Jywgbm9kZVswXSk7XG4gIH1cblxuICAvLyBJZiB0aGUgbGVmdCBzaWRlIG9mIGEgY2FsbCBpcyBhIGZvcm1hdHRlciwgdGhlbiB3ZSBjYW4gZ2VuZXJhdGUgY29kZVxuICAvLyB0aGF0IHdpbGwgaW1tZWRpYXRlbHkgcHJvdmlkZSB0aGUgZXZhbHVhdGVkIGV4cHJlc3Npb24gdG8gdGhhdCBmb3JtYXR0ZXJcbiAgLy8gaW5zdGVhZCBvZiBuZXN0aW5nIHRoZSBjYWxsc1xuICBmdW5jdGlvbiBpbW1lZGlhdGVJbnRlcnBvbGF0aW9uKG5vZGUpIHtcbiAgICB2YXIgbWVtYmVyID0gbm9kZVsxXTtcbiAgICBpZiAoICFoYXNPcGVyYXRvcihtZW1iZXIsICdmbScpICkge1xuICAgICAgLy8gTm90aGluZyB0byBkbyBoZXJlXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IG5vZGVbMl07XG4gICAgbWVtYmVyLnB1c2goYXJnc1swXSk7XG4gICAgcmV0dXJuIG1lbWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGZGb3JtYXRGcm9tRGljdGlvbmFyeShub2RlKSB7XG4gICAgaWYgKCBub2RlLmxlbmd0aCA9PT0gMyApIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHZhciBleHByID0gbm9kZVszXTtcbiAgICBpZiAoICFoYXNPcGVyYXRvcihleHByLCAnc2UnKSApIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHZhciByZXF1aXJlZEluZGV4ZXMgPSBub2RlLmZvcm1hdHRlci5fX2ludFJlcXVpcmVkSW5kZXhlcyB8fCBbXTtcbiAgICB2YXIgdmFyTmFtZUVsZW1zID0gbWFwKHJlcXVpcmVkSW5kZXhlcywgZnVuY3Rpb24gKHZhck5hbWUpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHN5bSh2YXJOYW1lLCAnaWQnKSxcbiAgICAgICAgW3N5bSgnaWQnKSwgc3ltKHZhck5hbWUsICdsaXQnKV1cbiAgICAgIF07XG4gICAgfSk7XG5cbiAgICBub2RlWzNdID0gW3N5bSgnZGMnKSwgdmFyTmFtZUVsZW1zXTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFubm90YXRlU2VsZlJlZmVyZW5jZXMobm9kZSkge1xuICAgIGFubm90YXRlVXBUcmVlKCdzZWxmJywgJ3JlYWQnLCBoYXNPcGVyYXRvcik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBpc3N1ZVdhcm5pbmcoc291cmNlLCBtZXNzYWdlKSB7XG4gICAgd2FybmluZ3MucHVzaCh7XG4gICAgICBsaW5lOiBzb3VyY2UubGluZSxcbiAgICAgIGNvbHVtbjogc291cmNlLmNvbHVtbixcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcmd1bWVudHNTaWduYXR1cmUoYXJnTmFtZXMpIHtcbiAgaWYgKCAhYXJnTmFtZXMgfHwgIWFyZ05hbWVzLmxlbmd0aCApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gbWFwKGFyZ05hbWVzLCBmdW5jdGlvbiAoYXJnTmFtZSkge1xuICAgIHJldHVybiBhcmdOYW1lLnZhbHVlO1xuICB9KS5qb2luKCcsJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9wZW5UYWcoc3RhdGVtZW50KSB7XG4gIGlmICggIWlzSWRlbnRpZmllcihzdGF0ZW1lbnRbMV0pICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0YWcgPSBbXCI8XCIsIHN0YXRlbWVudFsxXS52YWx1ZV07XG4gIHZhciBhdHRycyA9IHN0YXRlbWVudFsyXTtcbiAgaWYgKCBhdHRycyAmJiBhdHRycy5sZW5ndGggKSB7XG4gICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSBhdHRycy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgICBpZiAoICFpc0lkZW50aWZpZXIoYXR0clswXSkgfHwgIWlzTGl0ZXJhbChhdHRyWzFdKSApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsID0gYXR0clsxXS52YWx1ZTtcbiAgICAgIGlmICggdHlwZW9mIHZhbCAhPT0gJ2Jvb2xlYW4nICkge1xuICAgICAgICB2YXIgY29udGVudCA9IGVzY2FwZUF0dHJpYnV0ZSh2YWwpO1xuICAgICAgICB0YWcucHVzaChcIiBcIiwgYXR0clswXS52YWx1ZSwgXCI9XFxcIlwiLCBjb250ZW50LCBcIlxcXCJcIik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIHZhbCApIHtcbiAgICAgICAgdGFnLnB1c2goXCIgXCIsIGF0dHJbMF0udmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICggc3RhdGVtZW50WzNdICkge1xuICAgIHRhZy5wdXNoKFwiIC9cIik7XG4gIH1cbiAgdGFnLnB1c2goXCI+XCIpO1xuXG4gIHJldHVybiB0YWcuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsb3NlVGFnKHN0YXRlbWVudCkge1xuICBpZiAoICFpc0lkZW50aWZpZXIoc3RhdGVtZW50WzFdKSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIFtcIjwvXCIsIHN0YXRlbWVudFsxXS52YWx1ZSwgXCI+XCJdLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50VGFnKHN0YXRlbWVudCkge1xuICByZXR1cm4gW1wiPCEtLVwiLCBzdGF0ZW1lbnRbMV0udmFsdWUsIFwiLS0+XCJdLmpvaW4oJycpO1xufVxuXG4vLyBFeHBvcnRlZCBGdW5jdGlvbnNcbmV4cG9ydHMucmV3cml0ZVN5bnRheFRyZWUgPSByZXdyaXRlU3ludGF4VHJlZTtcbiIsIi8qXG4gKiBJbnRlcnBvbCAoTG9naWNmdWwgSFRNTCBUZW1wbGF0ZXMpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIHNlZSBkb2MvTElDRU5TRS5tZFxuICpcbiAqIEBhdXRob3IgVGhvbWFzIFMuIEJyYWRmb3JkIChrb2RlNGZvb2QuaXQpXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVGhpcyBpcyBhIHN0dWIgdGhhdCB3aWxsIGJlIHBvcHVsYXRlZCBieSB0aGUgJ3JlYWwnIGNvbXBpbGVyIGZ1bmN0aW9uYWxpdHlcbiAqIHNob3VsZCBpdCBiZSBsb2FkZWQgYnkgZWl0aGVyIG5vZGUuanMgb3IgQnJvd3NlcmlmeS4gIEl0J3MgaGVyZSBiZWNhdXNlXG4gKiB3ZSBzaG91bGRuJ3QgaGF2ZSB0byByZWx5IG9uIEJyb3dzZXJpZnkncyBgLS1pZ25vcmVgIG9wdGlvbi5cbiAqL1xuIiwiLypcbiAqIEludGVycG9sIChMb2dpY2Z1bCBIVE1MIFRlbXBsYXRlcylcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogc2VlIGRvYy9MSUNFTlNFLm1kXG4gKlxuICogQGF1dGhvciBUaG9tYXMgUy4gQnJhZGZvcmQgKGtvZGU0Zm9vZC5pdClcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxudmFyIG9iamVjdEtleXMgPSB1dGlsLm9iamVjdEtleXM7XG52YXIgZWFjaCA9IHV0aWwuZWFjaDtcbnZhciBzdHJpbmdpZnkgPSB0eXBlcy5zdHJpbmdpZnk7XG52YXIgaXNJbnRlcnBvbEZ1bmN0aW9uID0gdHlwZXMuaXNJbnRlcnBvbEZ1bmN0aW9uO1xuXG52YXIgRGlnaXRzID0gXCIwfFsxLTldWzAtOV0qXCI7XG52YXIgSWRlbnQgPSBcIlskX2EtekEtWl1bJF9hLXpBLVowLTldKlwiO1xudmFyIFBpcGVzID0gXCIoW3xdXCIgKyBJZGVudCArIFwiKSpcIjtcbnZhciBUZXJtID0gXCI7P1wiO1xudmFyIFBhcmFtcyA9IFwiJSgoJSl8KFwiICsgRGlnaXRzICsgXCIpfChcIiArIElkZW50ICsgXCIpKT8oXCIgKyBQaXBlcyArIFwiKT9cIiArIFRlcm07XG4gICAgICAgICAgICAgLyogXCIlXCIgKCBcIiVcIiB8IGRpZ2l0cyB8IGlkZW50aWZpZXIgKT8gKCBcInxcIiBpZGVudGlmaWVyICkqIFwiO1wiPyAqL1xuXG52YXIgUGFyYW1SZWdleCA9IG5ldyBSZWdFeHAoUGFyYW1zLCBcIm1cIik7XG5cbnZhciBudWxsV3JpdGVyID0gcmVxdWlyZSgnLi93cml0ZXJzL251bGwnKS5jcmVhdGVOdWxsV3JpdGVyKCk7XG5cbi8qKlxuICogQnVpbGRzIGEgY2xvc3VyZSB0aGF0IHdpbGwgYmUgdXNlZCBpbnRlcm5hbGx5IHRvIHN1cHBvcnQgSW50ZXJwb2wnc1xuICogaW50ZXJwb2xhdGlvbiBvcGVyYXRpb25zLiAgVGhlIHJldHVybmVkIGNsb3N1cmUgd2lsbCBhdHRhY2ggZmxhZ3NcbiAqIHRoYXQgaWRlbnRpZnkgYW55IG5hbWVzIG9yIGluZGV4ZXMgdGhhdCBtdXN0IGJlIHByb3ZpZGVkIGJ5IGludGVycG9sXG4gKiB0byBmdWxmaWxsIGl0cyBmb3JtYXR0aW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRTdHIgdGhlIFN0cmluZyB0byBiZSB1c2VkIGZvciBpbnRlcnBvbGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0dGVyKGZvcm1hdFN0cikge1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICB2YXIgcmVxdWlyZWRJbmRleGVzID0ge307XG4gIHZhciByZXF1aXJlZEZ1bmN0aW9ucyA9IHt9O1xuICB2YXIgY2xlbiA9IDA7XG4gIHZhciBhdXRvSWR4ID0gMDtcblxuICB2YXIgd29ya1N0ciA9IGZvcm1hdFN0cjtcbiAgd2hpbGUgKCB3b3JrU3RyICYmIHdvcmtTdHIubGVuZ3RoICkge1xuICAgIHZhciBwYXJhbU1hdGNoID0gUGFyYW1SZWdleC5leGVjKHdvcmtTdHIpO1xuICAgIGlmICggIXBhcmFtTWF0Y2ggKSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goY3JlYXRlTGl0ZXJhbENvbXBvbmVudCh3b3JrU3RyKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSBwYXJhbU1hdGNoWzBdO1xuICAgIHZhciBtYXRjaElkeCA9IHBhcmFtTWF0Y2guaW5kZXg7XG4gICAgdmFyIG1hdGNoTGVuID0gbWF0Y2gubGVuZ3RoO1xuXG4gICAgaWYgKCBtYXRjaElkeCApIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaChjcmVhdGVMaXRlcmFsQ29tcG9uZW50KHdvcmtTdHIuc3Vic3RyaW5nKDAsIG1hdGNoSWR4KSkpO1xuICAgIH1cblxuICAgIGlmICggcGFyYW1NYXRjaFsyXSA9PT0gJyUnICkge1xuICAgICAgY29tcG9uZW50cy5wdXNoKGNyZWF0ZUxpdGVyYWxDb21wb25lbnQoJyUnKSk7XG4gICAgICB3b3JrU3RyID0gd29ya1N0ci5zdWJzdHJpbmcobWF0Y2hJZHggKyBtYXRjaExlbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaWR4ID0gYXV0b0lkeCsrO1xuICAgIGlmICggcGFyYW1NYXRjaFs0XSApIHtcbiAgICAgIGlkeCA9IHBhcmFtTWF0Y2hbNF07XG4gICAgfVxuICAgIGVsc2UgaWYgKCBwYXJhbU1hdGNoWzNdICkge1xuICAgICAgaWR4ID0gcGFyc2VJbnQocGFyYW1NYXRjaFszXSwgMTApO1xuICAgIH1cbiAgICByZXF1aXJlZEluZGV4ZXNbaWR4XSA9IHRydWU7XG5cbiAgICBpZiAoIHBhcmFtTWF0Y2hbNV0gKSB7XG4gICAgICB2YXIgZm9ybWF0dGVycyA9IHBhcmFtTWF0Y2hbNV0uc2xpY2UoMSkuc3BsaXQoJ3wnKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChjcmVhdGVQaXBlZENvbXBvbmVudChpZHgsIGZvcm1hdHRlcnMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goY3JlYXRlSW5kZXhlZENvbXBvbmVudChpZHgpKTtcbiAgICB9XG5cbiAgICB3b3JrU3RyID0gd29ya1N0ci5zdWJzdHJpbmcobWF0Y2hJZHggKyBtYXRjaExlbik7XG4gIH1cbiAgY2xlbiA9IGNvbXBvbmVudHMubGVuZ3RoO1xuXG4gIGZvcm1hdEZ1bmN0aW9uLl9faW50UmVxdWlyZWRJbmRleGVzID0gb2JqZWN0S2V5cyhyZXF1aXJlZEluZGV4ZXMpO1xuICBmb3JtYXRGdW5jdGlvbi5fX2ludFJlcXVpcmVkRnVuY3Rpb25zID0gb2JqZWN0S2V5cyhyZXF1aXJlZEZ1bmN0aW9ucyk7XG4gIGZvcm1hdEZ1bmN0aW9uLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gIHJldHVybiBmb3JtYXRGdW5jdGlvbjtcblxuICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZm9ybWF0U3RyO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RnVuY3Rpb24oc3VwcG9ydEZ1bmN0aW9ucywgd3JpdGVyLCBkYXRhKSB7XG4gICAgaWYgKCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PT0gbnVsbCApIHtcbiAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGNsZW47IGkrKyApIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgc3dpdGNoICggY29tcG9uZW50WzBdICkge1xuICAgICAgICBjYXNlIDA6IHJlc3VsdCArPSBjb21wb25lbnRbMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDE6IHJlc3VsdCArPSBzdHJpbmdpZnkoZGF0YVtjb21wb25lbnRbMV1dKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogcmVzdWx0ICs9IGNvbXBvbmVudFsxXShkYXRhLCBzdXBwb3J0RnVuY3Rpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUxpdGVyYWxDb21wb25lbnQobGl0ZXJhbCkge1xuICAgIHJldHVybiBbMCwgbGl0ZXJhbF07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbmRleGVkQ29tcG9uZW50KGlkeCkge1xuICAgIHJldHVybiBbMSwgaWR4XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBpcGVkQ29tcG9uZW50KGlkeCwgZm9ybWF0dGVycykge1xuICAgIHZhciBmdW5jcyA9IGZvcm1hdHRlcnMucmV2ZXJzZSgpO1xuICAgIHZhciBmbGVuID0gZnVuY3MubGVuZ3RoIC0gMTtcblxuICAgIC8vIFJlZ2lzdGVyIHJlcXVpcmVtZW50IG9uIHRoZXNlIGZvcm1hdHRlcnNcbiAgICBlYWNoKGZ1bmNzLCBmdW5jdGlvbiAoZnVuY05hbWUpIHtcbiAgICAgIHJlcXVpcmVkRnVuY3Rpb25zW2Z1bmNOYW1lXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gWzIsIHBpcGVkRnVuY3Rpb25dO1xuXG4gICAgZnVuY3Rpb24gcGlwZWRGdW5jdGlvbihkYXRhLCBzdXBwb3J0RnVuY3Rpb25zKSB7XG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW2lkeF07XG4gICAgICBmb3IgKCB2YXIgaSA9IGZsZW47IGkgPj0gMDsgaS0tICkge1xuICAgICAgICB2YXIgZnVuY05hbWUgPSBmdW5jc1tpXTtcbiAgICAgICAgdmFyIGZ1bmMgPSBzdXBwb3J0RnVuY3Rpb25zW2Z1bmNOYW1lXTtcblxuICAgICAgICBpZiAoICFpc0ludGVycG9sRnVuY3Rpb24oZnVuYykgKSB7XG4gICAgICAgICAgaWYgKCBzdXBwb3J0RnVuY3Rpb25zLl9faW50RXhwb3J0cyApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0aW5nIHRvIGNhbGwgYW4gdW5ibGVzc2VkIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBmdW5jKG51bGxXcml0ZXIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZERlZmVycmVkRm9ybWF0dGVyKGZvcm1hdFN0ciwgc3VwcG9ydEZ1bmN0aW9ucykge1xuICB2YXIgZm9ybWF0dGVyID0gYnVpbGRGb3JtYXR0ZXIoZm9ybWF0U3RyKTtcbiAgc3VwcG9ydGVkRm9ybWF0dGVyLl9faW50RnVuY3Rpb24gPSAnZm9ybWF0JztcbiAgc3VwcG9ydGVkRm9ybWF0dGVyLnRvU3RyaW5nID0gZm9ybWF0dGVyLnRvU3RyaW5nO1xuICBpZiAoIHN1cHBvcnRGdW5jdGlvbnMgIT09IHVuZGVmaW5lZCApIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkRm9ybWF0dGVyO1xuICB9XG4gIHJldHVybiBkZWZlcnJlZEZvcm1hdHRlcjtcblxuICBmdW5jdGlvbiBzdXBwb3J0ZWRGb3JtYXR0ZXIod3JpdGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGZvcm1hdHRlcihzdXBwb3J0RnVuY3Rpb25zLCB3cml0ZXIsIGRhdGEpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBkZWZlcnJlZEZvcm1hdHRlcihfc3VwcG9ydEZ1bmN0aW9ucykge1xuICAgIHN1cHBvcnRGdW5jdGlvbnMgPSBfc3VwcG9ydEZ1bmN0aW9ucztcbiAgICByZXR1cm4gc3VwcG9ydGVkRm9ybWF0dGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkSW1tZWRpYXRlRm9ybWF0dGVyKGZvcm1hdFN0ciwgc3VwcG9ydEZ1bmN0aW9ucykge1xuICB2YXIgZm9ybWF0dGVyID0gYnVpbGRGb3JtYXR0ZXIoZm9ybWF0U3RyKTtcbiAgaWYgKCBzdXBwb3J0RnVuY3Rpb25zICE9PSB1bmRlZmluZWQgKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZEZvcm1hdHRlcjtcbiAgfVxuICByZXR1cm4gaW1tZWRpYXRlRm9ybWF0dGVyO1xuXG4gIGZ1bmN0aW9uIHN1cHBvcnRlZEZvcm1hdHRlcihkYXRhKSB7XG4gICAgcmV0dXJuIGZvcm1hdHRlcihzdXBwb3J0RnVuY3Rpb25zLCB1bmRlZmluZWQsIGRhdGEpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBpbW1lZGlhdGVGb3JtYXR0ZXIoc3VwcG9ydEZ1bmN0aW9ucywgZGF0YSkge1xuICAgIHJldHVybiBmb3JtYXR0ZXIoc3VwcG9ydEZ1bmN0aW9ucywgdW5kZWZpbmVkLCBkYXRhKTtcbiAgfVxufVxuXG4vLyBFeHBvcnRlZCBGdW5jdGlvbnNcbmV4cG9ydHMuYnVpbGRGb3JtYXR0ZXIgPSBidWlsZEZvcm1hdHRlcjtcbmV4cG9ydHMuYnVpbGREZWZlcnJlZEZvcm1hdHRlciA9IGJ1aWxkRGVmZXJyZWRGb3JtYXR0ZXI7XG5leHBvcnRzLmJ1aWxkSW1tZWRpYXRlRm9ybWF0dGVyID0gYnVpbGRJbW1lZGlhdGVGb3JtYXR0ZXI7XG4iLCIvKlxuICogSW50ZXJwb2wgKExvZ2ljZnVsIEhUTUwgVGVtcGxhdGVzKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBzZWUgZG9jL0xJQ0VOU0UubWRcbiAqXG4gKiBAYXV0aG9yIFRob21hcyBTLiBCcmFkZm9yZCAoa29kZTRmb29kLml0KVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xudmFyIGNvbXBpbGVyID0gcmVxdWlyZSgnLi9jb21waWxlci9zdHViJyk7XG52YXIgcnVudGltZSA9IHJlcXVpcmUoJy4vcnVudGltZScpO1xuXG52YXIgaXNBcnJheSA9IHV0aWwuaXNBcnJheTtcbnZhciBibGVzcyA9IHR5cGVzLmJsZXNzO1xuXG52YXIgY3JlYXRlUnVudGltZSA9IHJ1bnRpbWUuY3JlYXRlUnVudGltZTtcbnZhciBjb21waWxlTW9kdWxlO1xudmFyIGdlbmVyYXRlRnVuY3Rpb247XG5cbnZhciBDVVJSRU5UX1ZFUlNJT04gPSBcIjEuMy4wXCI7XG5cbi8vIEJvb3RzdHJhcFxuXG5pbnRlcnBvbC5WRVJTSU9OID0gQ1VSUkVOVF9WRVJTSU9OO1xuaW50ZXJwb2wuYmxlc3MgPSBibGVzcztcbmludGVycG9sLmV2YWx1YXRlID0gZXZhbHVhdGU7XG5pbnRlcnBvbC5jb21waWxlID0gY29tcGlsZTtcbmludGVycG9sLnJ1bnRpbWUgPSBnZXRSdW50aW1lO1xuaW50ZXJwb2wuc3RvcEl0ZXJhdGlvbiA9IHR5cGVzLnN0b3BJdGVyYXRpb247XG5cbi8vIENvcmUgSW50ZXJwb2wgSW1wbGVtZW50YXRpb25cblxudmFyIGdsb2JhbFJ1bnRpbWUgPSBjcmVhdGVSdW50aW1lKGludGVycG9sKTtcblxuLyoqXG4gKiBNYWluIEludGVycG9sIGVudHJ5IHBvaW50LiAgVGFrZXMgYSB0ZW1wbGF0ZSBhbmQgcmV0dXJucyBhIGNsb3N1cmVcbiAqIGZvciByZW5kZXJpbmcgaXQuICBUaGUgdGVtcGxhdGUgbXVzdCBiZSBhIFN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGUgdGhlIHRlbXBsYXRlIHRvIGJlIGNvbXBpbGVkXG4gKiBAcGFyYW0ge1J1bnRpbWV9IFtydW50aW1lXSBSdW50aW1lIEluc3RhbmNlIChvciBjb25maWcgT2JqZWN0KVxuICovXG5mdW5jdGlvbiBpbnRlcnBvbCh0ZW1wbGF0ZSwgcnVudGltZSkge1xuICBpZiAoIHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidGVtcGxhdGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgfVxuXG4gIHJ1bnRpbWUgPSBnZXRSdW50aW1lKHJ1bnRpbWUpO1xuICB2YXIgb3B0aW9ucyA9IHJ1bnRpbWUub3B0aW9ucztcblxuICB2YXIgY29tcGlsZWRPdXRwdXQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKS50ZW1wbGF0ZUJvZHk7XG4gIHZhciB3cmFwcGVyID0gZ2VuZXJhdGVGdW5jdGlvbihjb21waWxlZE91dHB1dCk7XG4gIHJldHVybiB3cmFwcGVyKHJ1bnRpbWUpO1xufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGNvbXBpbGUgYW5kIGV4ZWN1dGUgYSB0ZW1wbGF0ZSBhZ2FpbnN0IGEgY29udGV4dFxuICogT2JqZWN0IGFuZCBvcHRpb25zLiAgTm90IGdlbmVyYWxseSByZWNvbW1lbmRlZC5cbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGUoc2NyaXB0LCBvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGNvbXBpbGVkID0gaW50ZXJwb2woc2NyaXB0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbXBpbGVkKG9iaiwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogSW52b2tlcyB0aGUgSW50ZXJwb2wgY29tcGlsZXIgYWdhaW5zdCB0aGUgc3BlY2lmaWVkIHRlbXBsYXRlIGFuZCBwcm9kdWNlc1xuICogYW4gT2JqZWN0IHRoYXQgaW5jbHVkZXMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGdlbmVyYXRvciBhbmQgYW55IGVycm9ycyBvclxuICogd2FybmluZ3MuICBUaGUgY29tcGlsZXIgbW9kdWxlIGhhcyB0byBiZSBsb2FkZWQgZm9yIHRoaXMgdG8gd29yay5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGUgdGhlIEludGVycG9sIFRlbXBsYXRlIHRvIGJlIGNvbXBpbGVkXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKCAhY29tcGlsZU1vZHVsZSApIHtcbiAgICBpZiAoIHR5cGVvZiBjb21waWxlci5jb21waWxlTW9kdWxlICE9PSAnZnVuY3Rpb24nICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIEludGVycG9sIGNvbXBpbGVyIHdhcyBuZXZlciBsb2FkZWRcIik7XG4gICAgfVxuICAgIGNvbXBpbGVNb2R1bGUgPSBjb21waWxlci5jb21waWxlTW9kdWxlO1xuICAgIGdlbmVyYXRlRnVuY3Rpb24gPSBjb21waWxlci5nZW5lcmF0ZUZ1bmN0aW9uO1xuICB9XG4gIHJldHVybiBjb21waWxlTW9kdWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IFJ1bnRpbWUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuICBJZiBubyBvcHRpb25zIGFyZVxuICogcHJvdmlkZWQsIHdpbGwgcmV0dXJuIHRoZSBnbG9iYWwgUnVudGltZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGNvbmZpZ3VyYXRpb24gT2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldFJ1bnRpbWUob3B0aW9ucykge1xuICBpZiAoICFvcHRpb25zICkge1xuICAgIHJldHVybiBnbG9iYWxSdW50aW1lO1xuICB9XG4gIHJldHVybiBjcmVhdGVSdW50aW1lKGludGVycG9sLCBvcHRpb25zKTtcbn1cblxuLy8gRXhwb3J0ZWQgRnVuY3Rpb25zXG5tb2R1bGUuZXhwb3J0cyA9IGludGVycG9sO1xuIiwiLypcbiAqIEludGVycG9sIChMb2dpY2Z1bCBIVE1MIFRlbXBsYXRlcylcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogc2VlIGRvYy9MSUNFTlNFLm1kXG4gKlxuICogQGF1dGhvciBUaG9tYXMgUy4gQnJhZGZvcmQgKGtvZGU0Zm9vZC5pdClcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBpc0FycmF5ID0gdXRpbC5pc0FycmF5O1xudmFyIG9iamVjdEtleXMgPSB1dGlsLm9iamVjdEtleXM7XG5cbi8qKlxuICogQmFzaWMgT2JqZWN0IE1hdGNoZXIgdG8gc3VwcG9ydCB0aGUgYGxpa2VgIG9wZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHRlbXBsYXRlIHRoZSBUZW1wbGF0ZSB0byBtYXRjaCBhZ2FpbnN0XG4gKiBAcGFyYW0ge01peGVkfSBvYmogdGhlIE9iamVjdCBiZWluZyBpbnNwZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaXNNYXRjaGluZ09iamVjdCh0ZW1wbGF0ZSwgb2JqKSB7XG4gIGlmICggdGVtcGxhdGUgPT09IG51bGwgfHwgdGVtcGxhdGUgPT09IHVuZGVmaW5lZCApIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCB0eXBlb2YgdGVtcGxhdGUgIT09ICdvYmplY3QnICkge1xuICAgIHJldHVybiB0ZW1wbGF0ZSA9PT0gb2JqO1xuICB9XG5cbiAgaWYgKCBpc0FycmF5KHRlbXBsYXRlKSApIHtcbiAgICBpZiAoICFpc0FycmF5KG9iaikgfHwgdGVtcGxhdGUubGVuZ3RoICE9PSBvYmoubGVuZ3RoICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoIHZhciBpID0gMCwgbGVuID0gdGVtcGxhdGUubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICBpZiAoICFpc01hdGNoaW5nT2JqZWN0KHRlbXBsYXRlW2ldLCBvYmpbaV0pICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKCB2YXIga2V5IGluIHRlbXBsYXRlICkge1xuICAgIGlmICggIWlzTWF0Y2hpbmdPYmplY3QodGVtcGxhdGVba2V5XSwgb2JqW2tleV0pICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb21waWxlZCBtYXRjaGVyLCBmb3Igd2hlbiB0aGUgdGVtcGxhdGUgaGFzIGJlZW4gZGVmaW5lZCBhcyBhIGxpdGVyYWwuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdGVtcGxhdGUgdGhlIFRlbXBsYXRlIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuZnVuY3Rpb24gYnVpbGRNYXRjaGVyKHRlbXBsYXRlKSB7XG4gIGlmICggdGVtcGxhdGUgPT09IG51bGwgfHwgdGVtcGxhdGUgPT09IHVuZGVmaW5lZCApIHtcbiAgICByZXR1cm4gbnVsbE1hdGNoZXI7XG4gIH1cbiAgaWYgKCB0eXBlb2YgdGVtcGxhdGUgIT09ICdvYmplY3QnICkge1xuICAgIHJldHVybiB2YWx1ZU1hdGNoZXI7XG4gIH1cbiAgaWYgKCBpc0FycmF5KHRlbXBsYXRlKSApIHtcbiAgICByZXR1cm4gYnVpbGRBcnJheU1hdGNoZXIodGVtcGxhdGUpO1xuICB9XG4gIHJldHVybiBidWlsZE9iamVjdE1hdGNoZXIodGVtcGxhdGUpO1xuXG4gIGZ1bmN0aW9uIG51bGxNYXRjaGVyKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiB2YWx1ZU1hdGNoZXIob2JqKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlID09PSBvYmo7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRBcnJheU1hdGNoZXIodGVtcGxhdGUpIHtcbiAgdmFyIG1hdGNoZXJzID0gW107XG4gIHZhciBtbGVuID0gdGVtcGxhdGUubGVuZ3RoO1xuXG4gIGZvciAoIHZhciBpID0gMDsgaSA8IG1sZW47IGkrKyApIHtcbiAgICBtYXRjaGVycy5wdXNoKGJ1aWxkTWF0Y2hlcih0ZW1wbGF0ZVtpXSkpO1xuICB9XG4gIHJldHVybiBhcnJheU1hdGNoZXI7XG5cbiAgZnVuY3Rpb24gYXJyYXlNYXRjaGVyKG9iaikge1xuICAgIGlmICggdGVtcGxhdGUgPT09IG9iaiApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoICFpc0FycmF5KG9iaikgfHwgbWxlbiAhPT0gb2JqLmxlbmd0aCApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbWxlbjsgaSsrICkge1xuICAgICAgaWYgKCAhbWF0Y2hlcnNbaV0ob2JqW2ldKSApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZE9iamVjdE1hdGNoZXIodGVtcGxhdGUpIHtcbiAgdmFyIG1hdGNoZXJzID0gW107XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyh0ZW1wbGF0ZSk7XG4gIHZhciBtbGVuID0ga2V5cy5sZW5ndGg7XG5cbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgbWxlbjsgaSsrICkge1xuICAgIG1hdGNoZXJzLnB1c2goYnVpbGRNYXRjaGVyKHRlbXBsYXRlW2tleXNbaV1dKSk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdE1hdGNoZXI7XG5cbiAgZnVuY3Rpb24gb2JqZWN0TWF0Y2hlcihvYmopIHtcbiAgICBpZiAoIHRlbXBsYXRlID09PSBvYmogKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG1sZW47IGkrKyApIHtcbiAgICAgIGlmICggIW1hdGNoZXJzW2ldKG9ialtrZXlzW2ldXSkgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gRXhwb3J0ZWQgRnVuY3Rpb25zXG5leHBvcnRzLm1hdGNoZXMgPSBpc01hdGNoaW5nT2JqZWN0O1xuZXhwb3J0cy5tYXRjaGVyID0gYnVpbGRNYXRjaGVyO1xuIiwiLypcbiAqIEludGVycG9sIChMb2dpY2Z1bCBIVE1MIFRlbXBsYXRlcylcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogc2VlIGRvYy9MSUNFTlNFLm1kXG4gKlxuICogQGF1dGhvciBUaG9tYXMgUy4gQnJhZGZvcmQgKGtvZGU0Zm9vZC5pdClcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW9yeSA9IHJlcXVpcmUoJy4vbWVtb3J5Jyk7XG52YXIgc3lzdGVtID0gcmVxdWlyZSgnLi9zeXN0ZW0nKTtcblxuLy8gRXhwb3J0ZWQgRnVuY3Rpb25zXG5leHBvcnRzLmNyZWF0ZU1lbW9yeVJlc29sdmVyID0gbWVtb3J5LmNyZWF0ZU1lbW9yeVJlc29sdmVyO1xuZXhwb3J0cy5jcmVhdGVTeXN0ZW1SZXNvbHZlciA9IHN5c3RlbS5jcmVhdGVTeXN0ZW1SZXNvbHZlcjtcbiIsIi8qXG4gKiBJbnRlcnBvbCAoTG9naWNmdWwgSFRNTCBUZW1wbGF0ZXMpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIHNlZSBkb2MvTElDRU5TRS5tZFxuICpcbiAqIEBhdXRob3IgVGhvbWFzIFMuIEJyYWRmb3JkIChrb2RlNGZvb2QuaXQpXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0eXBlcyA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIGlzSW50ZXJwb2xNb2R1bGUgPSB0eXBlcy5pc0ludGVycG9sTW9kdWxlO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG52YXIgYmxlc3MgPSB0eXBlcy5ibGVzcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IE1lbW9yeVJlc29sdmVyLiAgQXMgaXRzIG5hbWUgaW1wbGllcywgdGhpcyByZXNvbHZlclxuICogYWxsb3dzIG9uZSB0byByZWdpc3RlciBhIG1vZHVsZSB0byBiZSBzdG9yZWQgaW4gbWVtb3J5LiAgQSBkZWZhdWx0XG4gKiBpbnN0YW5jZSBvZiB0aGlzIHJlc29sdmVyIGlzIHVzZWQgdG8gc3RvcmUgdGhlIFN5c3RlbSBNb2R1bGVzLlxuICogQmVjYXVzZSBvZiBpdHMgZmxleGliaWxpdHksIGl0IGNhbiBhbHNvIGJlIHVzZWQgdG8gc3RvcmUgY3VzdG9tXG4gKiBtb2R1bGVzIGFuZCBuYXRpdmUgSmF2YVNjcmlwdCBoZWxwZXJzLlxuICpcbiAqIEBwYXJhbSB7UnVudGltZX0gW3J1bnRpbWVdIFJ1bnRpbWUgb3duZXIgZm9yIE1lbW9yeVJlc29sdmVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthZGRSdW50aW1lRW50cmllc10gd2hldGhlciB0byBhZGQgcmVnaXN0ZXJNb2R1bGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5UmVzb2x2ZXIocnVudGltZSwgYWRkUnVudGltZUVudHJpZXMpIHtcbiAgdmFyIGludGVycG9sID0gcnVudGltZS5pbnRlcnBvbDtcbiAgdmFyIGNhY2hlID0ge307XG5cbiAgdmFyIHJlc29sdmVyID0ge1xuICAgIHJlc29sdmVNb2R1bGU6IHJlc29sdmVNb2R1bGUsXG4gICAgcmVzb2x2ZUV4cG9ydHM6IHJlc29sdmVFeHBvcnRzLFxuICAgIHVucmVnaXN0ZXJNb2R1bGU6IHVucmVnaXN0ZXJNb2R1bGUsXG4gICAgcmVnaXN0ZXJNb2R1bGU6IHJlZ2lzdGVyTW9kdWxlXG4gIH07XG5cbiAgcnVudGltZS5yZXNvbHZlcnMoKS5wdXNoKHJlc29sdmVyKTtcbiAgaWYgKCBhZGRSdW50aW1lRW50cmllcyApIHtcbiAgICBydW50aW1lLnJlZ2lzdGVyTW9kdWxlID0gcmVnaXN0ZXJNb2R1bGU7XG4gICAgcnVudGltZS51bnJlZ2lzdGVyTW9kdWxlID0gdW5yZWdpc3Rlck1vZHVsZTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZXI7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZU1vZHVsZShuYW1lKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNhY2hlW25hbWVdO1xuICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQubW9kdWxlIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUV4cG9ydHMobmFtZSkge1xuICAgIHZhciByZXN1bHQgPSBjYWNoZVtuYW1lXTtcbiAgICBpZiAoICFyZXN1bHQgKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICggcmVzdWx0Lm1vZHVsZUV4cG9ydHMgKSB7XG4gICAgICByZXR1cm4gcmVzdWx0Lm1vZHVsZUV4cG9ydHM7XG4gICAgfVxuXG4gICAgdmFyIG1vZHVsZUV4cG9ydHMgPSByZXN1bHQubW9kdWxlRXhwb3J0cyA9IHJlc3VsdC5tb2R1bGUuZXhwb3J0cygpO1xuICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBtb2R1bGUgZnJvbSB0aGUgcmVzb2x2ZXIgY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBtb2R1bGUgdG8gcmVtb3ZlXG4gICAqL1xuICBmdW5jdGlvbiB1bnJlZ2lzdGVyTW9kdWxlKG5hbWUpIHtcbiAgICBkZWxldGUgY2FjaGVbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbW9kdWxlIGluIHRoZSBtb2R1bGUgY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBtb2R1bGUgdG8gYmUgcmVnaXN0ZXJlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ3xPYmplY3R9IG1vZHVsZSB0aGUgbW9kdWxlIHRvIHJlZ2lzdGVyXG4gICAqL1xuICBmdW5jdGlvbiByZWdpc3Rlck1vZHVsZShuYW1lLCBtb2R1bGUpIHtcbiAgICAvLyBBIGNvbXBpbGVkIEludGVycG9sIE1vZHVsZSBmdW5jdGlvblxuICAgIGlmICggaXNJbnRlcnBvbE1vZHVsZShtb2R1bGUpICkge1xuICAgICAgY2FjaGVbbmFtZV0gPSB7IG1vZHVsZTogbW9kdWxlIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gKlN0cmluZyogLSBBbiB1bnBhcnNlZCBJbnRlcnBvbCB0ZW1wbGF0ZVxuICAgIGlmICggdHlwZW9mIG1vZHVsZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBjYWNoZVtuYW1lXSA9IHsgbW9kdWxlOiBpbnRlcnBvbChtb2R1bGUpIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gKk9iamVjdCogLSBBIGhhc2ggb2YgSGVscGVycyAobmFtZS0+RnVuY3Rpb24pXG4gICAgaWYgKCB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUgIT09IG51bGwgJiYgIWlzQXJyYXkobW9kdWxlKSApIHtcbiAgICAgIGNhY2hlW25hbWVdID0geyBtb2R1bGU6IGNyZWF0ZU1vZHVsZVN0dWIobW9kdWxlKSB9O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIk1vZHVsZSBub3QgcHJvdmlkZWRcIik7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgJ2JsZXNzZWQnIG1vZHVsZSB3aGVyZSBhcmUgRnVuY3Rpb25zIGFyZSBtYWRlIHRvIGJlIGJvdGhcbiAqIEludGVycG9sLWNvbXBhdGlibGUgYW5kIGNvbmZpZ3VyYWJsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIHRoZSBNb2R1bGUgdG8gYmxlc3NcbiAqL1xuZnVuY3Rpb24gYmxlc3NNb2R1bGUobW9kdWxlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICggdmFyIGtleSBpbiBtb2R1bGUgKSB7XG4gICAgdmFyIHZhbHVlID0gbW9kdWxlW2tleV07XG4gICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gYmxlc3ModmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGFrZXMgYSBoYXNoIG9mIEZ1bmN0aW9ucywgYmxlc3NlcyB0aGVtLCBhbmQgY3JlYXRlcyBhIHN0dWIgbW9kdWxlIGZvclxuICogdGhlbSB0aGF0IGNhbiBiZSByZXR1cm5lZCBieSB0aGUgYHJlc29sdmVNb2R1bGUoKWAgY2FsbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlRXhwb3J0cyB0aGUgaGFzaCBvZiBGdW5jdGlvbnMgdG8gc3R1YlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2R1bGVTdHViKG1vZHVsZUV4cG9ydHMpIHtcbiAgbW9kdWxlRXhwb3J0cyA9IGJsZXNzTW9kdWxlKG1vZHVsZUV4cG9ydHMpO1xuICB0ZW1wbGF0ZUludGVyZmFjZS5fX2ludE1vZHVsZSA9IHRydWU7XG4gIHRlbXBsYXRlSW50ZXJmYWNlLmV4cG9ydHMgPSB0ZW1wbGF0ZUV4cG9ydHM7XG4gIHJldHVybiB0ZW1wbGF0ZUludGVyZmFjZTtcblxuICBmdW5jdGlvbiB0ZW1wbGF0ZUludGVyZmFjZSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBmdW5jdGlvbiB0ZW1wbGF0ZUV4cG9ydHMoKSB7XG4gICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gIH1cbn1cblxuLy8gRXhwb3J0ZWQgRnVuY3Rpb25zXG5leHBvcnRzLmNyZWF0ZU1lbW9yeVJlc29sdmVyID0gY3JlYXRlTWVtb3J5UmVzb2x2ZXI7XG4iLCIvKlxuICogSW50ZXJwb2wgKExvZ2ljZnVsIEhUTUwgVGVtcGxhdGVzKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBzZWUgZG9jL0xJQ0VOU0UubWRcbiAqXG4gKiBAYXV0aG9yIFRob21hcyBTLiBCcmFkZm9yZCAoa29kZTRmb29kLml0KVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdHlwZXMgPSByZXF1aXJlKCcuLi8uLi90eXBlcycpO1xudmFyIGJsZXNzID0gdHlwZXMuYmxlc3M7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBXcmFwcyBhIEZ1bmN0aW9uIGluIGFuIGVudmVsb3BlIHRoYXQgYWNjZXB0cyBhIFdyaXRlciAoYnV0IGRpc2NhcmRzIGl0KS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIHRoZSBGdW5jdGlvbiB0byB3cmFwXG4gKi9cbmZ1bmN0aW9uIHdyYXAoZnVuYykge1xuICByZXR1cm4gYmxlc3Mod3JhcHBlZEZ1bmN0aW9uKTtcblxuICBmdW5jdGlvbiB3cmFwcGVkRnVuY3Rpb24od3JpdGVyKSB7XG4gICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfVxufVxuXG4vLyBFeHBvcnRlZCBGdW5jdGlvbnNcbmV4cG9ydHMud3JhcCA9IHdyYXA7XG4iLCIvKlxuICogSW50ZXJwb2wgKExvZ2ljZnVsIEhUTUwgVGVtcGxhdGVzKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBzZWUgZG9jL0xJQ0VOU0UubWRcbiAqXG4gKiBAYXV0aG9yIFRob21hcyBTLiBCcmFkZm9yZCAoa29kZTRmb29kLml0KVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtb3J5ID0gcmVxdWlyZSgnLi4vbWVtb3J5Jyk7XG5cbnZhciBtYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG52YXIgbGlzdCA9IHJlcXVpcmUoJy4vbGlzdCcpO1xudmFyIHJlbmRlciA9IHJlcXVpcmUoJy4vcmVuZGVyJyk7XG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcnKTtcblxudmFyIGNyZWF0ZU1lbW9yeVJlc29sdmVyID0gbWVtb3J5LmNyZWF0ZU1lbW9yeVJlc29sdmVyO1xuXG5mdW5jdGlvbiBjcmVhdGVTeXN0ZW1SZXNvbHZlcihydW50aW1lKSB7XG4gIHZhciByZXNvbHZlciA9IGNyZWF0ZU1lbW9yeVJlc29sdmVyKHJ1bnRpbWUpO1xuXG4gIHJlc29sdmVyLnJlZ2lzdGVyTW9kdWxlKCdtYXRoJywgbWF0aCk7XG4gIHJlc29sdmVyLnJlZ2lzdGVyTW9kdWxlKCdsaXN0JywgbGlzdCk7XG4gIHJlc29sdmVyLnJlZ2lzdGVyTW9kdWxlKCdyZW5kZXInLCByZW5kZXIpO1xuICByZXNvbHZlci5yZWdpc3Rlck1vZHVsZSgnc3RyaW5nJywgc3RyaW5nKTtcblxuICBkZWxldGUgcmVzb2x2ZXIucmVnaXN0ZXJNb2R1bGU7XG4gIGRlbGV0ZSByZXNvbHZlci51bnJlZ2lzdGVyTW9kdWxlO1xuXG4gIHJ1bnRpbWUucmVzb2x2ZXJzKCkucHVzaChyZXNvbHZlcik7XG4gIHJldHVybiByZXNvbHZlcjtcbn1cblxuLy8gRXhwb3J0ZWQgRnVuY3Rpb25zXG5leHBvcnRzLmNyZWF0ZVN5c3RlbVJlc29sdmVyID0gY3JlYXRlU3lzdGVtUmVzb2x2ZXI7XG4iLCIvKlxuICogSW50ZXJwb2wgKExvZ2ljZnVsIEhUTUwgVGVtcGxhdGVzKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBzZWUgZG9jL0xJQ0VOU0UubWRcbiAqXG4gKiBAYXV0aG9yIFRob21hcyBTLiBCcmFkZm9yZCAoa29kZTRmb29kLml0KVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbnZhciBvYmplY3RLZXlzID0gdXRpbC5vYmplY3RLZXlzO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG5cbi8vIGBmaXJzdCh2YWx1ZSlgIHJldHVybnMgdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIHByb3ZpZGVkIGFycmF5IChvciBgbnVsbGAgaWZcbi8vIHRoZSBhcnJheSBpcyBlbXB0eSkuXG5mdW5jdGlvbiBmaXJzdCh3cml0ZXIsIHZhbHVlKSB7XG4gIGlmICggaXNBcnJheSh2YWx1ZSkgKSB7XG4gICAgcmV0dXJuIHZhbHVlWzBdO1xuICB9XG4gIGlmICggdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCApIHtcbiAgICB2YXIgbmFtZSA9IG9iamVjdEtleXModmFsdWUpWzBdO1xuICAgIHZhciB2YWwgPSB2YWx1ZVtuYW1lXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsID09PSBudWxsID8gdW5kZWZpbmVkIDogdmFsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIGBqb2luKGRlbGltLCB2YWx1ZSlgIHJldHVybnMgdGhlIHJlc3VsdCBvZiBqb2luaW5nIHRoZSBlbGVtZW50cyBvZiB0aGVcbi8vIHByb3ZpZGVkIGFycmF5LiBFYWNoIGVsZW1lbnQgd2lsbCBiZSBjb25jYXRlbmF0ZWQgaW50byBhIHN0cmluZyBzZXBhcmF0ZWRcbi8vIGJ5IHRoZSBzcGVjaWZpZWQgZGVsaW1pdGVyIChvciAnICcpLlxuZnVuY3Rpb24gam9pbih3cml0ZXIsIGRlbGltLCB2YWx1ZSkge1xuICBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG4gICAgdmFsdWUgPSBkZWxpbTtcbiAgICBkZWxpbSA9ICcgJztcbiAgfVxuICBpZiAoIGlzQXJyYXkodmFsdWUpICkge1xuICAgIHJldHVybiB2YWx1ZS5qb2luKGRlbGltKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIGBsYXN0KHZhbHVlKWAgcmV0dXJucyB0aGUgbGFzdCBpdGVtIG9mIHRoZSBwcm92aWRlZCBhcnJheSAob3IgYG51bGxgIGlmXG4vLyB0aGUgYXJyYXkgaXMgZW1wdHkpLlxuZnVuY3Rpb24gbGFzdCh3cml0ZXIsIHZhbHVlKSB7XG4gIGlmICggaXNBcnJheSh2YWx1ZSkgKSB7XG4gICAgcmV0dXJuIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdO1xuICB9XG4gIGlmICggdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCApIHtcbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXModmFsdWUpO1xuICAgIHZhciBuYW1lID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciB2YWwgPSB2YWx1ZVtuYW1lXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsID09PSBudWxsID8gdW5kZWZpbmVkIDogdmFsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIGBsZW5ndGgodmFsdWUpYCBpZiBpdCBpcyBhbiBhcnJheSwgcmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBwcm92aWRlZFxuLy8gdmFsdWUsIGlmIGFuIG9iamVjdCwgdGhlIG51bWJlciBvZiBrZXlzLCBvdGhlcndpc2UgYDBgLlxuZnVuY3Rpb24gbGVuZ3RoKHdyaXRlciwgdmFsdWUpIHtcbiAgaWYgKCBpc0FycmF5KHZhbHVlKSApIHtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICB9XG4gIGlmICggdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCApIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBgZW1wdHkodmFsdWUpYCByZXR1cm5zIHRydWUgb3IgZmFsc2UgZGVwZW5kaW5nIG9uIHdoZXRoZXIgb3Igbm90IHRoZVxuLy8gcHJvdmlkZWQgYXJyYXkgaXMgZW1wdHkuXG5mdW5jdGlvbiBlbXB0eSh3cml0ZXIsIHZhbHVlKSB7XG4gIGlmICggaXNBcnJheSh2YWx1ZSkgKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gIH1cbiAgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICkge1xuICAgIHJldHVybiAhb2JqZWN0S2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBga2V5cyh2YWx1ZSlgIHJldHVybnMgdGhlIGtleXMgb2YgdGhlIE9iamVjdCBvciBpbmRleGVzIG9mIHRoZSBBcnJheVxuLy8gcGFzc2VkIHRvIGl0LiAgSWYgdGhlIEFycmF5IGlzIHNwYXJzZSAoaGFzIGdhcHMpIGl0IHdpbGwgb25seSByZXR1cm5cbi8vIHRoZSBpbmRleGVzIHdpdGggYXNzaWduZWQgdmFsdWVzLlxuZnVuY3Rpb24ga2V5cyh3cml0ZXIsIHZhbHVlKSB7XG4gIGlmICggdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCApIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLy8gdmFsdWVzKHZhbHVlKWAgcmV0dXJucyB0aGUgdmFsdWVzIG9mIHRoZSBPYmplY3Qgb3IgQXJyYXkgcGFzc2VkIHRvXG4vLyBpdC4gIElmIHRoZSBhcnJheSBpcyBzcGFyc2UgKGhhcyBnYXBzKSBpdCB3aWxsIG9ubHkgcmV0dXJuIHRoZVxuLy8gYXNzaWduZWQgdmFsdWVzLlxuZnVuY3Rpb24gdmFsdWVzKHdyaXRlciwgdmFsdWUpIHtcbiAgaWYgKCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsICkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHZhbHVlKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgcmVzdWx0W2ldID0gdmFsdWVba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gRXhwb3J0c1xuZXhwb3J0cy5maXJzdCA9IGZpcnN0O1xuZXhwb3J0cy5qb2luID0gam9pbjtcbmV4cG9ydHMubGFzdCA9IGxhc3Q7XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMuZW1wdHkgPSBlbXB0eTtcbmV4cG9ydHMua2V5cyA9IGtleXM7XG5leHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcbiIsIi8qXG4gKiBJbnRlcnBvbCAoTG9naWNmdWwgSFRNTCBUZW1wbGF0ZXMpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIHNlZSBkb2MvTElDRU5TRS5tZFxuICpcbiAqIEBhdXRob3IgVGhvbWFzIFMuIEJyYWRmb3JkIChrb2RlNGZvb2QuaXQpXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG5cbnZhciB0eXBlcyA9IHJlcXVpcmUoJy4uLy4uL3R5cGVzJyk7XG52YXIgYmxlc3MgPSB0eXBlcy5ibGVzcztcbnZhciBzdG9wSXRlcmF0aW9uID0gdHlwZXMuc3RvcEl0ZXJhdGlvbjtcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbnZhciB3cmFwID0gaGVscGVycy53cmFwO1xuXG5mdW5jdGlvbiBudW1iZXJTb3J0KGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBsZWZ0ID4gcmlnaHQ7XG59XG5cbi8vIGByYW5nZShzdGFydCwgZW5kKWAgY3JlYXRlcyBhbiBpbnRlZ2VyIHJhbmdlIGdlbmVyYXRvclxuZnVuY3Rpb24gcmFuZ2Uod3JpdGVyLCBzdGFydCwgZW5kKSB7XG4gIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCk7XG4gIGVuZCA9IE1hdGguZmxvb3IoZW5kKTtcbiAgdmFyIGluY3JlbWVudCA9IGVuZCA+IHN0YXJ0ID8gMSA6IC0xO1xuICByZXR1cm4gYmxlc3MocmFuZ2VJbnN0YW5jZSwgJ2dlbicpO1xuICBcbiAgZnVuY3Rpb24gcmFuZ2VJbnN0YW5jZSgpIHtcbiAgICBpZiAoIHN0YXJ0ID09PSBzdG9wSXRlcmF0aW9uICkge1xuICAgICAgcmV0dXJuIHN0b3BJdGVyYXRpb247XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBzdGFydDtcbiAgICBpZiAoIHN0YXJ0ID09PSBlbmQgKSB7XG4gICAgICBzdGFydCA9IHN0b3BJdGVyYXRpb247XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhcnQgKz0gaW5jcmVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8vIGBhdmcodmFsdWUpYCBpZiBhbiBBcnJheSwgcmV0dXJucyB0aGUgYXZlcmFnZSAobWF0aGVtYXRpY2FsIG1lYW4pIG9mXG4vLyB2YWx1ZSdzIGVsZW1lbnRzXG5mdW5jdGlvbiBhdmcod3JpdGVyLCB2YWx1ZSkge1xuICBpZiAoICFpc0FycmF5KHZhbHVlKSApIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogTmFOO1xuICB9XG4gIGlmICggdmFsdWUubGVuZ3RoID09PSAwICkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGZvciAoIHZhciBpID0gMCwgciA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyByICs9IHZhbHVlW2krK10gKTtcbiAgcmV0dXJuIHIgLyBsO1xufVxuXG4vLyBgbWF4KHZhbHVlKWAgaWYgYW4gQXJyYXksIHJldHVybiB0aGUgZ3JlYXRlc3QgdmFsdWUgaW4gaXRcbmZ1bmN0aW9uIG1heCh3cml0ZXIsIHZhbHVlKSB7XG4gIGlmICggIWlzQXJyYXkodmFsdWUpICkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBOYU47XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlKTtcbn1cblxuLy8gYG1lZGlhbih2YWx1ZSlgIGlmIGFuIEFycmF5LCByZXR1cm4gdGhlIG1hdGhlbWF0aWNhbCBtZWRpYW4gb2Zcbi8vIHZhbHVlJ3MgZWxlbWVudHNcbmZ1bmN0aW9uIG1lZGlhbih3cml0ZXIsIHZhbHVlKSB7XG4gIGlmICggIWlzQXJyYXkodmFsdWUpICkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBOYU47XG4gIH1cbiAgaWYgKCB2YWx1ZS5sZW5ndGggPT09IDAgKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHRlbXAgPSB2YWx1ZS5zbGljZSgwKS5zb3J0KG51bWJlclNvcnQpO1xuICBpZiAoIHRlbXAubGVuZ3RoICUgMiA9PT0gMCApIHtcbiAgICB2YXIgbWlkID0gdGVtcC5sZW5ndGggLyAyO1xuICAgIHJldHVybiAodGVtcFttaWQgLSAxXSArIHRlbXBbbWlkXSkgLyAyO1xuICB9XG4gIHJldHVybiB0ZW1wWygodGVtcC5sZW5ndGggKyAxKSAvIDIpIC0gMV07XG59XG5cbi8vIGBtaW4odmFsdWUpYCBpZiBhbiBBcnJheSwgcmV0dXJuIHRoZSBsb3dlc3QgdmFsdWUgaW4gaXRcbmZ1bmN0aW9uIG1pbih3cml0ZXIsIHZhbHVlKSB7XG4gIGlmICggIWlzQXJyYXkodmFsdWUpICkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBOYU47XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlKTtcbn1cblxuLy8gYHN1bSh2YWx1ZSlgIGlmIGFuIEFycmF5LCByZXR1cm4gdGhlIG1hdGhlbWF0aWNhbCBzdW0gb2YgdmFsdWUnc1xuLy8gZWxlbWVudHNcbmZ1bmN0aW9uIHN1bSh3cml0ZXIsIHZhbHVlKSB7XG4gIGlmICggIWlzQXJyYXkodmFsdWUpICkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBOYU47XG4gIH1cbiAgZm9yICggdmFyIGkgPSAwLCByZXMgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgcmVzICs9IHZhbHVlW2krK10gKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gTWF0aCBmdW5jdGlvbnNcblxuLy8gYG51bWJlcih2YWx1ZSlgIGNvbnZlcnQgdmFsdWUgdG8gYSBOdW1iZXJcbmV4cG9ydHMubnVtYmVyID0gd3JhcChOdW1iZXIpO1xuLy8gYGFicyh2YWx1ZSlgIHJldHVybnMgdGhlIGFic29sdXRlIHZhbHVlXG5leHBvcnRzLmFicyA9IHdyYXAoTWF0aC5hYnMpO1xuLy8gYGFjb3ModmFsdWUpYCByZXR1cm5zIHRoZSBhcmMtY29zaW5lIG9mIHZhbHVlIChpbiByYWRpYW5zKVxuZXhwb3J0cy5hY29zID0gd3JhcChNYXRoLmFjb3MpO1xuLy8gYGFzaW4odmFsdWUpYCByZXR1cm5zIHRoZSBhcmMtc2luZSBvZiB2YWx1ZSAoaW4gcmFkaWFucylcbmV4cG9ydHMuYXNpbiA9IHdyYXAoTWF0aC5hc2luKTtcbi8vIGBhdGFuKHZhbHVlKWAgcmV0dXJucyB0aGUgYXJjLXRhbmdlbnQgb2YgdmFsdWUgKGluIHJhZGlhbnMpXG5leHBvcnRzLmF0YW4gPSB3cmFwKE1hdGguYXRhbik7XG4vLyBgYXRhbjIoeCx5KWAgcmV0dXJucyB0aGUgYXJjLXRhbmdlbnQgb2YgdGhlIGNvb3Jkc1xuZXhwb3J0cy5hdGFuMiA9IHdyYXAoTWF0aC5hdGFuMik7XG4vLyBgY2VpbCh2YWx1ZSlgIHJvdW5kcyB0byB0aGUgbmV4dCBoaWdoZXN0IGludGVnZXJcbmV4cG9ydHMuY2VpbCA9IHdyYXAoTWF0aC5jZWlsKTtcbi8vIGBjb3ModmFsdWUpYCByZXR1cm5zIHRoZSBjb3NpbmUgb2YgdmFsdWUgKGluIHJhZGlhbnMpXG5leHBvcnRzLmNvcyA9IHdyYXAoTWF0aC5jb3MpO1xuLy8gYGV4cCh4KWAgcmV0dXJucyBFIHRvIHRoZSBwb3dlciBvZiB4XG5leHBvcnRzLmV4cCA9IHdyYXAoTWF0aC5leHApO1xuLy8gYGZsb29yKHZhbHVlKWAgcm91bmRzIHRvIHRoZSBuZXh0IGxvd2VzdCBpbnRlZ2VyXG5leHBvcnRzLmZsb29yID0gd3JhcChNYXRoLmZsb29yKTtcbi8vIGBsb2codmFsdWUpYCByZXR1cm5zIHRoZSBuYXR1cmFsIGxvZ2FyaXRobVxuZXhwb3J0cy5sb2cgPSB3cmFwKE1hdGgubG9nKTtcbi8vIGBwb3coeCx5KWAgcmV0dXJucyB4IHJhaXNlZCB0byB0aGUgcG93ZXIgb2YgeVxuZXhwb3J0cy5wb3cgPSB3cmFwKE1hdGgucG93KTtcbi8vIGByYW5kb20oKWAgcmV0dXJucyBhIHJhbmRvbSBudW1iZXIgKDAgPD0geCA8IDEpXG5leHBvcnRzLnJhbmRvbSA9IHdyYXAoTWF0aC5yYW5kb20pO1xuLy8gYHJvdW5kKHZhbHVlKWAgcm91bmRzIHVwIG9yIGRvd24gdG8gdGhlIGNsb3Nlc3QgaW50ZWdlclxuZXhwb3J0cy5yb3VuZCA9IHdyYXAoTWF0aC5yb3VuZCk7XG4vLyBgc2luKHZhbHVlKWAgcmV0dXJucyB0aGUgc2luZSBvZiB2YWx1ZSAoaW4gcmFkaWFucylcbmV4cG9ydHMuc2luID0gd3JhcChNYXRoLnNpbik7XG4vLyBgc3FydCh2YWx1ZSlgIHJldHVybnMgdGhlIHNxdWFyZSByb290XG5leHBvcnRzLnNxcnQgPSB3cmFwKE1hdGguc3FydCk7XG4vLyBgdGFuKHZhbHVlKWAgcmV0dXJucyB0aGUgdGFuZ2VudCBvZiB2YWx1ZSAoaW4gcmFkaWFucylcbmV4cG9ydHMudGFuID0gd3JhcChNYXRoLnRhbik7XG5cbi8vICMjIyBDb25zdGFudHNcblxuLy8gYEVgIGlzIEV1bGVyJ3MgTnVtYmVyXG5leHBvcnRzLkUgPSBNYXRoLkU7XG4vLyBgTE4yYCBpcyB0aGUgTmF0dXJhbCBMb2dhcml0aG0gb2YgMlxuZXhwb3J0cy5MTjIgPSBNYXRoLkxOMjtcbi8vIGBMTjEwYCBpcyB0aGUgTmF0dXJhbCBMb2dhcml0aG0gb2YgMTBcbmV4cG9ydHMuTE4xMCA9IE1hdGguTE4xMDtcbi8vIGBMT0cyRWAgaXMgdGhlIEJhc2UtMiBMb2dhcml0aG0gb2YgRVxuZXhwb3J0cy5MT0cyRSA9IE1hdGguTE9HMkU7XG4vLyBgTE9HMTBFYCBpcyB0aGUgQmFzZS0xMCBMb2dhcml0aG0gb2YgRVxuZXhwb3J0cy5MT0cxMEUgPSBNYXRoLkxPRzEwRTtcbi8vIGBQSWAgaXMgUGlcbmV4cG9ydHMuUEkgPSBNYXRoLlBJO1xuLy8gYFNRUlQxXzJgIGlzIHRoZSBTcXVhcmUgUm9vdCBvZiAxLzJcbmV4cG9ydHMuU1FSVDFfMiA9IE1hdGguU1FSVDFfMjtcbi8vIGBTUVJUMmAgaXMgdGhlIFNxdWFyZSBSb290IG9mIDJcbmV4cG9ydHMuU1FSVDIgPSBNYXRoLlNRUlQyO1xuXG4vLyBFeHBvcnRlZCBGdW5jdGlvbnNcbmV4cG9ydHMucmFuZ2UgPSByYW5nZTtcbmV4cG9ydHMuYXZnID0gYXZnO1xuZXhwb3J0cy5tYXggPSBtYXg7XG5leHBvcnRzLm1lZGlhbiA9IG1lZGlhbjtcbmV4cG9ydHMubWluID0gbWluO1xuZXhwb3J0cy5zdW0gPSBzdW07XG4iLCIvKlxuICogSW50ZXJwb2wgKExvZ2ljZnVsIEhUTUwgVGVtcGxhdGVzKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBzZWUgZG9jL0xJQ0VOU0UubWRcbiAqXG4gKiBAYXV0aG9yIFRob21hcyBTLiBCcmFkZm9yZCAoa29kZTRmb29kLml0KVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdHlwZXMgPSByZXF1aXJlKCcuLi8uLi90eXBlcycpO1xudmFyIGJsZXNzID0gdHlwZXMuYmxlc3M7XG5cbnZhciBub09wID0gYmxlc3MoZnVuY3Rpb24gKCkge30pO1xuXG5mdW5jdGlvbiBjb3VudGVyKHdyaXRlciwgc3RhcnQsIGluY3JlbWVudCkge1xuICBpZiAoIHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicgfHwgaXNOYU4oc3RhcnQpICkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICBpZiAoIHR5cGVvZiBpbmNyZW1lbnQgIT09ICdudW1iZXInIHx8IGlzTmFOKGluY3JlbWVudCkgKSB7XG4gICAgaW5jcmVtZW50ID0gMTtcbiAgfVxuICByZXR1cm4gYmxlc3MoY291bnRlckluc3RhbmNlKTtcblxuICBmdW5jdGlvbiBjb3VudGVySW5zdGFuY2UoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IGluY3JlbWVudDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW5PZGQod3JpdGVyLCBldmVuLCBvZGQpIHtcbiAgaWYgKCBldmVuID09PSB1bmRlZmluZWQgKSB7XG4gICAgZXZlbiA9ICdldmVuJztcbiAgfVxuICBpZiAoIG9kZCA9PT0gdW5kZWZpbmVkICkge1xuICAgIG9kZCA9ICdvZGQnO1xuICB9XG5cbiAgdmFyIGN1cnJlbnQgPSB0cnVlO1xuICByZXR1cm4gYmxlc3MoZXZlbk9kZEluc3RhbmNlKTtcblxuICBmdW5jdGlvbiBldmVuT2RkSW5zdGFuY2UoKSB7XG4gICAgY3VycmVudCA9ICFjdXJyZW50O1xuICAgIHJldHVybiBjdXJyZW50ID8gb2RkIDogZXZlbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXBhcmF0b3Iod3JpdGVyLCBzZXApIHtcbiAgdmFyIGVtcHR5ID0gJyc7XG4gIGlmICggc2VwID09PSB1bmRlZmluZWQgKSB7XG4gICAgc2VwID0gJywgJztcbiAgfVxuICBlbHNlIGlmICggdHlwZW9mIHNlcCA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICBlbXB0eSA9IG5vT3A7XG4gIH1cblxuICB2YXIgZmlyc3QgPSB0cnVlO1xuICByZXR1cm4gYmxlc3Moc2VwYXJhdG9ySW5zdGFuY2UpO1xuXG4gIGZ1bmN0aW9uIHNlcGFyYXRvckluc3RhbmNlKCkge1xuICAgIGlmICggZmlyc3QgKSB7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cbiAgICByZXR1cm4gc2VwO1xuICB9XG59XG5cbi8vIEV4cG9ydHNcbmV4cG9ydHMuY291bnRlciA9IGNvdW50ZXI7XG5leHBvcnRzLmV2ZW5PZGQgPSBldmVuT2RkO1xuZXhwb3J0cy5zZXBhcmF0b3IgPSBzZXBhcmF0b3I7XG4iLCIvKlxuICogSW50ZXJwb2wgKExvZ2ljZnVsIEhUTUwgVGVtcGxhdGVzKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBzZWUgZG9jL0xJQ0VOU0UubWRcbiAqXG4gKiBAYXV0aG9yIFRob21hcyBTLiBCcmFkZm9yZCAoa29kZTRmb29kLml0KVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9ybWF0ID0gcmVxdWlyZSgnLi4vLi4vZm9ybWF0Jyk7XG52YXIgdHlwZXMgPSByZXF1aXJlKCcuLi8uLi90eXBlcycpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxudmFyIGJ1aWxkRGVmZXJyZWRGb3JtYXR0ZXIgPSBmb3JtYXQuYnVpbGREZWZlcnJlZEZvcm1hdHRlcjtcbnZhciBzdHJpbmdpZnkgPSB0eXBlcy5zdHJpbmdpZnk7XG52YXIgd3JhcCA9IGhlbHBlcnMud3JhcDtcblxuLy8gYGJ1aWxkKHZhbHVlLCBzdXBwb3J0RnVuY3Rpb25zKWAgY29udmVydHMgdGhlIHByb3ZpZGVkIHN0cmluZyBhbmRcbi8vIHN1cHBvcnRGdW5jdGlvbnMgT2JqZWN0IGludG8gYW4gSW50ZXJwb2wgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbi5cbmZ1bmN0aW9uIGJ1aWxkKHdyaXRlciwgdmFsdWUsIHN1cHBvcnRGdW5jdGlvbnMpIHtcbiAgdmFyIGZvcm1hdHRlciA9IGJ1aWxkRGVmZXJyZWRGb3JtYXR0ZXIoc3RyaW5naWZ5KHZhbHVlKSk7XG4gIHJldHVybiBmb3JtYXR0ZXIoc3VwcG9ydEZ1bmN0aW9ucyk7XG59XG5cbi8vIGBsb3dlcih2YWx1ZSlgIGNvbnZlcnRzIHRoZSBwcm92aWRlZCBzdHJpbmcgdG8gbG93ZXItY2FzZSBhbmQgcmV0dXJuc1xuLy8gdGhlIHJlc3VsdC5cbmZ1bmN0aW9uIGxvd2VyKHdyaXRlciwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0cmluZ2lmeSh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbn1cblxuLy8gYHNwbGl0KGRlbGltLCB2YWx1ZSlgIHNwbGl0cyB0aGUgcHJvdmlkZWQgc3RyaW5nIHdoZXJldmVyIHRoZVxuLy8gc3BlY2lmaWVkIGRlbGltaXRlciAob3Igd2hpdGVzcGFjZSkgaXMgZW5jb3VudGVyZWQgYW5kIHJldHVybnMgdGhlXG4vLyByZXN1bHQuXG5mdW5jdGlvbiBzcGxpdCh3cml0ZXIsIGRlbGltLCB2YWx1ZSkge1xuICBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG4gICAgdmFsdWUgPSBkZWxpbTtcbiAgICBkZWxpbSA9IC9cXHMqLztcbiAgfVxuICByZXR1cm4gc3RyaW5naWZ5KHZhbHVlKS5zcGxpdChkZWxpbSk7XG59XG5cbi8vIGB0aXRsZSh2YWx1ZSlgIGNvbnZlcnRzIHRoZSBwcm92aWRlZCBzdHJpbmcgdG8gdGl0bGUtY2FzZSBhbmQgcmV0dXJuc1xuLy8gdGhlIHJlc3VsdC4gIFRpdGxlIGNhc2UgY29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBlYWNoIHdvcmQgdG9cbi8vIHVwcGVyLWNhc2UsIGFuZCB0aGUgcmVzdCB0byBsb3dlci1jYXNlLlxuZnVuY3Rpb24gdGl0bGUod3JpdGVyLCB2YWx1ZSkge1xuICByZXR1cm4gc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9cXHdcXFMqL2csIGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbn1cblxuLy8gYHVwcGVyKHZhbHVlKWAgY29udmVydHMgdGhlIHByb3ZpZGVkIHN0cmluZyB0byB1cHBlci1jYXNlIGFuZCByZXR1cm5zXG4vLyB0aGUgcmVzdWx0LlxuZnVuY3Rpb24gdXBwZXIod3JpdGVyLCB2YWx1ZSkge1xuICByZXR1cm4gc3RyaW5naWZ5KHZhbHVlKS50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBgc3RyaW5nKHZhbHVlKWAgY29udmVydHMgdmFsdWUgdG8gYSBTdHJpbmdcbmV4cG9ydHMuc3RyaW5nID0gd3JhcChTdHJpbmcpO1xuXG4vLyBFeHBvcnRlZCBGdW5jdGlvbnNcbmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcbmV4cG9ydHMubG93ZXIgPSBsb3dlcjtcbmV4cG9ydHMuc3BsaXQgPSBzcGxpdDtcbmV4cG9ydHMudGl0bGUgPSB0aXRsZTtcbmV4cG9ydHMudXBwZXIgPSB1cHBlcjtcbiIsIi8qXG4gKiBJbnRlcnBvbCAoTG9naWNmdWwgSFRNTCBUZW1wbGF0ZXMpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIHNlZSBkb2MvTElDRU5TRS5tZFxuICpcbiAqIEBhdXRob3IgVGhvbWFzIFMuIEJyYWRmb3JkIChrb2RlNGZvb2QuaXQpXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xudmFyIG1hdGNoID0gcmVxdWlyZSgnLi9tYXRjaCcpO1xuXG52YXIgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG52YXIgaXNJbnRlcnBvbFJ1bnRpbWUgPSB0eXBlcy5pc0ludGVycG9sUnVudGltZTtcbnZhciBpc0ludGVycG9sRnVuY3Rpb24gPSB0eXBlcy5pc0ludGVycG9sRnVuY3Rpb247XG52YXIgaXNJbnRlcnBvbFBhcnRpYWwgPSB0eXBlcy5pc0ludGVycG9sUGFydGlhbDtcbnZhciBpc0ludGVycG9sR2VuZXJhdG9yID0gdHlwZXMuaXNJbnRlcnBvbEdlbmVyYXRvcjtcbnZhciBzdG9wSXRlcmF0aW9uID0gdHlwZXMuc3RvcEl0ZXJhdGlvbjtcbnZhciBibGVzcyA9IHR5cGVzLmJsZXNzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG52YXIgbWl4aW4gPSB1dGlsLm1peGluO1xudmFyIGV4dGVuZE9iamVjdCA9IHV0aWwuZXh0ZW5kT2JqZWN0O1xudmFyIG9iamVjdEtleXMgPSB1dGlsLm9iamVjdEtleXM7XG5cbnZhciBpbnRlcm5hbFJlc29sdmVycyA9IHJlcXVpcmUoJy4vcmVzb2x2ZXJzL2ludGVybmFsJyk7XG52YXIgY3JlYXRlU3lzdGVtUmVzb2x2ZXIgPSBpbnRlcm5hbFJlc29sdmVycy5jcmVhdGVTeXN0ZW1SZXNvbHZlcjtcbnZhciBjcmVhdGVNZW1vcnlSZXNvbHZlciA9IGludGVybmFsUmVzb2x2ZXJzLmNyZWF0ZU1lbW9yeVJlc29sdmVyO1xuXG52YXIgd3JpdGVycyA9IHJlcXVpcmUoJy4vd3JpdGVycycpO1xudmFyIGNyZWF0ZVN0cmluZ1dyaXRlciA9IHdyaXRlcnMuY3JlYXRlU3RyaW5nV3JpdGVyO1xudmFyIG51bGxXcml0ZXIgPSB3cml0ZXJzLmNyZWF0ZU51bGxXcml0ZXIoKTtcblxudmFyIG5vT3AgPSBibGVzcyhmdW5jdGlvbiAoKSB7fSk7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gY3JlYXRlUnVudGltZShpbnRlcnBvbCwgcnVudGltZU9wdGlvbnMpIHtcbiAgaWYgKCBpc0ludGVycG9sUnVudGltZShydW50aW1lT3B0aW9ucykgKSB7XG4gICAgcmV0dXJuIHJ1bnRpbWVPcHRpb25zO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSBtaXhpbih7fSwgcnVudGltZU9wdGlvbnMpO1xuICB2YXIgY2FjaGVNb2R1bGVzID0gb3B0aW9ucy5jYWNoZTtcbiAgdmFyIGNyZWF0ZURlZmF1bHRSZXNvbHZlcnMgPSAhb3B0aW9ucy5yZXNvbHZlcnM7XG4gIHZhciByZXNvbHZlcnMgPSBjcmVhdGVEZWZhdWx0UmVzb2x2ZXJzID8gW10gOiBvcHRpb25zLnJlc29sdmVycztcblxuICB2YXIgcmVzb2x2ZUV4cG9ydHMgPSBjcmVhdGVSZXNvbHZlcigncmVzb2x2ZUV4cG9ydHMnKTtcbiAgdmFyIHJlc29sdmVNb2R1bGUgPSBjcmVhdGVSZXNvbHZlcigncmVzb2x2ZU1vZHVsZScpO1xuXG4gIHZhciBydW50aW1lID0ge1xuICAgIF9faW50UnVudGltZTogdHJ1ZSxcbiAgICBpbnRlcnBvbDogaW50ZXJwb2wsXG5cbiAgICBvcHRpb25zOiBnZXRPcHRpb25zLFxuICAgIHJlc29sdmVyczogZ2V0UmVzb2x2ZXJzLFxuXG4gICAgZXh0ZW5kT2JqZWN0OiB1dGlsLmV4dGVuZE9iamVjdCxcbiAgICBtaXhpbjogdXRpbC5taXhpbixcbiAgICBpc1RydXRoeTogdHlwZXMuaXNUcnV0aHksXG4gICAgaXNGYWxzeTogdHlwZXMuaXNGYWxzeSxcblxuICAgIGltbWVkaWF0ZUZvcm1hdHRlcjogZm9ybWF0LmJ1aWxkSW1tZWRpYXRlRm9ybWF0dGVyLFxuICAgIGRlZmVycmVkRm9ybWF0dGVyOiBmb3JtYXQuYnVpbGREZWZlcnJlZEZvcm1hdHRlcixcblxuICAgIG1hdGNoZXM6IG1hdGNoLm1hdGNoZXMsXG4gICAgbWF0Y2hlcjogbWF0Y2gubWF0Y2hlcixcblxuICAgIHJlc29sdmVFeHBvcnRzOiByZXNvbHZlRXhwb3J0cyxcbiAgICByZXNvbHZlTW9kdWxlOiByZXNvbHZlTW9kdWxlLFxuICAgIGltcG9ydGVyOiBidWlsZEltcG9ydGVyLFxuICAgIGRlZmluZU1vZHVsZTogZGVmaW5lTW9kdWxlLFxuICAgIGRlZmluZVBhcnRpYWw6IGRlZmluZVBhcnRpYWwsXG4gICAgZGVmaW5lR3VhcmRlZFBhcnRpYWw6IGRlZmluZUd1YXJkZWRQYXJ0aWFsLFxuICAgIGNsZWFuc2VBcmd1bWVudHM6IGNsZWFuc2VBcmd1bWVudHMsXG5cbiAgICBnZXRQcm9wZXJ0eTogZ2V0UHJvcGVydHksXG4gICAgZ2V0UGF0aDogZ2V0UGF0aCxcbiAgICBiaW5kUGFydGlhbDogYmluZFBhcnRpYWwsXG4gICAgbG9vcDogbG9vcCxcbiAgICBleGVjOiBleGVjXG4gIH07XG5cbiAgaWYgKCBjcmVhdGVEZWZhdWx0UmVzb2x2ZXJzICkge1xuICAgIGNyZWF0ZVN5c3RlbVJlc29sdmVyKHJ1bnRpbWUpO1xuICAgIGNyZWF0ZU1lbW9yeVJlc29sdmVyKHJ1bnRpbWUsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHJ1bnRpbWU7XG5cbiAgZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJlc29sdmVycygpIHtcbiAgICByZXR1cm4gcmVzb2x2ZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZXIobWV0aG9kTmFtZSkge1xuICAgIHJldHVybiByZXNvbHZlO1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZShtb2R1bGVOYW1lKSB7XG4gICAgICBmb3IgKCB2YXIgaSA9IHJlc29sdmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgdmFyIG1vZHVsZSA9IHJlc29sdmVyc1tpXVttZXRob2ROYW1lXShtb2R1bGVOYW1lKTtcbiAgICAgICAgaWYgKCBtb2R1bGUgKSB7XG4gICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvLyB3aGVyZSBleHBvcnRzIGFyZSBhY3R1YWxseSByZXNvbHZlZC4gcmFpc2VFcnJvciB3aWxsIGJlIGZhbHNlXG4gIC8vIGlmIHdlJ3JlIGluIHRoZSBwcm9jZXNzIG9mIGV2YWx1YXRpbmcgYSB0ZW1wbGF0ZSBmb3IgdGhlIHB1cnBvc2VcbiAgLy8gb2YgeWllbGRpbmcgaXRzIGV4cG9ydHNcbiAgZnVuY3Rpb24gYnVpbGRJbXBvcnRlcihtb2R1bGVOYW1lKSB7XG4gICAgdmFyIGltcG9ydGVyID0gZHluYW1pY0ltcG9ydGVyO1xuICAgIHZhciBtb2R1bGU7XG5cbiAgICByZXR1cm4gcGVyZm9ybUltcG9ydDtcblxuICAgIGZ1bmN0aW9uIHBlcmZvcm1JbXBvcnQoKSB7XG4gICAgICByZXR1cm4gaW1wb3J0ZXIoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWNoZWRJbXBvcnRlcigpIHtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHluYW1pY0ltcG9ydGVyKCkge1xuICAgICAgbW9kdWxlID0gcmVzb2x2ZUV4cG9ydHMobW9kdWxlTmFtZSk7XG4gICAgICBpZiAoICFtb2R1bGUgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZHVsZSAnXCIgKyBtb2R1bGVOYW1lICsgXCInIG5vdCByZXNvbHZlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICggY2FjaGVNb2R1bGVzICkge1xuICAgICAgICBpbXBvcnRlciA9IGNhY2hlZEltcG9ydGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVG9TdHJpbmcoZnVuYykge1xuICB2YXIgc3RyaW5nV3JpdGVycyA9IFtdO1xuICB2YXIgc3RyaW5nV3JpdGVyc0F2YWlsID0gMDtcbiAgcmV0dXJuIHRvU3RyaW5nO1xuXG4gIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciB3cml0ZXI7XG4gICAgaWYgKCBzdHJpbmdXcml0ZXJzQXZhaWwgKSB7XG4gICAgICB3cml0ZXIgPSBzdHJpbmdXcml0ZXJzWy0tc3RyaW5nV3JpdGVyc0F2YWlsXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB3cml0ZXIgPSBjcmVhdGVTdHJpbmdXcml0ZXIoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGZ1bmMod3JpdGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSB3cml0ZXIuZG9uZSgpO1xuICAgICAgc3RyaW5nV3JpdGVyc1tzdHJpbmdXcml0ZXJzQXZhaWwrK10gPSB3cml0ZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoIGVyciApIHtcbiAgICAgIHdyaXRlci5yZXNldCgpO1xuICAgICAgc3RyaW5nV3JpdGVyc1tzdHJpbmdXcml0ZXJzQXZhaWwrK10gPSB3cml0ZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZU1vZHVsZSh0ZW1wbGF0ZSkge1xuICB2YXIgc3RyaW5nV3JpdGVycyA9IFtdO1xuICB2YXIgc3RyaW5nV3JpdGVyc0F2YWlsID0gMDtcbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge307XG4gIHZhciBleHBvcnRlZENvbnRleHQ7XG5cbiAgdGVtcGxhdGVJbnRlcmZhY2UuX19pbnRNb2R1bGUgPSB0cnVlO1xuICB0ZW1wbGF0ZUludGVyZmFjZS5leHBvcnRzID0gdGVtcGxhdGVFeHBvcnRzO1xuICByZXR1cm4gdGVtcGxhdGVJbnRlcmZhY2U7XG5cbiAgZnVuY3Rpb24gdGVtcGxhdGVJbnRlcmZhY2Uob2JqLCB0ZW1wbGF0ZU9wdGlvbnMpIHtcbiAgICB2YXIgY3R4ID0gb2JqID8gZXh0ZW5kT2JqZWN0KG9iaikgOiB7fTtcbiAgICBpZiAoICF0ZW1wbGF0ZU9wdGlvbnMgKSB7XG4gICAgICB0ZW1wbGF0ZU9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICAvLyBJZiBubyBXcml0ZXIgaXMgcHJvdmlkZWQsIGNyZWF0ZSBhIHRocm93LWF3YXkgQXJyYXkgV3JpdGVyXG4gICAgdmFyIHdyaXRlciA9IHRlbXBsYXRlT3B0aW9ucy53cml0ZXI7XG4gICAgdmFyIHVzZVN0cmluZ1dyaXRlciA9ICF3cml0ZXI7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCB1c2VTdHJpbmdXcml0ZXIgKSB7XG4gICAgICAgIGlmICggc3RyaW5nV3JpdGVyc0F2YWlsICkge1xuICAgICAgICAgIHdyaXRlciA9IHN0cmluZ1dyaXRlcnNbLS1zdHJpbmdXcml0ZXJzQXZhaWxdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHdyaXRlciA9IGNyZWF0ZVN0cmluZ1dyaXRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlKGN0eCwgd3JpdGVyKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHdyaXRlci5kb25lKCk7XG4gICAgICAgIHN0cmluZ1dyaXRlcnNbc3RyaW5nV3JpdGVyc0F2YWlsKytdID0gd3JpdGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdGVtcGxhdGUoY3R4LCB3cml0ZXIpO1xuICAgICAgcmV0dXJuIHdyaXRlci5kb25lKCk7XG4gICAgfVxuICAgIGNhdGNoICggZXJyICkge1xuICAgICAgd3JpdGVyLnJlc2V0KCk7XG4gICAgICBpZiAoIHVzZVN0cmluZ1dyaXRlciApIHtcbiAgICAgICAgc3RyaW5nV3JpdGVyc1tzdHJpbmdXcml0ZXJzQXZhaWwrK10gPSB3cml0ZXI7XG4gICAgICB9XG4gICAgICBpZiAoIHR5cGVvZiB0ZW1wbGF0ZU9wdGlvbnMuZXJyb3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgdGVtcGxhdGVPcHRpb25zLmVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmUtcmFpc2UgaWYgbm8gY2FsbGJhY2tcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3ltYm9scyAocGFydGlhbHMgYW5kIGFzc2lnbm1lbnRzKSB0aGF0IHRoZSBydW50aW1lXG4gICAqIHRlbXBsYXRlIHdpbGwgcHJvZHVjdCBhZ2FpbnN0IGFuIGVtcHR5IGB7fWAgY29udGV4dCBPYmplY3QuICBUaGlzIGlzXG4gICAqIHRoZSBtZXRob2QgYnkgd2hpY2ggSW50ZXJwb2wgaW1wb3J0cyB3b3JrLiAgUGFydGlhbHMgcHJvZHVjZWQgd2l0aFxuICAgKiB0aGlzIG1ldGhvZCBzdGlsbCBoYXZlIGFjY2VzcyB0byB0aGUgZ2xvYmFsIGNvbnRleHQuXG4gICAqL1xuICBmdW5jdGlvbiB0ZW1wbGF0ZUV4cG9ydHMoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBndWFyZCAqL1xuICAgIGlmICggZXhwb3J0ZWRDb250ZXh0ICkge1xuICAgICAgcmV0dXJuIGV4cG9ydGVkQ29udGV4dDtcbiAgICB9XG5cbiAgICAvLyBgX19pbnRFeHBvcnRzYCBpcyBhbiBpbmRpY2F0b3IgdG8gZXZhbHVhdG9ycyB0aGF0IHdlJ3JlIHByb2Nlc3NpbmdcbiAgICAvLyBleHBvcnRzIGFuZCBzbyB0aGV5IGNhbiBiZSBhIGJpdCBsYXggYWJvdXQgcmVwb3J0aW5nIGVycm9ycyBvclxuICAgIC8vIHJlc29sdmluZyBpbXBvcnRzXG5cbiAgICBleHBvcnRlZENvbnRleHQgPSB7fTtcbiAgICBleHBvcnRlZENvbnRleHQuX19pbnRFeHBvcnRzID0gdHJ1ZTtcbiAgICB0ZW1wbGF0ZShleHBvcnRlZENvbnRleHQsIG51bGxXcml0ZXIpO1xuICAgIGRlbGV0ZSBleHBvcnRlZENvbnRleHQuX19pbnRFeHBvcnRzO1xuXG4gICAgcmV0dXJuIGV4cG9ydGVkQ29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVQYXJ0aWFsKHBhcnRpYWwpIHtcbiAgcGFydGlhbC5fX2ludEZ1bmN0aW9uID0gJ3BhcnQnO1xuICBwYXJ0aWFsLnRvU3RyaW5nID0gY3JlYXRlVG9TdHJpbmcocGFydGlhbCk7XG4gIHJldHVybiBwYXJ0aWFsO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVHdWFyZGVkUGFydGlhbChvcmlnaW5hbFBhcnRpYWwsIGVudmVsb3BlKSB7XG4gIGlmICggIWlzSW50ZXJwb2xQYXJ0aWFsKG9yaWdpbmFsUGFydGlhbCkgKSB7XG4gICAgb3JpZ2luYWxQYXJ0aWFsID0gbm9PcDtcbiAgfVxuICByZXR1cm4gZGVmaW5lUGFydGlhbChlbnZlbG9wZShvcmlnaW5hbFBhcnRpYWwpKTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVja2VyICovXG5mdW5jdGlvbiBjbGVhbnNlQXJndW1lbnRzKGFyciwgc3RhcnRJZHgpIHtcbiAgZm9yICggdmFyIGkgPSBzdGFydElkeCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgIGlmICggYXJyW2ldID09PSBudWxsICkge1xuICAgICAgYXJyW2ldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShvYmosIHByb3BlcnR5KSB7XG4gIGlmICggb2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsICkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHJlcyA9IG9ialtwcm9wZXJ0eV07XG4gIHJldHVybiByZXMgPT09IG51bGwgPyB1bmRlZmluZWQgOiByZXM7XG59XG5cbmZ1bmN0aW9uIGdldFBhdGgob2JqKSB7XG4gIGZvciAoIHZhciBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgIGlmICggb2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsICkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb2JqID0gb2JqW2FyZ3VtZW50c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9iaiA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iajtcbn1cblxuZnVuY3Rpb24gYmluZFBhcnRpYWwoY3R4LCBmdW5jLCBjYWxsQXJncykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHNob3J0LWNpcmN1aXQgKi9cbiAgaWYgKCAhaXNJbnRlcnBvbEZ1bmN0aW9uKGZ1bmMpICkge1xuICAgIGlmICggY3R4Ll9faW50RXhwb3J0cyApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRpbmcgdG8gYmluZCBhbiB1bmJsZXNzZWQgZnVuY3Rpb25cIik7XG4gIH1cblxuICB2YXIgYXJnVGVtcGxhdGUgPSBbdW5kZWZpbmVkXS5jb25jYXQoY2FsbEFyZ3MpO1xuICBib3VuZFBhcnRpYWwuX19pbnRGdW5jdGlvbiA9IGZ1bmMuX19pbnRGdW5jdGlvbjtcbiAgYm91bmRQYXJ0aWFsLnRvU3RyaW5nID0gY3JlYXRlVG9TdHJpbmcoYm91bmRQYXJ0aWFsKTtcbiAgcmV0dXJuIGJvdW5kUGFydGlhbDtcblxuICBmdW5jdGlvbiBib3VuZFBhcnRpYWwod3JpdGVyKSB7XG4gICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgdmFyIGFwcGx5QXJncyA9IGFyZ1RlbXBsYXRlLnNsaWNlKDApLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGFwcGx5QXJnc1swXSA9IHdyaXRlcjtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcHBseUFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3AoZGF0YSwgbG9vcENhbGxiYWNrKSB7XG4gIHZhciBpLCBsZW4sIG5hbWUsIHZhbHVlO1xuXG4gIGlmICggaXNBcnJheShkYXRhKSApIHtcbiAgICBmb3IgKCBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgIHZhbHVlID0gZGF0YVtpXTtcbiAgICAgIGxvb3BDYWxsYmFjayh2YWx1ZSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICBpZiAoIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhICE9PSBudWxsICkge1xuICAgIHZhciBpdGVtcyA9IG9iamVjdEtleXMoZGF0YSk7XG4gICAgZm9yICggaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgbmFtZSA9IGl0ZW1zW2ldO1xuICAgICAgdmFsdWUgPSBkYXRhW25hbWVdO1xuICAgICAgbG9vcENhbGxiYWNrKHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlID09PSBudWxsID8gdW5kZWZpbmVkIDogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgXG4gIGlmICggaXNJbnRlcnBvbEdlbmVyYXRvcihkYXRhKSApIHtcbiAgICBmb3IgKCB2YWx1ZSA9IGRhdGEoKTsgdmFsdWUgIT09IHN0b3BJdGVyYXRpb247IHZhbHVlID0gZGF0YSgpICkge1xuICAgICAgbG9vcENhbGxiYWNrKHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhlYyhjdHgsIGZ1bmMsIGFyZ3MpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBzaG9ydC1jaXJjdWl0ICovXG4gIGlmICggIWlzSW50ZXJwb2xGdW5jdGlvbihmdW5jKSApIHtcbiAgICBpZiAoIGN0eC5fX2ludEV4cG9ydHMgKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0aW5nIHRvIGNhbGwgYW4gdW5ibGVzc2VkIGZ1bmN0aW9uXCIpO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG4vLyBFeHBvcnRlZCBGdW5jdGlvbnNcbmV4cG9ydHMuY3JlYXRlUnVudGltZSA9IGNyZWF0ZVJ1bnRpbWU7XG4iLCIvKlxuICogSW50ZXJwb2wgKExvZ2ljZnVsIEhUTUwgVGVtcGxhdGVzKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBzZWUgZG9jL0xJQ0VOU0UubWRcbiAqXG4gKiBAYXV0aG9yIFRob21hcyBTLiBCcmFkZm9yZCAoa29kZTRmb29kLml0KVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgaXNBcnJheSA9IHV0aWwuaXNBcnJheTtcbnZhciBvYmplY3RLZXlzID0gdXRpbC5vYmplY3RLZXlzO1xuXG5mdW5jdGlvbiBlbXB0eVN0cmluZygpIHtcbiAgcmV0dXJuICcnO1xufVxuXG52YXIgc3RvcEl0ZXJhdGlvbiA9IHtcbiAgX19pbnRTdG9wSXRlcmF0aW9uOiB0cnVlXG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gT2JqZWN0IGlzIGFuIEludGVycG9sIFJ1bnRpbWUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgT2JqZWN0IHRvIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJwb2xSdW50aW1lKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmIG9iai5fX2ludFJ1bnRpbWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBPYmplY3QgaXMgYW4gSW50ZXJwb2wgTm9kZSBNb2R1bGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgT2JqZWN0IHRvIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJwb2xOb2RlTW9kdWxlKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmIG9iai5fX2ludE5vZGVNb2R1bGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIEZ1bmN0aW9uIGlzIGEgY29tcGlsZWQgSW50ZXJwb2wgTW9kdWxlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgdGhlIEZ1bmN0aW9uIHRvIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJwb2xNb2R1bGUoZnVuYykge1xuICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgJiYgZnVuYy5fX2ludE1vZHVsZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEgRnVuY3Rpb24gaXMgJ2JsZXNzZWQnIGFzIEludGVycG9sLWNvbXBhdGlibGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyB0aGUgRnVuY3Rpb24gdG8gY2hlY2tcbiAqL1xuZnVuY3Rpb24gaXNJbnRlcnBvbEZ1bmN0aW9uKGZ1bmMpIHtcbiAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nICYmIGZ1bmMuX19pbnRGdW5jdGlvbjtcbn1cblxuLyoqXG4gKiBTYW1lIGFzIGlzSW50ZXJwb2xGdW5jdGlvbiBleGNlcHQgdGhhdCBpdCdzIGNoZWNraW5nIHNwZWNpZmljYWxseSBmb3JcbiAqIGEgZGVjbGFyZWQgcGFydGlhbC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIHRoZSBGdW5jdGlvbiB0byBjaGVja1xuICovXG5mdW5jdGlvbiBpc0ludGVycG9sUGFydGlhbChmdW5jKSB7XG4gIHJldHVybiB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJyAmJiBmdW5jLl9faW50RnVuY3Rpb24gPT09ICdwYXJ0Jztcbn1cblxuLyoqXG4gKiBTYW1lIGFzIGlzSW50ZXJwb2xGdW5jdGlvbiBleGNlcHQgdGhhdCBpdCdzIGNoZWNraW5nIHNwZWNpZmljYWxseSBmb3JcbiAqIGEgZ2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgdGhlIEZ1bmN0aW9uIHRvIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJwb2xHZW5lcmF0b3IoZnVuYykge1xuICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgJiYgZnVuYy5fX2ludEZ1bmN0aW9uID09PSAnZ2VuJztcbn1cblxuLyoqXG4gKiAnYmxlc3MnIGEgRnVuY3Rpb24gb3IgU3RyaW5nIGFzIGJlaW5nIEludGVycG9sLWNvbXBhdGlibGUuICBJbiB0aGUgY2FzZSBvZlxuICogYSBTdHJpbmcsIGl0IHdpbGwgbWFyayB0aGUgU3RyaW5nIGFzIGNhcGFibGUgb2YgYmVpbmcgcmVuZGVyZWQgd2l0aG91dCBcbiAqIGVzY2FwaW5nLiAgV2l0aCB0aGUgZXhjZXB0aW9uIG9mIGdlbmVyYXRvcnMsIGFsbCBGdW5jdGlvbnMgaW4gSW50ZXJwb2xcbiAqICB3aWxsIGJlIHBhc3NlZCBhIFdyaXRlciBpbnN0YW5jZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuIFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSB2YWx1ZSB0aGUgU3RyaW5nIG9yIEZ1bmN0aW9uIHRvICdibGVzcydcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZnVuY1R5cGVdIHRoZSBibGVzc2VkIHR5cGUgKCd3cmFwJyBvciAnc3RyaW5nJyBieSBkZWZhdWx0KSBcbiAqL1xuZnVuY3Rpb24gYmxlc3ModmFsdWUsIGZ1bmNUeXBlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gIHN3aXRjaCAoIHR5cGUgKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHZhciBibGVzc1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9O1xuICAgICAgYmxlc3NTdHJpbmcudG9TdHJpbmcgPSBibGVzc1N0cmluZztcbiAgICAgIGJsZXNzU3RyaW5nLl9faW50RnVuY3Rpb24gPSAnc3RyaW5nJztcbiAgICAgIHJldHVybiBibGVzc1N0cmluZztcblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGlmICggdmFsdWUuX19pbnRGdW5jdGlvbiApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUuX19pbnRGdW5jdGlvbiA9IGZ1bmNUeXBlIHx8ICd3cmFwJztcbiAgICAgIHZhbHVlLnRvU3RyaW5nID0gZW1wdHlTdHJpbmc7XG4gICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgdG8gYmxlc3MgbXVzdCBiZSBhIEZ1bmN0aW9uIG9yIFN0cmluZ1wiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSh2YWx1ZSwgc3RyaW5naWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgIHJlc3VsdFtpXSA9IHN0cmluZ2lmaWVyKHZhbHVlW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmpvaW4oJyAnKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIHByb3ZpZGVkIHZhbHVlIGZvciBJbnRlcnBvbCdzIHB1cnBvc2VzLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIHRoZSB2YWx1ZSB0byBzdHJpbmdpZnlcbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gIHN3aXRjaCAoIHR5cGVvZiB2YWx1ZSApIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiAnJyArIHZhbHVlO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIHZhbHVlLl9faW50RnVuY3Rpb24gPyB2YWx1ZS50b1N0cmluZygpIDogJyc7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKCBpc0FycmF5KHZhbHVlKSApIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlLCBzdHJpbmdpZnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gJycgOiB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG52YXIgYW1wUmVnZXggPSAvJi9nO1xudmFyIGx0UmVnZXggPSAvPC9nO1xudmFyIGd0UmVnZXggPSAvPi9nO1xudmFyIHF1b3RlUmVnZXggPSAvXCIvZztcbnZhciBhcG9zUmVnZXggPSAvJy9nO1xuXG4vKipcbiAqIEVzY2FwZSB0aGUgcHJvdmlkZWQgdmFsdWUgZm9yIHRoZSBwdXJwb3NlcyBvZiByZW5kZXJpbmcgaXQgYXMgYW4gSFRNTFxuICogYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIHRoZSB2YWx1ZSB0byBlc2NhcGVcbiAqL1xudmFyIGVzY2FwZUF0dHJpYnV0ZSA9IGNyZWF0ZUVzY2FwZWRTdHJpbmdpZmllcigvWyY8PidcIl0vZywgcmVwbGFjZUF0dHJpYnV0ZSk7XG5cbi8qKlxuICogRXNjYXBlIHRoZSBwcm92aWRlZCB2YWx1ZSBmb3IgdGhlIHB1cnBvc2VzIG9mIHJlbmRlcmluZyBpdCBhcyBIVE1MXG4gKiBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIHRoZSB2YWx1ZSB0byBlc2NhcGVcbiAqL1xudmFyIGVzY2FwZUNvbnRlbnQgPSBjcmVhdGVFc2NhcGVkU3RyaW5naWZpZXIoL1smPD5dL2csIHJlcGxhY2VDb250ZW50KTtcblxuZnVuY3Rpb24gcmVwbGFjZUF0dHJpYnV0ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShhbXBSZWdleCwgJyZhbXA7JylcbiAgICAgICAgICAgICAgLnJlcGxhY2UobHRSZWdleCwgJyZsdDsnKVxuICAgICAgICAgICAgICAucmVwbGFjZShndFJlZ2V4LCAnJmd0OycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKHF1b3RlUmVnZXgsICcmcXVvdDsnKVxuICAgICAgICAgICAgICAucmVwbGFjZShhcG9zUmVnZXgsICcmIzM5OycpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQ29udGVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShhbXBSZWdleCwgJyZhbXA7JylcbiAgICAgICAgICAgICAgLnJlcGxhY2UobHRSZWdleCwgJyZsdDsnKVxuICAgICAgICAgICAgICAucmVwbGFjZShndFJlZ2V4LCAnJmd0OycpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFc2NhcGVkU3RyaW5naWZpZXIoZXNjYXBlUmVnZXgsIHJlcGxhY2VGdW5jdGlvbikge1xuICByZXR1cm4gZXNjYXBlZFN0cmluZ2lmaWVyO1xuXG4gIC8vIFRoaXMgaXMgdmVyeSBzaW1pbGFyIHRvICdzdHJpbmdpZnknIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiAnc3RyaW5nJ1xuICBmdW5jdGlvbiBlc2NhcGVkU3RyaW5naWZpZXIodmFsdWUpIHtcbiAgICBzd2l0Y2ggKCB0eXBlb2YgdmFsdWUgKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gZXNjYXBlUmVnZXgudGVzdCh2YWx1ZSkgPyByZXBsYWNlRnVuY3Rpb24odmFsdWUpIDogdmFsdWU7XG5cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlO1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICByZXR1cm4gdmFsdWUuX19pbnRGdW5jdGlvbiA/IHZhbHVlLnRvU3RyaW5nKCkgOiAnJztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKCBpc0FycmF5KHZhbHVlKSApIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUsIGVzY2FwZWRTdHJpbmdpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gJycgOiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVkIHZhbHVlIGlzICp0cnV0aHkqIGJ5IEludGVycG9sJ3NcbiAqIHN0YW5kYXJkcy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSB0aGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoZSB2YWx1ZSBjb25zdGl0dXRlcyBhICp0cnV0aHkqIG9uZVxuICovXG5mdW5jdGlvbiBpc1RydXRoeSh2YWx1ZSkge1xuICBpZiAoICF2YWx1ZSApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCBpc0FycmF5KHZhbHVlKSApIHtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoID4gMDtcbiAgfVxuICBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgKSB7XG4gICAgcmV0dXJuIG9iamVjdEtleXModmFsdWUpLmxlbmd0aCA+IDA7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlZCB2YWx1ZSBpcyAqZmFsc3kqIGJ5IEludGVycG9sJ3NcbiAqIHN0YW5kYXJkcy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSB0aGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGlmIHRoZSB2YWx1ZSBjb25zdGl0dXRlcyBhICpmYWxzeSogb25lXG4gKi9cbmZ1bmN0aW9uIGlzRmFsc3kodmFsdWUpIHtcbiAgaWYgKCAhdmFsdWUgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCBpc0FycmF5KHZhbHVlKSApIHtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSAwO1xuICB9XG4gIGlmICggdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCApIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gRXhwb3J0ZWQgRnVuY3Rpb25zXG5leHBvcnRzLnN0b3BJdGVyYXRpb24gPSBzdG9wSXRlcmF0aW9uO1xuZXhwb3J0cy5pc0ludGVycG9sUnVudGltZSA9IGlzSW50ZXJwb2xSdW50aW1lO1xuZXhwb3J0cy5pc0ludGVycG9sTm9kZU1vZHVsZSA9IGlzSW50ZXJwb2xOb2RlTW9kdWxlO1xuZXhwb3J0cy5pc0ludGVycG9sTW9kdWxlID0gaXNJbnRlcnBvbE1vZHVsZTtcbmV4cG9ydHMuaXNJbnRlcnBvbEZ1bmN0aW9uID0gaXNJbnRlcnBvbEZ1bmN0aW9uO1xuZXhwb3J0cy5pc0ludGVycG9sUGFydGlhbCA9IGlzSW50ZXJwb2xQYXJ0aWFsO1xuZXhwb3J0cy5pc0ludGVycG9sR2VuZXJhdG9yID0gaXNJbnRlcnBvbEdlbmVyYXRvcjtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuZXhwb3J0cy5lc2NhcGVBdHRyaWJ1dGUgPSBlc2NhcGVBdHRyaWJ1dGU7XG5leHBvcnRzLmVzY2FwZUNvbnRlbnQgPSBlc2NhcGVDb250ZW50O1xuZXhwb3J0cy5ibGVzcyA9IGJsZXNzO1xuZXhwb3J0cy5pc1RydXRoeSA9IGlzVHJ1dGh5O1xuZXhwb3J0cy5pc0ZhbHN5ID0gaXNGYWxzeTtcbiIsIi8qXG4gKiBJbnRlcnBvbCAoTG9naWNmdWwgSFRNTCBUZW1wbGF0ZXMpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIHNlZSBkb2MvTElDRU5TRS5tZFxuICpcbiAqIEBhdXRob3IgVGhvbWFzIFMuIEJyYWRmb3JkIChrb2RlNGZvb2QuaXQpXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEludGVycG9sLXNwZWNpZmljIHV0aWxpdGllcyBhbmQgcG9seWZpbGxzLiAgVGhlc2UgYXJlIGltcGxlbWVudGVkICphcypcbi8vIEludGVycG9sIHVzZXMgdGhlbSByYXRoZXIgdGhhbiBiZWluZyBzdHJpY3RseSBFUzUgY29tcGF0aWJsZS5cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuLyogaXN0YW5idWwgaWdub3JlIGlmOiB3b24ndCBoYXBwZW4gaW4gbm9kZSAqL1xuaWYgKCAhaXNBcnJheSApIHtcbiAgaXNBcnJheSA9IGZ1bmN0aW9uIF9pc0FycmF5KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzO1xuLyogaXN0YW5idWwgaWdub3JlIGlmOiB3b24ndCBoYXBwZW4gaW4gbm9kZSAqL1xuaWYgKCAhb2JqZWN0S2V5cyApIHtcbiAgb2JqZWN0S2V5cyA9IGZ1bmN0aW9uIF9vYmplY3RLZXlzKG9iaikge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICggdmFyIGtleSBpbiBvYmogKSB7XG4gICAgICBpZiAoIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG59XG5cbnZhciBleHRlbmRPYmplY3Q7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogd29uJ3QgaGFwcGVuIGluIG5vZGUgKi9cbnZhciB0ZXN0UHJvdG8gPSB7IF9fcHJvdG9fXzogeyB3b3JrczogdHJ1ZSB9IH07ICAgICAgICAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbmlmICggdGVzdFByb3RvLndvcmtzICYmIG9iamVjdEtleXModGVzdFByb3RvKS5sZW5ndGggPT09IDAgKSB7XG4gIGV4dGVuZE9iamVjdCA9IGZ1bmN0aW9uIF9mYXN0RXh0ZW5kT2JqZWN0KG9iaikge1xuICAgIHJldHVybiB7IF9fcHJvdG9fXzogb2JqIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICB9O1xufVxuZWxzZSBpZiAoIE9iamVjdC5jcmVhdGUgKSB7XG4gIGV4dGVuZE9iamVjdCA9IE9iamVjdC5jcmVhdGU7XG59XG5lbHNlIHtcbiAgZXh0ZW5kT2JqZWN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGYWtlQ29uc3RydWN0b3IoKSB7fVxuICAgIHJldHVybiBmdW5jdGlvbiBfc2xvd0V4dGVuZE9iamVjdChvYmopIHtcbiAgICAgIEZha2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBvYmo7XG4gICAgICByZXR1cm4gbmV3IEZha2VDb25zdHJ1Y3RvcigpO1xuICAgIH07XG4gIH0pKCk7XG59XG5cbmZ1bmN0aW9uIG1peGluKHRhcmdldCkge1xuICBmb3IgKCB2YXIgaSA9IDEsIGlsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrICkge1xuICAgIHZhciBzcmMgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKCB0eXBlb2Ygc3JjICE9PSAnb2JqZWN0JyB8fCBzcmMgPT09IG51bGwgfHwgaXNBcnJheShzcmMpICkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhzcmMpO1xuICAgIGZvciAoIHZhciBqID0ga2V5cy5sZW5ndGggLSAxOyBqID49IDA7IGotLSApIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIGVhY2g7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogd29uJ3QgaGFwcGVuIGluIG5vZGUgKi9cbmlmICggQXJyYXkucHJvdG90eXBlLmZvckVhY2ggKSB7XG4gIGVhY2ggPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbm5lciA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICAgIHJldHVybiBmdW5jdGlvbiBfZWFjaCh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBpbm5lci5jYWxsKHZhbHVlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgfSkoKTtcbn1cbmVsc2Uge1xuICBlYWNoID0gZnVuY3Rpb24gX2VhY2goYXJyLCBjYWxsYmFjaykge1xuICAgIGZvciAoIHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgY2FsbGJhY2soYXJyW2ldLCBpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBtYXA7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogd29uJ3QgaGFwcGVuIGluIG5vZGUgKi9cbmlmICggQXJyYXkucHJvdG90eXBlLm1hcCApIHtcbiAgbWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5uZXIgPSBBcnJheS5wcm90b3R5cGUubWFwO1xuICAgIHJldHVybiBmdW5jdGlvbiBfbWFwKHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGlubmVyLmNhbGwodmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9KSgpO1xufVxuZWxzZSB7XG4gIG1hcCA9IGZ1bmN0aW9uIF9tYXAoYXJyLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBlYWNoKGFyciwgZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgIHJlc3VsdFtpXSA9IGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbnZhciBmaWx0ZXI7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogd29uJ3QgaGFwcGVuIGluIG5vZGUgKi9cbmlmICggQXJyYXkucHJvdG90eXBlLmZpbHRlciApIHtcbiAgZmlsdGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5uZXIgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyO1xuICAgIHJldHVybiBmdW5jdGlvbiBfZmlsdGVyKHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGlubmVyLmNhbGwodmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9KSgpO1xufVxuZWxzZSB7XG4gIGZpbHRlciA9IGZ1bmN0aW9uIF9maWx0ZXIoYXJyLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBlYWNoKGFyciwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmICggIWNhbGxiYWNrKGl0ZW0pICkge1xuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxmTWFwKGFyciwgY2FsbGJhY2spIHtcbiAgZWFjaChhcnIsIGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgYXJyW2ldID0gY2FsbGJhY2soaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gYXJyO1xufVxuXG4vLyBFeHBvcnRlZCBGdW5jdGlvbnNcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5leHBvcnRzLmV4dGVuZE9iamVjdCA9IGV4dGVuZE9iamVjdDtcbmV4cG9ydHMub2JqZWN0S2V5cyA9IG9iamVjdEtleXM7XG5leHBvcnRzLm1peGluID0gbWl4aW47XG5cbmV4cG9ydHMuZWFjaCA9IGVhY2g7XG5leHBvcnRzLm1hcCA9IG1hcDtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuZXhwb3J0cy5zZWxmTWFwID0gc2VsZk1hcDtcbiIsIi8qXG4gKiBJbnRlcnBvbCAoTG9naWNmdWwgSFRNTCBUZW1wbGF0ZXMpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIHNlZSBkb2MvTElDRU5TRS5tZFxuICpcbiAqIEBhdXRob3IgVGhvbWFzIFMuIEJyYWRmb3JkIChrb2RlNGZvb2QuaXQpXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHN0cmluZyA9IHJlcXVpcmUoJy4vc3RyaW5nJyk7XG5cbnZhciBjcmVhdGVTdHJpbmdXcml0ZXIgPSBzdHJpbmcuY3JlYXRlU3RyaW5nV3JpdGVyO1xuXG52YXIgUkVQTEFDRSA9IGNyZWF0ZURPTVdyaXRlci5SRVBMQUNFID0gJ3JlcGxhY2UnO1xudmFyIEFQUEVORCA9IGNyZWF0ZURPTVdyaXRlci5BUFBFTkQgPSAnYXBwZW5kJztcbnZhciBJTlNFUlQgPSBjcmVhdGVET01Xcml0ZXIuSU5TRVJUID0gJ2luc2VydCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIERPTVdyaXRlci4gIEEgRE9NV3JpdGVyIGF0dGFjaGVzIGl0c2VsZiB0byBhIERPTSBFbGVtZW50LFxuICogYW5kIHdpbGwgbWFuaXB1bGF0ZSB0aGF0IEVsZW1lbnQncyBjb250ZW50IHdoZW4gYSB0ZW1wbGF0ZSBpcyByZW5kZXJlZFxuICogd2l0aCBpdC4gIFRoZSB3cml0ZXIgaXMgdmVyeSBzaW1wbGUgYW5kIHdvbid0IGNvdmVyIGFsbCB1c2UtY2FzZXMsIGl0XG4gKiBhbHNvIG1heSBub3QgYmUgdGhlIG1vc3QgcGVyZm9ybWFudCBhcHByb2FjaC5cbiAqXG4gKiBUaGUgZGVmYXVsdCBtb2RlIGlzIFJFUExBQ0UsIG1lYW5pbmcgYWxsIG9mIHRoZSBFbGVtZW50J3MgY2hpbGRyZW4gYXJlXG4gKiByZXBsYWNlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIHRlbXBsYXRlIGlzIHJlbmRlcmVkLiAgSU5TRVJUIGFuZCBBUFBFTkRcbiAqIHdpbGwgaW5zZXJ0IG5ldyByZW5kZXJpbmdzIHRvIHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIHRoZSBjaGlsZCBsaXN0XG4gKiByZXNwZWN0aXZlbHkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRFbGVtZW50IHRoZSBFbGVtZW50IHRvIHdoaWNoIHRoaXMgRE9NV3JpdGVyIGF0dGFjaGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gW3JlbmRlck1vZGVdIHRoZSBET00gcmVuZGVyaW5nIG1vZGU6IFJFUExBQ0V8QVBQRU5EfElOU0VSVFxuICovXG4gXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogYnJvd3Nlci1vbmx5ICovXG5mdW5jdGlvbiBjcmVhdGVET01Xcml0ZXIocGFyZW50RWxlbWVudCwgcmVuZGVyTW9kZSkge1xuICB2YXIgd3JpdGVyID0gY3JlYXRlU3RyaW5nV3JpdGVyKCk7XG4gIHZhciB3cml0ZXJEb25lID0gd3JpdGVyLmRvbmU7XG5cbiAgaWYgKCByZW5kZXJNb2RlID09PSB1bmRlZmluZWQgKSB7XG4gICAgcmVuZGVyTW9kZSA9IFJFUExBQ0U7XG4gIH1cblxuICBzd2l0Y2ggKCByZW5kZXJNb2RlICkge1xuICAgIGNhc2UgQVBQRU5EOlxuICAgICAgd3JpdGVyLmRvbmUgPSBhcHBlbmRFbmRSZW5kZXI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSU5TRVJUOlxuICAgICAgd3JpdGVyLmRvbmUgPSBpbnNlcnRFbmRSZW5kZXI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgUkVQTEFDRTpcbiAgICAgIHdyaXRlci5kb25lID0gcmVwbGFjZUVuZFJlbmRlcjtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVuZGVyTW9kZTogXCIgKyByZW5kZXJNb2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEVuZFJlbmRlcigpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IHdyaXRlckRvbmUoKTtcbiAgICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRFbmRSZW5kZXIoKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSB3cml0ZXJEb25lKCk7XG4gICAgcGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBwYXJlbnRFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUVuZFJlbmRlcigpIHtcbiAgICBwYXJlbnRFbGVtZW50LmlubmVySFRNTCA9IHdyaXRlckRvbmUoKTtcbiAgfVxufVxuXG4vLyBFeHBvcnRlZCBGdW5jdGlvbnNcbmV4cG9ydHMuY3JlYXRlRE9NV3JpdGVyID0gY3JlYXRlRE9NV3JpdGVyO1xuIiwiLypcbiAqIEludGVycG9sIChMb2dpY2Z1bCBIVE1MIFRlbXBsYXRlcylcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogc2VlIGRvYy9MSUNFTlNFLm1kXG4gKlxuICogQGF1dGhvciBUaG9tYXMgUy4gQnJhZGZvcmQgKGtvZGU0Zm9vZC5pdClcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGRvbVdyaXRlciA9IHJlcXVpcmUoJy4vZG9tJyk7XG52YXIgbnVsbFdyaXRlciA9IHJlcXVpcmUoJy4vbnVsbCcpO1xudmFyIHN0cmluZ1dyaXRlciA9IHJlcXVpcmUoJy4vc3RyaW5nJyk7XG5cbi8vIEV4cG9ydGVkIEZ1bmN0aW9uc1xuZXhwb3J0cy5jcmVhdGVET01Xcml0ZXIgPSBkb21Xcml0ZXIuY3JlYXRlRE9NV3JpdGVyO1xuZXhwb3J0cy5jcmVhdGVOdWxsV3JpdGVyID0gbnVsbFdyaXRlci5jcmVhdGVOdWxsV3JpdGVyO1xuZXhwb3J0cy5jcmVhdGVTdHJpbmdXcml0ZXIgPSBzdHJpbmdXcml0ZXIuY3JlYXRlU3RyaW5nV3JpdGVyO1xuIiwiLypcbiAqIEludGVycG9sIChMb2dpY2Z1bCBIVE1MIFRlbXBsYXRlcylcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogc2VlIGRvYy9MSUNFTlNFLm1kXG4gKlxuICogQGF1dGhvciBUaG9tYXMgUy4gQnJhZGZvcmQgKGtvZGU0Zm9vZC5pdClcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmZ1bmN0aW9uIG5vT3AoKSB7fVxuXG4vKipcbiAqIENyZWF0ZXMgYSBOdWxsV3JpdGVyLiAgQWxsIGNhbGxzIHRvIHRoaXMgd3JpdGVyIGZpbmQgdGhlaXIgd2F5IGludG8gdGhlXG4gKiBiaXQgYnVja2V0LiAgSXRzIHByaW1hcnkgcHVycG9zZSBpcyB0byBzdXBwb3J0IHRoZSBiYWNrZ3JvdW5kIHJlbmRlcmluZyBvZlxuICogbW9kdWxlcyBpbiBvcmRlciB0byB5aWVsZCB0aGVpciBleHBvcnRlZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOdWxsV3JpdGVyKCkge1xuICByZXR1cm4ge1xuICAgIGRvbmU6IG5vT3AsXG4gICAgcmVzZXQ6IG5vT3AsXG4gICAgc3RhcnRFbGVtZW50OiBub09wLFxuICAgIHNlbGZDbG9zZUVsZW1lbnQ6IG5vT3AsXG4gICAgZW5kRWxlbWVudDogbm9PcCxcbiAgICBjb21tZW50OiBub09wLFxuICAgIGRvY1R5cGU6IG5vT3AsXG4gICAgY29udGVudDogbm9PcCxcbiAgICByYXc6IG5vT3BcbiAgfTtcbn1cblxuLy8gRXhwb3J0ZWQgRnVuY3Rpb25zXG5leHBvcnRzLmNyZWF0ZU51bGxXcml0ZXIgPSBjcmVhdGVOdWxsV3JpdGVyO1xuIiwiLypcbiAqIEludGVycG9sIChMb2dpY2Z1bCBIVE1MIFRlbXBsYXRlcylcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogc2VlIGRvYy9MSUNFTlNFLm1kXG4gKlxuICogQGF1dGhvciBUaG9tYXMgUy4gQnJhZGZvcmQgKGtvZGU0Zm9vZC5pdClcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHR5cGVzID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgc3RyaW5naWZ5ID0gdHlwZXMuc3RyaW5naWZ5O1xudmFyIGVzY2FwZUF0dHJpYnV0ZSA9IHR5cGVzLmVzY2FwZUF0dHJpYnV0ZTtcbnZhciBlc2NhcGVDb250ZW50ID0gdHlwZXMuZXNjYXBlQ29udGVudDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU3RyaW5nV3JpdGVyLiAgSW50ZXJwb2wgd2lsbCBjcmVhdGUgb25lIGJ5IGRlZmF1bHQgaWYgaXQgaXMgbm90XG4gKiBwcm92aWRlZCBhcyBhbiBvcHRpb24gdG8gYSBjb21waWxlZCB0ZW1wbGF0ZS4gIEEgU3RyaW5nV3JpdGVyIG1hbmFnZXMgdGhlXG4gKiB3cml0aW5nIG9mIGNvbnRlbnQgYXMgYW4gdW5kZXJseWluZyBBcnJheSBvZiBTdHJpbmdzLiAgVGhpcyBBcnJheSBpcyBqb2luZWRcbiAqIGFuZCByZXR1cm5lZCB3aGVuIHRoZSBgZG9uZSgpYCBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1dyaXRlcigpIHtcbiAgdmFyIGJ1ZmZlciA9ICcnO1xuXG4gIHJldHVybiB7XG4gICAgZG9uZTogZG9uZSxcbiAgICByZXNldDogcmVzZXQsXG4gICAgc3RhcnRFbGVtZW50OiBzdGFydEVsZW1lbnQsXG4gICAgc2VsZkNsb3NlRWxlbWVudDogc2VsZkNsb3NlRWxlbWVudCxcbiAgICBlbmRFbGVtZW50OiBlbmRFbGVtZW50LFxuICAgIGNvbW1lbnQ6IGNvbW1lbnQsXG4gICAgZG9jVHlwZTogZG9jVHlwZSxcbiAgICBjb250ZW50OiBjb250ZW50LFxuICAgIHJhdzogcmF3XG4gIH07XG5cbiAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICB2YXIgcmVzdWx0ID0gYnVmZmVyO1xuICAgIGJ1ZmZlciA9ICcnO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBidWZmZXIgPSAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgZm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuICAgICAgdmFyIHZhbCA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIGlmICggdHlwZW9mIHZhbCAhPT0gJ2Jvb2xlYW4nICkge1xuICAgICAgICBidWZmZXIgKz0gXCIgXCIgKyBzdHJpbmdpZnkoa2V5KSArIFwiPVxcXCJcIiArIGVzY2FwZUF0dHJpYnV0ZSh2YWwpICsgXCJcXFwiXCI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCB2YWwgKSB7XG4gICAgICAgIGJ1ZmZlciArPSBcIiBcIiArIHN0cmluZ2lmeShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0RWxlbWVudCh0YWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgYnVmZmVyICs9IFwiPFwiICsgc3RyaW5naWZ5KHRhZ05hbWUpO1xuICAgIHdyaXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgICBidWZmZXIgKz0gXCI+XCI7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxmQ2xvc2VFbGVtZW50KHRhZ05hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBidWZmZXIgKz0gXCI8XCIgKyBzdHJpbmdpZnkodGFnTmFtZSk7XG4gICAgd3JpdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAgIGJ1ZmZlciArPSBcIiAvPlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kRWxlbWVudCh0YWdOYW1lKSB7XG4gICAgYnVmZmVyICs9IFwiPC9cIiArIHN0cmluZ2lmeSh0YWdOYW1lKSArIFwiPlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWVudChjb250ZW50KSB7XG4gICAgYnVmZmVyICs9IFwiPCEtLVwiICsgY29udGVudCArIFwiLS0+XCI7XG4gIH1cblxuICBmdW5jdGlvbiBkb2NUeXBlKHJvb3RFbGVtZW50KSB7XG4gICAgYnVmZmVyICs9IFwiPCFET0NUWVBFIFwiICsgc3RyaW5naWZ5KHJvb3RFbGVtZW50KSArIFwiPlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gY29udGVudCh2YWx1ZSkge1xuICAgIGJ1ZmZlciArPSBlc2NhcGVDb250ZW50KHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhdyh2YWx1ZSkge1xuICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgfVxufVxuXG4vLyBFeHBvcnRlZCBGdW5jdGlvbnNcbmV4cG9ydHMuY3JlYXRlU3RyaW5nV3JpdGVyID0gY3JlYXRlU3RyaW5nV3JpdGVyO1xuIixudWxsXX0=
