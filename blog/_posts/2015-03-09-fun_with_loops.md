---
layout: post
title: Fun with Loops!
author: Thom
---
On the surface, Interpol loops seem like a simple way to iterate over a set of items.  But appearances can often be deceiving, and `for` loops are no exception.  Let's dive a little deeper into what you can accomplish with them.

## Simple Looping
The most basic use case for a loop would be to iterate over a set of items, typically a list.  This example loops over a set of items resulting from the expression `people`, passing each item as the `person` variable into the loop's body:

```ruby
for person in people
  person | "Hello %name"
end
```

## Filtering
Looping doesn't stop there.  You can also filter the items yielded from a range.  This is accomplished by adding a guard to your range clauses.  So if you want to loop over only those persons who are logged in:

```ruby
for person in people when person.logged_in
  person | "%name is logged in"
end
```

You can also include an `else` clause, in case nothing is generated by the loop:

```ruby
for person in people when person.logged_in
  person | "%name is logged in"
else
  "Nobody is logged in"
end
```

## Nested Looping
What if each person you're looping over has a set of friends that you'd like to display instead of just the person's name?  Then it's very easy to add a nested range to your loop:

```ruby
for person in people, friend in person.friends
  "%friend_name is a friend of %person_name" [
    friend_name = friend.name,
    person_name = person.name
  ]
end
```

You can even add guards to the individual ranges:

```ruby
for person in people when person.logged_in, 
    friend in person.friends when friend.logged_in
  "%friend_name is a friend of %person_name" [
    friend_name = friend.name,
    person_name = person.name
  ]
else
  "Nobody is available for a chat"
end
```

## Joins!
Yes, you read that correctly.  There's no reason you can't leverage Interpol loops to perform set joining between disparate collections.  Guard clauses are all you need to make it happen.  

If you iterate over separate collections, what you'll be generating without guards is a cartesian product.  We want to avoid that, so we add a guard to the second range that will filter out any unrelated items.  This loop will generate a set of mutual friends.

```ruby
for person1 in people, 
    person2 in people where person2.parent == person1.id
  "%name1 is the parent of %name2" [
    name1 = person1.name,
    name2 = person2.name
  ]
end
```

Obviously this can become very expensive, but when you need it, the functionality is there for you.

By the way, you may have noticed that I used the keyword `where` in this example instead of `when`.  These two keywords are synonymous and can be used interchangeably depending on how you want your guards to read.

## List Comprehensions
Let's face it, sometimes you just need to mangle a list.  That's why List Comprehensions are here to help you.  Nearly all the powers of loops are also extended to list comprehensions, which make them a very powerful way to reimagine your data for further processing.

For example, this will create a new list called `names` with the full names of all people who are logged in:

```python
let names = [
  p.first + ' ' p.last 
  for p in people when p.logged_in
]
```

With the exception of `else` branching, all of the capabilities of a `for` loop are here, including guards and multiple ranges.

## Lists Aren't Everything!
Looping applies both to Lists and to Generators, the latter of which we haven't yet talked about.  A Generator is a special Interpol function that, when called multiple times, will generate a set of values.  There are a few functions in the standard Interpol modules that act as generators.  For example:

```ruby
from math import range
[ "key_%i" for i in range(1,10) ]
# results in: key_1 key_2 key_3 key_4 ...
```

When `range(1,10)` is called it returns a generator function.  Each time that function is called, it will return the next value in the range, starting at 1 and ending at 10.  Under the hood, the generator is returning a sentinel object when the sequence is complete, but you don't need to worry about that unless you're implementing your own generator.

## In Summary
So there you have it.  Loops in all their forms!  As you can see, you have a lot of options for iterating over and transforming your data.  This means far less massaging of data that you'll have to perform in your controller code.  And how can that be bad?
