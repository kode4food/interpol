<!DOCTYPE html><html lang="en"><head><title>runtime</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="runtime"><meta name="groc-project-path" content="lib/runtime.js"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path">lib/runtime.js</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="cm">/*</span>
<span class="cm"> * Interpol (Templates Sans Facial Hair)</span>
<span class="cm"> * Licensed under the MIT License</span>
<span class="cm"> * see doc/LICENSE.md</span>
<span class="cm"> *</span>
<span class="cm"> * @author Thomas S. Bradford (kode4food.it)</span>
<span class="cm"> */</span>

<span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./util&#39;</span><span class="p">)</span>
  <span class="p">,</span> <span class="nx">format</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./format&#39;</span><span class="p">)</span>
  <span class="p">,</span> <span class="nx">match</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./match&#39;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">arrayWriter</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./writers/array&#39;</span><span class="p">)</span>
  <span class="p">,</span> <span class="nx">nullWriter</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./writers/null&#39;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">isArray</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">isArray</span>
  <span class="p">,</span> <span class="nx">mixin</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">mixin</span>
  <span class="p">,</span> <span class="nx">configure</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">configure</span>
  <span class="p">,</span> <span class="nx">extendContext</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">extendContext</span>
  <span class="p">,</span> <span class="nx">freezeObject</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">freezeObject</span>
  <span class="p">,</span> <span class="nx">objectKeys</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">objectKeys</span>
  <span class="p">,</span> <span class="nx">isInterpolFunction</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">isInterpolFunction</span>
  <span class="p">,</span> <span class="nx">createStaticMixin</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">createStaticMixin</span>
  <span class="p">,</span> <span class="nx">stringify</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">stringify</span>
  <span class="p">,</span> <span class="nx">buildTemplate</span> <span class="o">=</span> <span class="nx">format</span><span class="p">.</span><span class="nx">buildTemplate</span>
  <span class="p">,</span> <span class="nx">isMatchingObject</span> <span class="o">=</span> <span class="nx">match</span><span class="p">.</span><span class="nx">isMatchingObject</span>
  <span class="p">,</span> <span class="nx">buildMatcher</span> <span class="o">=</span> <span class="nx">match</span><span class="p">.</span><span class="nx">buildMatcher</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">TemplateCacheMax</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">slice</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">globalOptions</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">writer</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">errorCallback</span><span class="o">:</span> <span class="kc">null</span> <span class="p">}</span>
  <span class="p">,</span> <span class="nx">globalContext</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="p">,</span> <span class="nx">globalResolvers</span> <span class="o">=</span> <span class="p">[];</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Converts a pre-compiled JSON instance to an evaluative runtime closure.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>parseOutput must be an Object.</strong><br/>(the pre-compiled JSON to use)</p></li>
<li><p><strong>localOptions is optional and must be an Object.</strong><br/>(Object for configuring the closure)</p></li>
<li><p><strong>resolvers is optional and must be a [Resolver].</strong><br/>(Resolvers to use for performing imports)</p></li>
<li><p><strong>cache is optional and must be a boolean.</strong><br/>(whether or not to cache resolved imports)</p></li>
</ul></div></div><div class="code"><div class="wrapper"><span class="kd">function</span> <span class="nx">buildRuntime</span><span class="p">(</span><span class="nx">parseOutput</span><span class="p">,</span> <span class="nx">localOptions</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">createArrayWriter</span> <span class="o">=</span> <span class="nx">arrayWriter</span><span class="p">.</span><span class="nx">createArrayWriter</span>
    <span class="p">,</span> <span class="nx">NullWriter</span> <span class="o">=</span> <span class="nx">nullWriter</span><span class="p">.</span><span class="nx">createNullWriter</span><span class="p">();</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A lookup table of code-path generators</p></div></div><div class="code"><div class="wrapper">  <span class="kd">var</span> <span class="nx">Evaluators</span> <span class="o">=</span> <span class="nx">freezeObject</span><span class="p">({</span>
    <span class="nx">im</span><span class="o">:</span> <span class="nx">createImportEvaluator</span><span class="p">,</span>
    <span class="nx">de</span><span class="o">:</span> <span class="nx">createPartialEvaluator</span><span class="p">,</span>
    <span class="nx">bi</span><span class="o">:</span> <span class="nx">createBindEvaluator</span><span class="p">,</span>
    <span class="nx">ca</span><span class="o">:</span> <span class="nx">createCallEvaluator</span><span class="p">,</span>
    <span class="nx">as</span><span class="o">:</span> <span class="nx">createAssignEvaluator</span><span class="p">,</span>
    <span class="nx">op</span><span class="o">:</span> <span class="nx">createOpenTagEvaluator</span><span class="p">,</span>
    <span class="nx">cl</span><span class="o">:</span> <span class="nx">createCloseTagEvaluator</span><span class="p">,</span>
    <span class="nx">ct</span><span class="o">:</span> <span class="nx">createCommentTagEvaluator</span><span class="p">,</span>
    <span class="nx">dt</span><span class="o">:</span> <span class="nx">createDocTypeEvaluator</span><span class="p">,</span>
    <span class="nx">ou</span><span class="o">:</span> <span class="nx">createOutputEvaluator</span><span class="p">,</span>
    <span class="nx">ra</span><span class="o">:</span> <span class="nx">createRawOutputEvaluator</span><span class="p">,</span>
    <span class="nx">fr</span><span class="o">:</span> <span class="nx">createForEvaluator</span><span class="p">,</span>
    <span class="nx">us</span><span class="o">:</span> <span class="nx">createUsingEvaluator</span><span class="p">,</span>
    <span class="nx">cn</span><span class="o">:</span> <span class="nx">createConditionalEvaluator</span><span class="p">,</span>
    <span class="nx">or</span><span class="o">:</span> <span class="nx">createOrEvaluator</span><span class="p">,</span>
    <span class="nx">an</span><span class="o">:</span> <span class="nx">createAndEvaluator</span><span class="p">,</span>
    <span class="nx">eq</span><span class="o">:</span> <span class="nx">createEqEvaluator</span><span class="p">,</span>
    <span class="nx">ma</span><span class="o">:</span> <span class="nx">createMatchEvaluator</span><span class="p">,</span>
    <span class="nx">nq</span><span class="o">:</span> <span class="nx">createNeqEvaluator</span><span class="p">,</span>
    <span class="nx">gt</span><span class="o">:</span> <span class="nx">createGtEvaluator</span><span class="p">,</span>
    <span class="nx">lt</span><span class="o">:</span> <span class="nx">createLtEvaluator</span><span class="p">,</span>
    <span class="nx">ge</span><span class="o">:</span> <span class="nx">createGteEvaluator</span><span class="p">,</span>
    <span class="nx">le</span><span class="o">:</span> <span class="nx">createLteEvaluator</span><span class="p">,</span>
    <span class="nx">ad</span><span class="o">:</span> <span class="nx">createAddEvaluator</span><span class="p">,</span>
    <span class="nx">su</span><span class="o">:</span> <span class="nx">createSubEvaluator</span><span class="p">,</span>
    <span class="nx">mu</span><span class="o">:</span> <span class="nx">createMulEvaluator</span><span class="p">,</span>
    <span class="nx">di</span><span class="o">:</span> <span class="nx">createDivEvaluator</span><span class="p">,</span>
    <span class="nx">mo</span><span class="o">:</span> <span class="nx">createModEvaluator</span><span class="p">,</span>
    <span class="nx">fm</span><span class="o">:</span> <span class="nx">createFormatEvaluator</span><span class="p">,</span>
    <span class="nx">no</span><span class="o">:</span> <span class="nx">createNotEvaluator</span><span class="p">,</span>
    <span class="nx">ne</span><span class="o">:</span> <span class="nx">createNegEvaluator</span><span class="p">,</span>
    <span class="nx">mb</span><span class="o">:</span> <span class="nx">createMemberEvaluator</span><span class="p">,</span>
    <span class="nx">ar</span><span class="o">:</span> <span class="nx">createArrayEvaluator</span><span class="p">,</span>
    <span class="nx">dc</span><span class="o">:</span> <span class="nx">createDictionaryEvaluator</span><span class="p">,</span>
    <span class="nx">id</span><span class="o">:</span> <span class="nx">createIdEvaluator</span><span class="p">,</span>
    <span class="nx">se</span><span class="o">:</span> <span class="nx">createSelfEvaluator</span>
  <span class="p">});</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>literals are stored in the <code>l</code> property of parseOutput, while the parse
tree is stored in the <code>n</code> property.  Since a parsed Interpol module
is simply a set of statements, we can create a statementsEvaluator and
call it a day.</p></div></div><div class="code"><div class="wrapper">  <span class="kd">var</span> <span class="nx">lits</span> <span class="o">=</span> <span class="nx">parseOutput</span><span class="p">.</span><span class="nx">l</span>
    <span class="p">,</span> <span class="nx">runtimeOptions</span> <span class="o">=</span> <span class="nx">mixin</span><span class="p">({},</span> <span class="nx">globalOptions</span><span class="p">,</span> <span class="nx">localOptions</span><span class="p">)</span>
    <span class="p">,</span> <span class="nx">cacheModules</span> <span class="o">=</span> <span class="nx">runtimeOptions</span><span class="p">.</span><span class="nx">cache</span>
    <span class="p">,</span> <span class="nx">resolvers</span> <span class="o">=</span> <span class="nx">runtimeOptions</span><span class="p">.</span><span class="nx">resolvers</span> <span class="o">||</span> <span class="nx">globalResolvers</span>
    <span class="p">,</span> <span class="nx">evaluator</span> <span class="o">=</span> <span class="nx">wrapLiteral</span><span class="p">(</span><span class="nx">createStatementsEvaluator</span><span class="p">(</span><span class="nx">parseOutput</span><span class="p">.</span><span class="nx">n</span><span class="p">))</span>
    <span class="p">,</span> <span class="nx">exportedContext</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

  <span class="nx">runtimeTemplate</span><span class="p">.</span><span class="nx">configure</span> <span class="o">=</span> <span class="nx">configureTemplate</span><span class="p">;</span>
  <span class="nx">runtimeTemplate</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">templateExports</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">freezeObject</span><span class="p">(</span><span class="nx">runtimeTemplate</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>The result of a runtime processing is this closure.  <code>obj</code> is the
Object to be used as a working context, while <code>localOptions</code> are
options to be applied to a particular rendering.  If no <code>errorCallback</code>
is provided, calls to this function may throw errors.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>obj must be an Object.</strong><br/>(the context Object to be rendered)</p></li>
<li><p><strong>localOptions is optional and must be an Object.</strong><br/>(Object for configuring the current render)</p>

<ul><li><p><strong>localOptions.writer is optional and must be a Writer.</strong><br/>(an alternative Writer to use)</p></li>
<li><p><strong>localOptions.errorCallback is optional and must be a Function.</strong><br/>(a callback for errors)</p></li></ul></li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">runtimeTemplate</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">localOptions</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">mixin</span><span class="p">(</span><span class="nx">extendContext</span><span class="p">(</span><span class="nx">globalContext</span><span class="p">),</span> <span class="nx">obj</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">processingOptions</span> <span class="o">=</span> <span class="nx">mixin</span><span class="p">({},</span> <span class="nx">globalOptions</span><span class="p">,</span> <span class="nx">localOptions</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If no Writer is provided, create a throw-away Array Writer</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">writer</span> <span class="o">=</span> <span class="nx">processingOptions</span><span class="p">.</span><span class="nx">writer</span> <span class="o">||</span> <span class="nx">createArrayWriter</span><span class="p">();</span>

    <span class="k">try</span> <span class="p">{</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">startRender</span><span class="p">();</span>
      <span class="nx">evaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">writer</span><span class="p">.</span><span class="nx">endRender</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span> <span class="nx">err</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">processingOptions</span><span class="p">.</span><span class="nx">errorCallback</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">processingOptions</span><span class="p">.</span><span class="nx">errorCallback</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Re-raise if no callback</p></div></div><div class="code"><div class="wrapper">      <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Returns a preconfigured version of the runtime template with a
default obj and options.  Convenient if you're doing DOM writing
or need to repeatedly call the template with the same Object.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>defaultObj must be an Object.</strong><br/>(default context Object to use)</p></li>
<li><p><strong>defaultOptions must be an Object.</strong><br/>(default Options to provide)</p></li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">configureTemplate</span><span class="p">(</span><span class="nx">defaultObj</span><span class="p">,</span> <span class="nx">defaultOptions</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">configure</span><span class="p">(</span><span class="nx">runtimeTemplate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returns the symbols (partials and assignments) that the runtime
template will product against an empty <code>{}</code> context Object.  This is
the method by which Interpol imports work.  Partials produced with
this method still have access to the global context.</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">templateExports</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nx">exportedContext</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">exportedContext</span><span class="p">;</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>__intExports</code> is an indicator to evaluators that we're processing
exports and so they can be a bit lax about reporting errors or
resolving imports</p></div></div><div class="code"><div class="wrapper">    <span class="nx">exportedContext</span> <span class="o">=</span> <span class="nx">extendContext</span><span class="p">(</span><span class="nx">globalContext</span><span class="p">);</span>
    <span class="nx">exportedContext</span><span class="p">.</span><span class="nx">__intExports</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="nx">evaluator</span><span class="p">(</span><span class="nx">exportedContext</span><span class="p">,</span> <span class="nx">NullWriter</span><span class="p">);</span>
    <span class="k">delete</span> <span class="nx">exportedContext</span><span class="p">.</span><span class="nx">__intExports</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">exportedContext</span><span class="p">;</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="evaluator-generation-utilities">Evaluator Generation Utilities</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">wrapLiteral</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if value is already a Function, we don't have to wrap it</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">wrapper</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">wrapper</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given an array of nodes, create evaluators for each element</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">wrapArrayEvaluators</span><span class="p">(</span><span class="nx">arrayNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">arrayNodes</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[];</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">arrayNodes</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">wrapLiteral</span><span class="p">(</span><span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">arrayNodes</span><span class="p">[</span><span class="nx">i</span><span class="p">]));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given an array of literal ids, expand them to real values</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">expandLiterals</span><span class="p">(</span><span class="nx">literalArray</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">literalArray</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[];</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">literalArray</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">lits</span><span class="p">[</span><span class="nx">literalArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>wrap evaluators for processing HTML attributes, including the attribute
names, since they can also be represented by expressions</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">wrapAttributeEvaluators</span><span class="p">(</span><span class="nx">keyValueNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">keyValueNodes</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[];</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">keyValueNodes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">keyValueNode</span> <span class="o">=</span> <span class="nx">keyValueNodes</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">keyValueNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                  <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">keyValueNode</span><span class="p">[</span><span class="mi">1</span><span class="p">])];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>wrap evaluators for local variable assignments, name is always a literal</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">wrapAssignmentEvaluators</span><span class="p">(</span><span class="nx">assignNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">assignNodes</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[];</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">assignNodes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">assignNode</span> <span class="o">=</span> <span class="nx">assignNodes</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">lits</span><span class="p">[</span><span class="nx">assignNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                  <span class="nx">wrapLiteral</span><span class="p">(</span><span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">assignNode</span><span class="p">[</span><span class="mi">1</span><span class="p">]))];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>The busiest function in the runtime process.  createEvaluator
resolves the evaluator generation function to use by taking the
first element of the node array.  It then passes the rest of the
node's elements as arguments to that generation function.</p>

<p>Parameters:</p>

<ul>
<li><strong>node can be an Array or a Number.</strong><br/>(Either an Array or a Literal Id)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="nx">node</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">node</span> <span class="o">===</span> <span class="kc">null</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">lits</span><span class="p">[</span><span class="nx">node</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">nodeType</span> <span class="o">=</span> <span class="nx">lits</span><span class="p">[</span><span class="nx">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
      <span class="p">,</span> <span class="nx">createFunction</span> <span class="o">=</span> <span class="nx">Evaluators</span><span class="p">[</span><span class="nx">nodeType</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">createFunction</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Invalid Node in Parse Tree: &quot;</span> <span class="o">+</span> <span class="nx">nodeType</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">createFunction</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">createStatementsEvaluator</span><span class="p">(</span><span class="nx">statementNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nx">statementNodes</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">statementNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">statements</span> <span class="o">=</span> <span class="nx">wrapArrayEvaluators</span><span class="p">(</span><span class="nx">statementNodes</span><span class="p">).</span><span class="nx">reverse</span><span class="p">()</span>
      <span class="p">,</span> <span class="nx">slen</span> <span class="o">=</span> <span class="nx">statements</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">statementsEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">statementsEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">slen</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">statements</span><span class="p">[</span><span class="nx">i</span><span class="p">](</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Depending on the value types for <code>left</code> and <code>right</code>, will return an
index into an Array for choosing the best code-path to take in
evaluating an operator.  0=both are literals, 1=left is a function,
2=right is a function, 3=both are functions.</p>

<p>Parameters:</p>

<ul>
<li><p><strong>left can be a Function or a Mixed.</strong><br/>(the left operand)</p></li>
<li><p><strong>right can be a Function or a Mixed.</strong><br/>(the right operand)</p></li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">l</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">left</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span>
      <span class="p">,</span> <span class="nx">r</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">right</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">l</span> <span class="o">|</span> <span class="nx">r</span><span class="p">;</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="evaluator-generation">Evaluator Generation</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an evaluator to deal with 'from' and 'import' statements</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createImportEvaluator</span><span class="p">(</span><span class="nx">fromNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">importList</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="p">,</span> <span class="nx">ilen</span> <span class="o">=</span> <span class="nx">fromNodes</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="p">,</span> <span class="nx">evaluator</span> <span class="o">=</span> <span class="nx">cacheModules</span> <span class="o">?</span> <span class="nx">cacheableEvaluator</span> <span class="o">:</span> <span class="nx">dynamicEvaluator</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">ilen</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">fromNode</span> <span class="o">=</span> <span class="nx">fromNodes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="p">,</span> <span class="nx">moduleName</span> <span class="o">=</span> <span class="nx">lits</span><span class="p">[</span><span class="nx">fromNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="p">,</span> <span class="nx">aliases</span> <span class="o">=</span> <span class="nx">fromNode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">,</span> <span class="nx">moduleAlias</span> <span class="o">=</span> <span class="kc">null</span>
        <span class="p">,</span> <span class="nx">toResolve</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">aliases</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">toResolve</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">aliases</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">importInfo</span> <span class="o">=</span> <span class="nx">aliases</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
            <span class="p">,</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">lits</span><span class="p">[</span><span class="nx">importInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="p">,</span> <span class="nx">alias</span> <span class="o">=</span> <span class="nx">importInfo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">lits</span><span class="p">[</span><span class="nx">importInfo</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">:</span> <span class="nx">name</span><span class="p">;</span>
          <span class="nx">toResolve</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">alias</span><span class="p">,</span> <span class="nx">name</span><span class="p">]);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">aliases</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">moduleAlias</span> <span class="o">=</span> <span class="nx">lits</span><span class="p">[</span><span class="nx">aliases</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="nx">moduleAlias</span> <span class="o">=</span> <span class="nx">moduleName</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">).</span><span class="nx">pop</span><span class="p">();</span>
      <span class="p">}</span>

      <span class="nx">importList</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">moduleName</span><span class="p">,</span> <span class="nx">moduleAlias</span><span class="p">,</span> <span class="nx">toResolve</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">importEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">importEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>have to call it like this because we can't override importEvaluator
after it has been returned to a parent evaluator</p></div></div><div class="code"><div class="wrapper">      <span class="nx">evaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if moduleCaching is on, we use the cachable form of the evaluator</p></div></div><div class="code"><div class="wrapper">    <span class="kd">function</span> <span class="nx">cacheableEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">__intExports</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">dynamicEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="nx">dynamicEvaluator</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="nx">evaluator</span> <span class="o">=</span> <span class="nx">createStaticMixin</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
      <span class="nx">evaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if moduleCaching is off, we resolve the exports every time</p></div></div><div class="code"><div class="wrapper">    <span class="kd">function</span> <span class="nx">dynamicEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">ilen</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">importItem</span> <span class="o">=</span> <span class="nx">importList</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
          <span class="p">,</span> <span class="nx">moduleName</span> <span class="o">=</span> <span class="nx">importItem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="p">,</span> <span class="nx">moduleAlias</span> <span class="o">=</span> <span class="nx">importItem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
          <span class="p">,</span> <span class="nx">toResolve</span> <span class="o">=</span> <span class="nx">importItem</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

        <span class="kd">var</span> <span class="nx">moduleExports</span> <span class="o">=</span> <span class="nx">resolveExports</span><span class="p">(</span><span class="nx">moduleName</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span> <span class="nx">toResolve</span> <span class="p">)</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">toResolve</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">aliasMap</span> <span class="o">=</span> <span class="nx">toResolve</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
            <span class="nx">ctx</span><span class="p">[</span><span class="nx">aliasMap</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">moduleExports</span><span class="p">[</span><span class="nx">aliasMap</span><span class="p">[</span><span class="mi">1</span><span class="p">]];</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
          <span class="nx">ctx</span><span class="p">[</span><span class="nx">moduleAlias</span><span class="p">]</span> <span class="o">=</span> <span class="nx">moduleExports</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>where exports are actually resolved. raiseError will be false
if we're in the process of evaluating a template for the purpose
of yielding its exports</p></div></div><div class="code"><div class="wrapper">    <span class="kd">function</span> <span class="nx">resolveExports</span><span class="p">(</span><span class="nx">moduleName</span><span class="p">,</span> <span class="nx">raiseError</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">module</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">resolvers</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">module</span> <span class="o">=</span> <span class="nx">resolvers</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">resolveExports</span><span class="p">(</span><span class="nx">moduleName</span><span class="p">,</span> <span class="nx">runtimeOptions</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nx">module</span> <span class="p">)</span> <span class="p">{</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">module</span> <span class="o">&amp;&amp;</span> <span class="nx">raiseError</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Module &#39;&quot;</span> <span class="o">+</span> <span class="nx">moduleName</span> <span class="o">+</span><span class="s2">&quot;&#39; not resolved&quot;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">module</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">isInterpolPartial</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">typeof</span> <span class="nx">func</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">func</span><span class="p">.</span><span class="nx">__intFunction</span> <span class="o">===</span> <span class="s1">&#39;part&#39;</span><span class="p">;</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an evaluator to represent a partial and its associated closure</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createPartialEvaluator</span><span class="p">(</span><span class="nx">nameLiteral</span><span class="p">,</span> <span class="nx">paramDefs</span><span class="p">,</span>
                                  <span class="nx">statementNodes</span><span class="p">,</span> <span class="nx">guardNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">lits</span><span class="p">[</span><span class="nx">nameLiteral</span><span class="p">]</span>
      <span class="p">,</span> <span class="nx">params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">null</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">expandLiterals</span><span class="p">(</span><span class="nx">paramDefs</span><span class="p">))</span>
      <span class="p">,</span> <span class="nx">plen</span> <span class="o">=</span> <span class="nx">params</span><span class="p">.</span><span class="nx">length</span>
      <span class="p">,</span> <span class="nx">statements</span> <span class="o">=</span> <span class="nx">createStatementsEvaluator</span><span class="p">(</span><span class="nx">statementNodes</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">guard</span> <span class="o">=</span> <span class="nx">guardNode</span> <span class="o">&amp;&amp;</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">guardNode</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">guard</span> <span class="o">?</span> <span class="nx">guardedClosureEvaluator</span> <span class="o">:</span> <span class="nx">unguardedClosureEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">unguardedClosureEvaluator</span><span class="p">(</span><span class="nx">ctx</span> <span class="cm">/*, writer */</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">ctx</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">callEvaluator</span><span class="p">;</span>
      <span class="nx">callEvaluator</span><span class="p">.</span><span class="nx">__intFunction</span> <span class="o">=</span> <span class="s1">&#39;part&#39;</span><span class="p">;</span>
      <span class="nx">callEvaluator</span><span class="p">.</span><span class="nx">__intEvaluator</span> <span class="o">=</span> <span class="nx">bodyEvaluator</span><span class="p">;</span>

      <span class="kd">function</span> <span class="nx">callEvaluator</span><span class="p">(</span><span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">statements</span><span class="p">(</span><span class="nx">createCallContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">callEvaluator</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">),</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kd">function</span> <span class="nx">bodyEvaluator</span><span class="p">(</span><span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">statements</span><span class="p">(</span><span class="nx">createCallContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">callEvaluator</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">),</span> <span class="nx">writer</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">guardedClosureEvaluator</span><span class="p">(</span><span class="nx">ctx</span> <span class="cm">/*, writer */</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">bodyEvaluator</span><span class="p">,</span> <span class="nx">oldEvaluator</span><span class="p">,</span> <span class="nx">newEvaluator</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="nx">isInterpolPartial</span><span class="p">(</span><span class="nx">ctx</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">bodyEvaluator</span> <span class="o">=</span> <span class="nx">guardedBodyEvaluator</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="nx">oldEvaluator</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">[</span><span class="nx">name</span><span class="p">].</span><span class="nx">__intEvaluator</span><span class="p">;</span>
        <span class="nx">bodyEvaluator</span> <span class="o">=</span> <span class="nx">branchedBodyEvaluator</span><span class="p">;</span>
        <span class="nx">newEvaluator</span> <span class="o">=</span> <span class="nx">guardedBodyEvaluator</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">ctx</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">callEvaluator</span><span class="p">;</span>
      <span class="nx">callEvaluator</span><span class="p">.</span><span class="nx">__intFunction</span> <span class="o">=</span> <span class="s1">&#39;part&#39;</span><span class="p">;</span>
      <span class="nx">callEvaluator</span><span class="p">.</span><span class="nx">__intEvaluator</span> <span class="o">=</span> <span class="nx">bodyEvaluator</span><span class="p">;</span>

      <span class="kd">function</span> <span class="nx">callEvaluator</span><span class="p">()</span> <span class="p">{</span>
        <span class="cm">/* jshint validthis:true */</span>
        <span class="nx">bodyEvaluator</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kd">function</span> <span class="nx">guardedBodyEvaluator</span><span class="p">(</span><span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">newCtx</span> <span class="o">=</span> <span class="nx">createCallContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">callEvaluator</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nx">guard</span><span class="p">(</span><span class="nx">newCtx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
          <span class="nx">statements</span><span class="p">(</span><span class="nx">newCtx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="kd">function</span> <span class="nx">branchedBodyEvaluator</span><span class="p">()</span> <span class="p">{</span>
        <span class="cm">/* jshint validthis:true */</span>
        <span class="k">return</span> <span class="nx">newEvaluator</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">)</span> <span class="o">||</span>
               <span class="nx">oldEvaluator</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Creates a new calling context and stores its locals from arguments</p></div></div><div class="code"><div class="wrapper">    <span class="kd">function</span> <span class="nx">createCallContext</span><span class="p">(</span><span class="nx">parentCtx</span><span class="p">,</span> <span class="nx">callEvaluator</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">newCtx</span> <span class="o">=</span> <span class="nx">extendContext</span><span class="p">(</span><span class="nx">parentCtx</span><span class="p">);</span>
      <span class="nx">newCtx</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">callEvaluator</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">plen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">newCtx</span><span class="p">[</span><span class="nx">params</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">newCtx</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a bound call evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createBindEvaluator</span><span class="p">(</span><span class="nx">memberNode</span><span class="p">,</span> <span class="nx">argNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">member</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">memberNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">wrapArrayEvaluators</span><span class="p">(</span><span class="nx">argNodes</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">alen</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">bindEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">bindEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">func</span> <span class="o">=</span> <span class="nx">member</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">isInterpolFunction</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">__intExports</span> <span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Attempting to bind an unblessed function&quot;</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kd">var</span> <span class="nx">callArgs</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">alen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">callArgs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">](</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kd">var</span> <span class="nx">bound</span> <span class="o">=</span> <span class="nx">configure</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">callArgs</span><span class="p">);</span>
      <span class="nx">bound</span><span class="p">.</span><span class="nx">__intFunction</span> <span class="o">=</span> <span class="nx">func</span><span class="p">.</span><span class="nx">__intFunction</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">bound</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an evaluator to perform a function or partial call</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createCallEvaluator</span><span class="p">(</span><span class="nx">memberNode</span><span class="p">,</span> <span class="nx">argNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">member</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">memberNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[</span><span class="kc">null</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">wrapArrayEvaluators</span><span class="p">(</span><span class="nx">argNodes</span><span class="p">))</span>
      <span class="p">,</span> <span class="nx">alen</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">callEvaluator</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we're in the process of gathering module exports, and the called
function can't be resolved, then just exit without exploding.
What happens inside of a function probably shouldn't influence the
top-level export context anyway</p></div></div><div class="code"><div class="wrapper">    <span class="kd">function</span> <span class="nx">callEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">func</span> <span class="o">=</span> <span class="nx">member</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">isInterpolFunction</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">__intExports</span> <span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Attempting to call an unblessed function&quot;</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kd">var</span> <span class="nx">callArgs</span> <span class="o">=</span> <span class="p">[</span><span class="nx">writer</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">alen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">callArgs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">](</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="k">return</span> <span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">callArgs</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an evaluator to perform local variable assignment</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createAssignEvaluator</span><span class="p">(</span><span class="nx">assignmentDefs</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">assigns</span> <span class="o">=</span> <span class="nx">wrapAssignmentEvaluators</span><span class="p">(</span><span class="nx">assignmentDefs</span><span class="p">).</span><span class="nx">reverse</span><span class="p">()</span>
      <span class="p">,</span> <span class="nx">alen</span> <span class="o">=</span> <span class="nx">assigns</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">assignEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">assignEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">alen</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">assign</span> <span class="o">=</span> <span class="nx">assigns</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="nx">ctx</span><span class="p">[</span><span class="nx">assign</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">assign</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an evaluator to write an html opening tag</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createOpenTagEvaluator</span><span class="p">(</span><span class="nx">nameNode</span><span class="p">,</span> <span class="nx">attributeDefs</span><span class="p">,</span> <span class="nx">selfClose</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">nameNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">attributes</span> <span class="o">=</span> <span class="nx">wrapAttributeEvaluators</span><span class="p">(</span><span class="nx">attributeDefs</span><span class="p">).</span><span class="nx">reverse</span><span class="p">()</span>
      <span class="p">,</span> <span class="nx">alen</span> <span class="o">=</span> <span class="nx">attributes</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">name</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">selfClose</span> <span class="o">?</span> <span class="nx">selfCloseFuncEvaluator</span> <span class="o">:</span> <span class="nx">openTagFuncEvaluator</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">selfClose</span> <span class="o">?</span> <span class="nx">selfCloseLiteralEvaluator</span> <span class="o">:</span> <span class="nx">openTagLiteralEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">selfCloseFuncEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">tagName</span> <span class="o">=</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">name</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">));</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">selfCloseElement</span><span class="p">(</span><span class="nx">tagName</span><span class="p">,</span> <span class="nx">getAttributes</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">openTagFuncEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">tagName</span> <span class="o">=</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">name</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">));</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">startElement</span><span class="p">(</span><span class="nx">tagName</span><span class="p">,</span> <span class="nx">getAttributes</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">selfCloseLiteralEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">selfCloseElement</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">getAttributes</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">openTagLiteralEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">startElement</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">getAttributes</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">getAttributes</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">alen</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">attribute</span> <span class="o">=</span> <span class="nx">attributes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
          <span class="p">,</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">key</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="p">)</span> <span class="p">{</span>
          <span class="nx">key</span> <span class="o">=</span> <span class="nx">key</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span> <span class="nx">key</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">key</span> <span class="o">===</span> <span class="kc">null</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">key</span> <span class="o">=</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">attribute</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">val</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="p">)</span> <span class="p">{</span>
          <span class="nx">val</span> <span class="o">=</span> <span class="nx">val</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nx">result</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">freezeObject</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an evaluator to write an html closing tag</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createCloseTagEvaluator</span><span class="p">(</span><span class="nx">nameNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">nameNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">name_func</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">name</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">name_func</span> <span class="o">?</span> <span class="nx">closeFuncEvaluator</span> <span class="o">:</span> <span class="nx">closeLiteralEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">closeFuncEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">endElement</span><span class="p">(</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">name</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">closeLiteralEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">endElement</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an evaluator to write an html comment</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createCommentTagEvaluator</span><span class="p">(</span><span class="nx">contentLiteral</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">content</span> <span class="o">=</span> <span class="nx">lits</span><span class="p">[</span><span class="nx">contentLiteral</span><span class="p">];</span>

    <span class="k">return</span> <span class="nx">commentTagEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">commentTagEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">comment</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an evaluator to write an html5 doctype</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createDocTypeEvaluator</span><span class="p">(</span><span class="nx">rootElemLiteral</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">rootElem</span> <span class="o">=</span> <span class="nx">lits</span><span class="p">[</span><span class="nx">rootElemLiteral</span><span class="p">];</span>

    <span class="k">return</span> <span class="nx">docTypeEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">docTypeEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">docType</span><span class="p">(</span><span class="nx">rootElem</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an evaluator that writes the result of an expression</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createOutputEvaluator</span><span class="p">(</span><span class="nx">exprNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">exprNode</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">$1</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nx">$1</span> <span class="o">=</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">$1</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">outputLiteral</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">outputEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">outputEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">content</span><span class="p">(</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">$1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">outputLiteral</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">content</span><span class="p">(</span><span class="nx">$1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an evaluator that writes the result of an
expression without escaping</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createRawOutputEvaluator</span><span class="p">(</span><span class="nx">exprNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">exprNode</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">typeof</span> <span class="nx">$1</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span> <span class="o">?</span> <span class="nx">outputLiteral</span> <span class="o">:</span> <span class="nx">outputEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">outputEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">rawContent</span><span class="p">(</span><span class="nx">$1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">outputLiteral</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">writer</span><span class="p">.</span><span class="nx">rawContent</span><span class="p">(</span><span class="nx">$1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an evaluator that performs for looping over ranges</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createForEvaluator</span><span class="p">(</span><span class="nx">rangeNodes</span><span class="p">,</span> <span class="nx">statementNodes</span><span class="p">,</span> <span class="nx">elseNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ranges</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="p">,</span> <span class="nx">rlen</span> <span class="o">=</span> <span class="nx">rangeNodes</span><span class="p">.</span><span class="nx">length</span>
      <span class="p">,</span> <span class="nx">statements</span> <span class="o">=</span> <span class="nx">createStatementsEvaluator</span><span class="p">(</span><span class="nx">statementNodes</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">elseStatements</span> <span class="o">=</span> <span class="nx">elseNodes</span> <span class="o">&amp;&amp;</span> <span class="nx">createStatementsEvaluator</span><span class="p">(</span><span class="nx">elseNodes</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">rangeNodes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">rangeNode</span> <span class="o">=</span> <span class="nx">rangeNodes</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="nx">ranges</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nx">lits</span><span class="p">[</span><span class="nx">rangeNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
        <span class="nx">wrapLiteral</span><span class="p">(</span><span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rangeNode</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
        <span class="nx">rangeNode</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">wrapLiteral</span><span class="p">(</span><span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rangeNode</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
      <span class="p">];</span>
    <span class="p">}</span>
    <span class="nx">ranges</span><span class="p">.</span><span class="nx">reverse</span><span class="p">();</span>

    <span class="k">return</span> <span class="nx">forEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">forEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The entire for loop is only a single nested context</p></div></div><div class="code"><div class="wrapper">      <span class="kd">var</span> <span class="nx">newCtx</span> <span class="o">=</span> <span class="nx">extendContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
        <span class="p">,</span> <span class="nx">statementsEvaluated</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

      <span class="nx">processRange</span><span class="p">(</span><span class="nx">rlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">statementsEvaluated</span> <span class="o">&amp;&amp;</span> <span class="nx">elseStatements</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">elseStatements</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kd">function</span> <span class="nx">processRange</span><span class="p">(</span><span class="nx">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">range</span> <span class="o">=</span> <span class="nx">ranges</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span>
          <span class="p">,</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="p">,</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">range</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="nx">newCtx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span>
          <span class="p">,</span> <span class="nx">guard</span> <span class="o">=</span> <span class="nx">range</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
          <span class="p">,</span> <span class="nx">items</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">data</span> <span class="o">!==</span> <span class="s1">&#39;object&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">var</span> <span class="nx">createItem</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
          <span class="nx">createItem</span> <span class="o">=</span> <span class="nx">createArrayItem</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
          <span class="nx">items</span> <span class="o">=</span> <span class="nx">objectKeys</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
          <span class="nx">createItem</span> <span class="o">=</span> <span class="nx">createObjectItem</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
          <span class="nx">newCtx</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">createItem</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span> <span class="nx">guard</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">guard</span><span class="p">(</span><span class="nx">newCtx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span> <span class="nx">idx</span> <span class="p">)</span> <span class="p">{</span>
            <span class="nx">processRange</span><span class="p">(</span><span class="nx">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
            <span class="nx">statements</span><span class="p">(</span><span class="nx">newCtx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
            <span class="nx">statementsEvaluated</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>

        <span class="kd">function</span> <span class="nx">createArrayItem</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="kd">function</span> <span class="nx">createObjectItem</span><span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">data</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">};</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an evaluator that borrows the specified expression
as the block's new context for locals (remaining immutable)</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createUsingEvaluator</span><span class="p">(</span><span class="nx">exprNode</span><span class="p">,</span> <span class="nx">statementNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">exprNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createStatementsEvaluator</span><span class="p">(</span><span class="nx">statementNodes</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">usingEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">usingEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">newCtx</span> <span class="o">=</span> <span class="nx">mixin</span><span class="p">(</span><span class="nx">extendContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">),</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">));</span>
      <span class="nx">$2</span><span class="p">(</span><span class="nx">newCtx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a conditional evaluator (if/else or ternary)</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createConditionalEvaluator</span><span class="p">(</span><span class="nx">conditionNode</span><span class="p">,</span> <span class="nx">trueNodes</span><span class="p">,</span> <span class="nx">falseNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">conditionNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createStatementsEvaluator</span><span class="p">(</span><span class="nx">trueNodes</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$3</span> <span class="o">=</span> <span class="nx">createStatementsEvaluator</span><span class="p">(</span><span class="nx">falseNodes</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">$1</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">$1</span> <span class="o">?</span> <span class="nx">$2</span> <span class="o">:</span> <span class="nx">$3</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$2</span><span class="p">,</span> <span class="nx">$3</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">condLiteral</span><span class="p">,</span> <span class="nx">condTrue</span><span class="p">,</span> <span class="nx">condFalse</span><span class="p">,</span> <span class="nx">condBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">];</span>

    <span class="kd">function</span> <span class="nx">condLiteral</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">?</span> <span class="nx">$2</span> <span class="o">:</span> <span class="nx">$3</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">condTrue</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">?</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">:</span> <span class="nx">$3</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">condFalse</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">?</span> <span class="nx">$2</span> <span class="o">:</span> <span class="nx">$3</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">condBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">?</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">:</span> <span class="nx">$3</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an 'or' evaluator, including short circuiting</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createOrEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">$1</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">$1</span> <span class="o">||</span> <span class="nx">$2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">typeof</span> <span class="nx">$2</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">?</span> <span class="nx">orFuncEvaluator</span> <span class="o">:</span> <span class="nx">orLiteralEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">orFuncEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">lval</span> <span class="o">=</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">lval</span> <span class="o">?</span> <span class="nx">lval</span> <span class="o">:</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">orLiteralEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">lval</span> <span class="o">=</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">lval</span> <span class="o">?</span> <span class="nx">lval</span> <span class="o">:</span> <span class="nx">$2</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an 'and' evaluator, including short circuiting</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createAndEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">$1</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">$1</span> <span class="o">&amp;&amp;</span> <span class="nx">$2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">typeof</span> <span class="nx">$2</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">?</span> <span class="nx">andFuncEvaluator</span> <span class="o">:</span> <span class="nx">andLiteralEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">andFuncEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">lval</span> <span class="o">=</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">lval</span> <span class="o">?</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="o">:</span> <span class="nx">lval</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">andLiteralEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">lval</span> <span class="o">=</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">lval</span> <span class="o">?</span> <span class="nx">$2</span> <span class="o">:</span> <span class="nx">lval</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a match evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createMatchEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">);</span>

    <span class="k">switch</span> <span class="p">(</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">return</span> <span class="nx">isMatchingObject</span><span class="p">(</span><span class="nx">$2</span><span class="p">,</span> <span class="nx">$1</span><span class="p">);</span>
      <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">buildMatcher</span><span class="p">(</span><span class="nx">$2</span><span class="p">);</span> <span class="k">return</span> <span class="nx">maLeft</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="k">return</span> <span class="nx">maRight</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">3</span><span class="o">:</span> <span class="k">return</span> <span class="nx">maBoth</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">maLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">));</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">maRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">isMatchingObject</span><span class="p">(</span><span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">),</span> <span class="nx">$1</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">maBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">isMatchingObject</span><span class="p">(</span><span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">),</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">));</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an equality evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createEqEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">);</span>

     <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="nx">eqLeft</span><span class="p">,</span> <span class="nx">eqRight</span><span class="p">,</span> <span class="nx">eqBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">$1</span> <span class="o">==</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">eqLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">==</span> <span class="nx">$2</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">eqRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span> <span class="o">==</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">eqBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">==</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an inequality evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createNeqEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="nx">neqLeft</span><span class="p">,</span> <span class="nx">neqRight</span><span class="p">,</span> <span class="nx">neqBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">$1</span> <span class="o">!=</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">neqLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">$2</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">neqRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span> <span class="o">!=</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">neqBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a greater-than evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createGtEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="nx">gtLeft</span><span class="p">,</span> <span class="nx">gtRight</span><span class="p">,</span> <span class="nx">gtBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">$1</span> <span class="o">&gt;</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">gtLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nx">$2</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">gtRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span> <span class="o">&gt;</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">gtBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a greater-than or equal to evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createGteEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="nx">gteLeft</span><span class="p">,</span> <span class="nx">gteRight</span><span class="p">,</span> <span class="nx">gteBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">$1</span> <span class="o">&gt;=</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">gteLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">$2</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">gteRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span> <span class="o">&gt;=</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">gteBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a less-than evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createLtEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="nx">ltLeft</span><span class="p">,</span> <span class="nx">ltRight</span><span class="p">,</span> <span class="nx">ltBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">$1</span> <span class="o">&lt;</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">ltLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nx">$2</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">ltRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span> <span class="o">&lt;</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">ltBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a less-than or equal to evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createLteEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="nx">lteLeft</span><span class="p">,</span> <span class="nx">lteRight</span><span class="p">,</span> <span class="nx">lteBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">$1</span> <span class="o">&lt;=</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">lteLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nx">$2</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">lteRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span> <span class="o">&lt;=</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">lteBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an addition evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createAddEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="nx">addLeft</span><span class="p">,</span> <span class="nx">addRight</span><span class="p">,</span> <span class="nx">addBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">$1</span> <span class="o">+</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">addLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">+</span> <span class="nx">$2</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">addRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span> <span class="o">+</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">addBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">+</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a subtraction evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createSubEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="nx">subLeft</span><span class="p">,</span> <span class="nx">subRight</span><span class="p">,</span> <span class="nx">subBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">$1</span> <span class="o">-</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">subLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">-</span> <span class="nx">$2</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">subRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span> <span class="o">-</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">subBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">-</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a multiplication evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createMulEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="nx">mulLeft</span><span class="p">,</span> <span class="nx">mulRight</span><span class="p">,</span> <span class="nx">mulBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">$1</span> <span class="o">*</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">mulLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">*</span> <span class="nx">$2</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">mulRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span> <span class="o">*</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">mulBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">*</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a division evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createDivEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="nx">divLeft</span><span class="p">,</span> <span class="nx">divRight</span><span class="p">,</span> <span class="nx">divBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">$1</span> <span class="o">/</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">divLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">/</span> <span class="nx">$2</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">divRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span> <span class="o">/</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">divBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">/</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a remainder evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createModEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">,</span> <span class="nx">rightNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">leftNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">rightNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="nx">modLeft</span><span class="p">,</span> <span class="nx">modRight</span><span class="p">,</span> <span class="nx">modBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">$1</span> <span class="o">%</span> <span class="nx">$2</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">modLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">%</span> <span class="nx">$2</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">modRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span> <span class="o">%</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">modBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="o">%</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an interpolation evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createFormatEvaluator</span><span class="p">(</span><span class="nx">formatNode</span><span class="p">,</span> <span class="nx">exprNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">formatNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$1_func</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">$1</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">exprNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2_func</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">$2</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">;</span>

    <span class="kd">var</span> <span class="nx">template</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">$1_func</span> <span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we can cache everything if the left operand is a literal</p></div></div><div class="code"><div class="wrapper">      <span class="nx">template</span> <span class="o">=</span> <span class="nx">buildTemplate</span><span class="p">(</span><span class="nx">$1</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="nx">$2_func</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">builtExpressionEvaluator</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span> <span class="nx">template</span><span class="p">.</span><span class="nx">__requiresContext</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">builtLiteralEvaluator</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">template</span><span class="p">(</span><span class="nx">$2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">cache</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="p">,</span> <span class="nx">cacheCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>otherwise, we have to evaluate the interpolation every time</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="nx">dynamicFormatEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">builtExpressionEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">template</span><span class="p">(</span><span class="nx">$2</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">),</span> <span class="nx">ctx</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">builtLiteralEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">template</span><span class="p">(</span><span class="nx">$2</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">);</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we exhaust TemplateCacheMax, then something is clearly wrong here
and we're not using the evaluator for localized strings.  If we keep
caching, we're going to start leaking memory.  So this evaluator will
blow away the cache and start over</p></div></div><div class="code"><div class="wrapper">    <span class="kd">function</span> <span class="nx">dynamicFormatEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">formatStr</span> <span class="o">=</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span>
        <span class="p">,</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">$2_func</span> <span class="o">?</span> <span class="nx">$2</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="o">:</span> <span class="nx">$2</span>
        <span class="p">,</span> <span class="nx">dynamicTemplate</span> <span class="o">=</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">formatStr</span><span class="p">];</span>

      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">dynamicTemplate</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nx">cacheCount</span> <span class="o">&gt;=</span> <span class="nx">TemplateCacheMax</span> <span class="p">)</span> <span class="p">{</span>
          <span class="nx">cache</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">cacheCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>build and cache the dynamic template</p></div></div><div class="code"><div class="wrapper">        <span class="nx">dynamicTemplate</span> <span class="o">=</span> <span class="nx">buildTemplate</span><span class="p">(</span><span class="nx">formatStr</span><span class="p">);</span>
        <span class="nx">cache</span><span class="p">[</span><span class="nx">formatStr</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dynamicTemplate</span><span class="p">;</span>
        <span class="nx">cacheCount</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">return</span> <span class="nx">dynamicTemplate</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a logical 'not' evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createNotEvaluator</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">typeof</span> <span class="nx">$1</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">?</span> <span class="nx">notEvaluator</span> <span class="o">:</span> <span class="o">!</span><span class="nx">$1</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">notEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!</span><span class="nx">$1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a mathematic negation evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createNegEvaluator</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">typeof</span> <span class="nx">$1</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">?</span> <span class="nx">negEvaluator</span> <span class="o">:</span> <span class="o">-</span><span class="nx">$1</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">negEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">-</span><span class="nx">$1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an array or object member access evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createMemberEvaluator</span><span class="p">(</span><span class="nx">parentNode</span><span class="p">,</span> <span class="nx">elemNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$1</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">parentNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">$2</span> <span class="o">=</span> <span class="nx">createEvaluator</span><span class="p">(</span><span class="nx">elemNode</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">getBinaryType</span><span class="p">(</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">$2</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>do this if the left operand is a literal, though it shouldn't be</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="nx">type</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">type</span> <span class="o">===</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="p">(</span> <span class="nx">$1</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">$1</span> <span class="o">===</span> <span class="kc">null</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">[</span><span class="kc">null</span><span class="p">,</span> <span class="nx">memLeft</span><span class="p">,</span> <span class="nx">memRight</span><span class="p">,</span> <span class="nx">memBoth</span><span class="p">][</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">$1</span><span class="p">[</span><span class="nx">$2</span><span class="p">]);</span>

    <span class="kd">function</span> <span class="nx">memLeft</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="nx">parent</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">parent</span> <span class="o">===</span> <span class="kc">null</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">parent</span><span class="p">[</span><span class="nx">$2</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">memRight</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">$1</span><span class="p">[</span><span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)];</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">memBoth</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nx">$1</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="nx">parent</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">parent</span> <span class="o">===</span> <span class="kc">null</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">parent</span><span class="p">[</span><span class="nx">$2</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">w</span><span class="p">)];</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate an array evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createArrayEvaluator</span><span class="p">(</span><span class="nx">elemNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">elems</span> <span class="o">=</span> <span class="nx">wrapArrayEvaluators</span><span class="p">(</span><span class="nx">elemNodes</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">elen</span> <span class="o">=</span> <span class="nx">elems</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">arrayEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">arrayEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">elen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">elems</span><span class="p">[</span><span class="nx">i</span><span class="p">](</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">freezeObject</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a dictionary evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createDictionaryEvaluator</span><span class="p">(</span><span class="nx">assignmentDefs</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">assigns</span> <span class="o">=</span> <span class="nx">wrapAssignmentEvaluators</span><span class="p">(</span><span class="nx">assignmentDefs</span><span class="p">).</span><span class="nx">reverse</span><span class="p">()</span>
      <span class="p">,</span> <span class="nx">alen</span> <span class="o">=</span> <span class="nx">assigns</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">dictionaryEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">dictionaryEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">dict</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">alen</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">assign</span> <span class="o">=</span> <span class="nx">assigns</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="nx">dict</span><span class="p">[</span><span class="nx">assign</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">assign</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">freezeObject</span><span class="p">(</span><span class="nx">dict</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a local variable retrieval evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createIdEvaluator</span><span class="p">(</span><span class="nx">nameLiteral</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">lits</span><span class="p">[</span><span class="nx">nameLiteral</span><span class="p">];</span>
    <span class="k">return</span> <span class="nx">idEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">idEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">ctx</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>generate a self-reference evaluator</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">createSelfEvaluator</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">selfEvaluator</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">selfEvaluator</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">writer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">ctx</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">options</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">globalOptions</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">globals</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">globalContext</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">resolvers</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">globalResolvers</span><span class="p">;</span>
<span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Exported Functions</p></div></div><div class="code"><div class="wrapper"><span class="nx">exports</span><span class="p">.</span><span class="nx">buildRuntime</span> <span class="o">=</span> <span class="nx">buildRuntime</span><span class="p">;</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="nx">options</span><span class="p">;</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">globals</span> <span class="o">=</span> <span class="nx">globals</span><span class="p">;</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">resolvers</span> <span class="o">=</span> <span class="nx">resolvers</span><span class="p">;</span></div></div></div></div></body></html>