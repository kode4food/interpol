<!DOCTYPE html><html lang="en"><head><title>compiler</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="compiler"><meta name="groc-project-path" content="lib/compiler.js"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path">lib/compiler.js</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="cm">/*</span>
<span class="cm"> * Interpol (Templates Sans Facial Hair)</span>
<span class="cm"> * Licensed under the MIT License</span>
<span class="cm"> * see doc/LICENSE.md</span>
<span class="cm"> *</span>
<span class="cm"> * @author Thomas S. Bradford (kode4food.it)</span>
<span class="cm"> */</span>

<span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">interpol</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./interpol&#39;</span><span class="p">)</span>
  <span class="p">,</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./util&#39;</span><span class="p">)</span>
  <span class="p">,</span> <span class="nx">parser</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./parser&#39;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">parseTemplate</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">parseTemplate</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">isArray</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">isArray</span>
  <span class="p">,</span> <span class="nx">freezeObject</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">freezeObject</span>
  <span class="p">,</span> <span class="nx">stringify</span> <span class="o">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">stringify</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">sym</span>
  <span class="p">,</span> <span class="nx">isSymbol</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">isSymbol</span>
  <span class="p">,</span> <span class="nx">isStatements</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">isStatements</span>
  <span class="p">,</span> <span class="nx">hasOperator</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">hasOperator</span>
  <span class="p">,</span> <span class="nx">isIdentifier</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">isIdentifier</span>
  <span class="p">,</span> <span class="nx">isLiteral</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">isLiteral</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">inverseOperators</span> <span class="o">=</span> <span class="nx">freezeObject</span><span class="p">({</span>
  <span class="s1">&#39;eq&#39;</span><span class="o">:</span> <span class="s1">&#39;nq&#39;</span><span class="p">,</span> <span class="s1">&#39;nq&#39;</span><span class="o">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span>
  <span class="s1">&#39;lt&#39;</span><span class="o">:</span> <span class="s1">&#39;ge&#39;</span><span class="p">,</span> <span class="s1">&#39;ge&#39;</span><span class="o">:</span> <span class="s1">&#39;lt&#39;</span><span class="p">,</span>
  <span class="s1">&#39;gt&#39;</span><span class="o">:</span> <span class="s1">&#39;le&#39;</span><span class="p">,</span> <span class="s1">&#39;le&#39;</span><span class="o">:</span> <span class="s1">&#39;gt&#39;</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">createTag</span> <span class="o">=</span> <span class="nx">freezeObject</span><span class="p">({</span>
  <span class="s1">&#39;op&#39;</span><span class="o">:</span> <span class="nx">createOpenTag</span><span class="p">,</span>
  <span class="s1">&#39;cl&#39;</span><span class="o">:</span> <span class="nx">createCloseTag</span><span class="p">,</span>
  <span class="s1">&#39;ct&#39;</span><span class="o">:</span> <span class="nx">createCommentTag</span>
<span class="p">});</span>
  
<span class="kd">function</span> <span class="nx">compileModule</span><span class="p">(</span><span class="nx">template</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">lits</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">reverseLits</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">warnings</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">var</span> <span class="nx">module</span> <span class="o">=</span> <span class="nx">parseTemplate</span><span class="p">(</span><span class="nx">template</span><span class="p">);</span>
  <span class="nx">module</span> <span class="o">=</span> <span class="nx">rewriteParseTree</span><span class="p">(</span><span class="nx">module</span><span class="p">);</span>
  <span class="nx">module</span> <span class="o">=</span> <span class="nx">replaceSymbols</span><span class="p">(</span><span class="nx">module</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">i</span><span class="o">:</span> <span class="s1">&#39;interpol&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">l</span><span class="o">:</span> <span class="nx">lits</span><span class="p">,</span> <span class="nx">n</span><span class="o">:</span> <span class="nx">module</span><span class="p">,</span> <span class="nx">e</span><span class="o">:</span> <span class="nx">warnings</span> <span class="p">};</span>

  <span class="kd">function</span> <span class="nx">rewriteParseTree</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">isStatements</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">statements</span> <span class="o">=</span> <span class="nx">rewriteParseTree</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">stmts</span><span class="p">);</span>
      <span class="nx">statements</span> <span class="o">=</span> <span class="nx">hoistPartials</span><span class="p">(</span><span class="nx">statements</span><span class="p">);</span>
      <span class="nx">statements</span> <span class="o">=</span> <span class="nx">mergeAssignments</span><span class="p">(</span><span class="nx">statements</span><span class="p">);</span>
      <span class="nx">statements</span> <span class="o">=</span> <span class="nx">mergePartials</span><span class="p">(</span><span class="nx">statements</span><span class="p">);</span>
      <span class="nx">statements</span> <span class="o">=</span> <span class="nx">rollupForLoops</span><span class="p">(</span><span class="nx">statements</span><span class="p">);</span>
      <span class="nx">statements</span> <span class="o">=</span> <span class="nx">promoteRawLiteralOutput</span><span class="p">(</span><span class="nx">statements</span><span class="p">);</span>
      <span class="nx">statements</span> <span class="o">=</span> <span class="nx">convertLiteralHTML</span><span class="p">(</span><span class="nx">statements</span><span class="p">);</span>
      <span class="nx">statements</span> <span class="o">=</span> <span class="nx">mergeRawLiteralOutput</span><span class="p">(</span><span class="nx">statements</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">statements</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rewriteParseTree</span><span class="p">(</span><span class="nx">node</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nx">hasOperator</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span> <span class="o">=</span> <span class="nx">flipConditionals</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
      <span class="nx">node</span> <span class="o">=</span> <span class="nx">flipEquality</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
      <span class="nx">node</span> <span class="o">=</span> <span class="nx">promoteNot</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
      <span class="nx">node</span> <span class="o">=</span> <span class="nx">literalFromArray</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
      <span class="nx">node</span> <span class="o">=</span> <span class="nx">literalFromDictionary</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Hoisting <em>only</em> occurs when the following condition is met:
  (!partial<em>definition)+
  partial</em>definition+
meaning that partial definitions can't be interspersed with
regular statements.  In that case, the logic is assumed too
complex to make a responsible guess as to the developer's
intentions.</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">hoistPartials</span><span class="p">(</span><span class="nx">statements</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nx">statements</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">statements</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">partials</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="p">,</span> <span class="nx">others</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ilen</span> <span class="o">=</span> <span class="nx">statements</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">ilen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">statement</span> <span class="o">=</span> <span class="nx">statements</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span> <span class="nx">hasOperator</span><span class="p">(</span><span class="nx">statement</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">others</span><span class="p">.</span><span class="nx">length</span> <span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Short-circuit.  We're either all partials or we don't
meet the conditions for hoisting</p></div></div><div class="code"><div class="wrapper">          <span class="nx">issueWarning</span><span class="p">(</span><span class="nx">statement</span><span class="p">);</span>
          <span class="k">return</span> <span class="nx">statements</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">partials</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">statement</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nx">partials</span><span class="p">.</span><span class="nx">length</span> <span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Short-circuit. we don't hoist under these conditions</p></div></div><div class="code"><div class="wrapper">          <span class="nx">issueWarning</span><span class="p">(</span><span class="nx">partials</span><span class="p">[</span><span class="nx">partials</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
          <span class="k">return</span> <span class="nx">statements</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">others</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">statement</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">partials</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">others</span><span class="p">);</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We can combine multiple sequential lines of assignments into
a single assignment operation</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">mergeAssignments</span><span class="p">(</span><span class="nx">statements</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">matchGroup</span><span class="p">(</span><span class="nx">statements</span><span class="p">,</span> <span class="nx">matchStatement</span><span class="p">(</span><span class="s1">&#39;as&#39;</span><span class="p">),</span> <span class="nx">processGroup</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">processGroup</span><span class="p">(</span><span class="nx">assignStatements</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="nx">assignStatements</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">assignStatements</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">target</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">target</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">assignStatements</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">[</span><span class="nx">target</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We can combine multiple sequential compatible partials into a
single branched partial</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">mergePartials</span><span class="p">(</span><span class="nx">statements</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">matchGroup</span><span class="p">(</span><span class="nx">statements</span><span class="p">,</span> <span class="nx">matchStatement</span><span class="p">(</span><span class="s1">&#39;de&#39;</span><span class="p">),</span> <span class="nx">processGroup</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">processGroup</span><span class="p">(</span><span class="nx">defStatements</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">namedDefs</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">defStatements</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">statement</span> <span class="o">=</span> <span class="nx">defStatements</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
          <span class="p">,</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">value</span>
          <span class="p">,</span> <span class="nx">group</span> <span class="o">=</span> <span class="nx">namedDefs</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span> <span class="nx">namedDefs</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">statement</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">group</span><span class="p">.</span><span class="nx">length</span> <span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if we see an unguarded, blow away previous definitions</p></div></div><div class="code"><div class="wrapper">          <span class="nx">warnings</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
            <span class="nx">line</span><span class="o">:</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">line</span><span class="p">,</span>
            <span class="nx">column</span><span class="o">:</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">column</span><span class="p">,</span>
            <span class="nx">message</span><span class="o">:</span> <span class="s2">&quot;The unguarded Partial &#39;&quot;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;&#39; will replace &quot;</span> <span class="o">+</span>
                     <span class="s2">&quot;the previous definition&quot;</span>
          <span class="p">});</span>
          <span class="nx">group</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nx">group</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">statement</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">namedDefs</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">definitions</span> <span class="o">=</span> <span class="nx">namedDefs</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nx">definitions</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
          <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">definitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
          <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">result</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">mergeDefinitions</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">definitions</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">mergeDefinitions</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">definitions</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">firstDefinition</span> <span class="o">=</span> <span class="nx">definitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">,</span> <span class="nx">originalArgs</span> <span class="o">=</span> <span class="nx">argumentsSignature</span><span class="p">(</span><span class="nx">firstDefinition</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="p">,</span> <span class="nx">statements</span> <span class="o">=</span> <span class="nx">firstDefinition</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="p">,</span> <span class="nx">guard</span> <span class="o">=</span> <span class="nx">firstDefinition</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

      <span class="k">if</span> <span class="p">(</span> <span class="nx">guard</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">statements</span> <span class="o">=</span> <span class="p">[</span>
          <span class="p">[</span><span class="nx">sym</span><span class="p">(</span><span class="s1">&#39;cn&#39;</span><span class="p">),</span> <span class="nx">guard</span><span class="p">,</span> <span class="nx">statements</span><span class="p">,</span> <span class="p">[</span><span class="nx">sym</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;lit&#39;</span><span class="p">)]]</span>
        <span class="p">];</span>
      <span class="p">}</span>

      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">definitions</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">definition</span> <span class="o">=</span> <span class="nx">definitions</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
          <span class="p">,</span> <span class="nx">theseArgs</span> <span class="o">=</span> <span class="nx">argumentsSignature</span><span class="p">(</span><span class="nx">definition</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

        <span class="k">if</span> <span class="p">(</span> <span class="nx">theseArgs</span> <span class="o">!==</span> <span class="nx">originalArgs</span> <span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Short-circuit, won't make assumptions about local names</p></div></div><div class="code"><div class="wrapper">          <span class="nx">warnings</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
            <span class="nx">line</span><span class="o">:</span> <span class="nx">definition</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">line</span><span class="p">,</span>
            <span class="nx">column</span><span class="o">:</span> <span class="nx">definition</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">column</span><span class="p">,</span>
            <span class="nx">message</span><span class="o">:</span> <span class="s2">&quot;Partial &#39;&quot;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;&#39; has different argument &quot;</span> <span class="o">+</span>
                     <span class="s2">&quot;names than previous definitions&quot;</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">definitions</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">var</span> <span class="nx">theseStatements</span> <span class="o">=</span> <span class="nx">definition</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
          <span class="p">,</span> <span class="nx">thisGuard</span> <span class="o">=</span> <span class="nx">definition</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

        <span class="nx">statements</span> <span class="o">=</span> <span class="p">[</span>
          <span class="p">[</span><span class="nx">sym</span><span class="p">(</span><span class="s1">&#39;cn&#39;</span><span class="p">),</span> <span class="nx">thisGuard</span><span class="p">,</span> <span class="nx">theseStatements</span><span class="p">,</span> <span class="nx">statements</span><span class="p">]</span>
        <span class="p">];</span>
        <span class="nx">guard</span> <span class="o">=</span> <span class="nx">guard</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="nx">sym</span><span class="p">(</span><span class="s1">&#39;or&#39;</span><span class="p">),</span> <span class="nx">thisGuard</span><span class="p">,</span> <span class="nx">guard</span><span class="p">];</span>
      <span class="p">}</span>

      <span class="nx">firstDefinition</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nx">statements</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="nx">guard</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">firstDefinition</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nx">guard</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">[</span><span class="nx">firstDefinition</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert literal output to pre-escaped raw output</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">promoteRawLiteralOutput</span><span class="p">(</span><span class="nx">statements</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">match</span><span class="p">(</span><span class="nx">statements</span><span class="p">,</span> <span class="nx">matcher</span><span class="p">,</span> <span class="nx">processStatement</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">matcher</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">hasOperator</span><span class="p">(</span><span class="nx">statement</span><span class="p">,</span> <span class="s1">&#39;ou&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
             <span class="nx">isLiteral</span><span class="p">(</span><span class="nx">statement</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">processStatement</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[</span><span class="nx">sym</span><span class="p">(</span><span class="s1">&#39;ra&#39;</span><span class="p">),</span> <span class="nx">sym</span><span class="p">(</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">statement</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">value</span><span class="p">),</span> <span class="s1">&#39;lit&#39;</span><span class="p">)];</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Literal HTML tags can be converted to raw output</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">convertLiteralHTML</span><span class="p">(</span><span class="nx">statements</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">match</span><span class="p">(</span><span class="nx">statements</span><span class="p">,</span> <span class="nx">matcher</span><span class="p">,</span> <span class="nx">processStatement</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">matcher</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">hasOperator</span><span class="p">(</span><span class="nx">statement</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;op&#39;</span><span class="p">,</span> <span class="s1">&#39;cl&#39;</span><span class="p">,</span> <span class="s1">&#39;ct&#39;</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">processStatement</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">op</span> <span class="o">=</span> <span class="nx">hasOperator</span><span class="p">(</span><span class="nx">statement</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;op&#39;</span><span class="p">,</span> <span class="s1">&#39;cl&#39;</span><span class="p">,</span> <span class="s1">&#39;ct&#39;</span><span class="p">])</span>
        <span class="p">,</span> <span class="nx">tag</span> <span class="o">=</span> <span class="nx">createTag</span><span class="p">[</span><span class="nx">op</span><span class="p">](</span><span class="nx">statement</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">tag</span> <span class="o">?</span> <span class="p">[</span><span class="nx">sym</span><span class="p">(</span><span class="s1">&#39;ra&#39;</span><span class="p">),</span> <span class="nx">sym</span><span class="p">(</span><span class="nx">tag</span><span class="p">,</span> <span class="s1">&#39;lit&#39;</span><span class="p">)]</span> <span class="o">:</span> <span class="nx">statement</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We can combine sequences of raw literal output</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">mergeRawLiteralOutput</span><span class="p">(</span><span class="nx">statements</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">matchGroup</span><span class="p">(</span><span class="nx">statements</span><span class="p">,</span> <span class="nx">matchStatement</span><span class="p">(</span><span class="s1">&#39;ra&#39;</span><span class="p">),</span> <span class="nx">processGroup</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">processGroup</span><span class="p">(</span><span class="nx">raStatements</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="p">,</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">raStatements</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">statement</span> <span class="o">=</span> <span class="nx">raStatements</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
          <span class="p">,</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nx">isLiteral</span><span class="p">(</span><span class="nx">output</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
          <span class="nx">buffer</span> <span class="o">=</span> <span class="nx">buffer</span> <span class="o">+</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">output</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
          <span class="nx">processBuffer</span><span class="p">();</span>
          <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">statement</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">processBuffer</span><span class="p">();</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>

      <span class="kd">function</span> <span class="nx">processBuffer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">length</span> <span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">sym</span><span class="p">(</span><span class="s1">&#39;ra&#39;</span><span class="p">),</span> <span class="nx">sym</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="s1">&#39;lit&#39;</span><span class="p">)]);</span>
        <span class="nx">buffer</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We can roll up a single nested for loop into a containing for
loop so that they share the same context</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">rollupForLoops</span><span class="p">(</span><span class="nx">statements</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">match</span><span class="p">(</span><span class="nx">statements</span><span class="p">,</span> <span class="nx">matcher</span><span class="p">,</span> <span class="nx">processStatement</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">matcher</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">hasOperator</span><span class="p">(</span><span class="nx">statement</span><span class="p">,</span> <span class="s1">&#39;fr&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>        <span class="c1">// is a for loop</span>
             <span class="nx">statement</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>           <span class="c1">// one child</span>
             <span class="nx">hasOperator</span><span class="p">(</span><span class="nx">statement</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;fr&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>  <span class="c1">// nested for loop</span>
             <span class="o">!</span><span class="nx">statement</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">statement</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>  <span class="c1">// no elses</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">processStatement</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">forStatements</span> <span class="o">=</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">,</span> <span class="nx">nested</span> <span class="o">=</span> <span class="nx">forStatements</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

      <span class="nx">statement</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">nested</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
      <span class="nx">statement</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nested</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
      <span class="k">return</span> <span class="nx">statement</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the condition is 'not' we can roll up its argument
and flip the branches.</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">flipConditionals</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">hasOperator</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="s1">&#39;cn&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">cond</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">hasOperator</span><span class="p">(</span><span class="nx">cond</span><span class="p">,</span> <span class="s1">&#39;no&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make it so</p></div></div><div class="code"><div class="wrapper">    <span class="nx">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cond</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="nx">node</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="nx">node</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if the operator is 'not' and it contains an equality,
then we can flip the equality operator and roll it up</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">flipEquality</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">hasOperator</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="s1">&#39;no&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="p">,</span> <span class="nx">op</span> <span class="o">=</span> <span class="nx">hasOperator</span><span class="p">(</span><span class="nx">child</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">newOp</span> <span class="o">=</span> <span class="nx">inverseOperators</span><span class="p">[</span><span class="nx">op</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">op</span> <span class="o">||</span> <span class="o">!</span><span class="nx">newOp</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">child</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">newOp</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">child</span><span class="p">;</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If left and right operands of an 'and' or 'or' are using the 'not'
unary, then promote it to the top and flip the and/or</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">promoteNot</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">op</span> <span class="o">=</span> <span class="nx">hasOperator</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;an&#39;</span><span class="p">,</span> <span class="s1">&#39;or&#39;</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">op</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="p">,</span> <span class="nx">leftOp</span> <span class="o">=</span> <span class="nx">hasOperator</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="s1">&#39;no&#39;</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
      <span class="p">,</span> <span class="nx">rightOp</span> <span class="o">=</span> <span class="nx">hasOperator</span><span class="p">(</span><span class="nx">right</span><span class="p">,</span> <span class="s1">&#39;no&#39;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">leftOp</span> <span class="o">||</span> <span class="o">!</span><span class="nx">rightOp</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">newOp</span> <span class="o">=</span> <span class="nx">op</span> <span class="o">===</span> <span class="s1">&#39;an&#39;</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;or&#39;</span> <span class="o">||</span> <span class="s1">&#39;an&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">[</span> <span class="nx">sym</span><span class="p">(</span><span class="s1">&#39;no&#39;</span><span class="p">,</span> <span class="nx">left</span><span class="p">),</span> <span class="p">[</span><span class="nx">sym</span><span class="p">(</span><span class="nx">newOp</span><span class="p">,</span> <span class="nx">node</span><span class="p">),</span> <span class="nx">left</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">right</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="p">];</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If all the elements of an Array are literals, then we can convert
the list to a literal array for the literal table</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">literalFromArray</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">hasOperator</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="s1">&#39;ar&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">elements</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="p">,</span> <span class="nx">output</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">elements</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">elements</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">isLiteral</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">output</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sym</span><span class="p">(</span><span class="nx">output</span><span class="p">,</span> <span class="s1">&#39;lit&#39;</span><span class="p">,</span> <span class="nx">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If all the elements of a Dictionary are literals, then we can
convert the list to a literal object for the literal table</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">literalFromDictionary</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">hasOperator</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="s1">&#39;dc&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">elements</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="p">,</span> <span class="nx">output</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">elements</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">elements</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="p">,</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">,</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">element</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="o">!</span><span class="nx">isIdentifier</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isLiteral</span><span class="p">(</span><span class="nx">name</span><span class="p">))</span> <span class="o">||</span> <span class="o">!</span><span class="nx">isLiteral</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">output</span><span class="p">[</span><span class="nx">name</span><span class="p">.</span><span class="nx">value</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sym</span><span class="p">(</span><span class="nx">output</span><span class="p">,</span> <span class="s1">&#39;lit&#39;</span><span class="p">,</span> <span class="nx">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>convert all symbol placeholders into symbol table entries for the
resulting output JSON</p></div></div><div class="code"><div class="wrapper">  <span class="kd">function</span> <span class="nx">replaceSymbols</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="nx">isSymbol</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">lit</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">replaceSymbols</span><span class="p">(</span><span class="nx">node</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">lit</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">canonical</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
      <span class="p">,</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nx">reverseLits</span><span class="p">[</span><span class="nx">canonical</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">idx</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">idx</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">idx</span> <span class="o">=</span> <span class="nx">lits</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">reverseLits</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="o">=</span> <span class="nx">idx</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">idx</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">issueWarning</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">warnings</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
      <span class="nx">line</span><span class="o">:</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">line</span><span class="p">,</span>
      <span class="nx">column</span><span class="o">:</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">column</span><span class="p">,</span>
      <span class="nx">message</span><span class="o">:</span> <span class="s2">&quot;Will only perform &#39;hoisting&#39; if all partials are placed &quot;</span> <span class="o">+</span>
               <span class="s2">&quot;after other statements&quot;</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">matchStatement</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">matcher</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">matcher</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">hasOperator</span><span class="p">(</span><span class="nx">statement</span><span class="p">,</span> <span class="nx">op</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Iterates over a set of statements and presents matching
statements to the callback for replacement</p></div></div><div class="code"><div class="wrapper"><span class="kd">function</span> <span class="nx">match</span><span class="p">(</span><span class="nx">statements</span><span class="p">,</span> <span class="nx">matcher</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">output</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">statements</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">statement</span> <span class="o">=</span> <span class="nx">statements</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nx">matcher</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nx">output</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">callback</span><span class="p">(</span><span class="nx">statement</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="nx">output</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">statement</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
<span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Iterates over a set of statements and presents adjacent groups
to the callback function for replacement</p></div></div><div class="code"><div class="wrapper"><span class="kd">function</span> <span class="nx">matchGroup</span><span class="p">(</span><span class="nx">statements</span><span class="p">,</span> <span class="nx">matcher</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">group</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="p">,</span> <span class="nx">output</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">statements</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">statement</span> <span class="o">=</span> <span class="nx">statements</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nx">matcher</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nx">group</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">statement</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="nx">processMatches</span><span class="p">();</span>
      <span class="nx">output</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">statement</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">processMatches</span><span class="p">();</span>
  <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">processMatches</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">group</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">?</span>  <span class="nx">group</span> <span class="o">:</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">group</span><span class="p">);</span>
    <span class="nx">output</span> <span class="o">=</span> <span class="nx">output</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="nx">group</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">argumentsSignature</span><span class="p">(</span><span class="nx">argNames</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">argNames</span> <span class="o">||</span> <span class="o">!</span><span class="nx">argNames</span><span class="p">.</span><span class="nx">length</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">argNames</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">argNames</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">createOpenTag</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">isIdentifier</span><span class="p">(</span><span class="nx">statement</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">tag</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">value</span><span class="p">]</span>
    <span class="p">,</span> <span class="nx">attrs</span> <span class="o">=</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span> <span class="nx">attrs</span> <span class="o">&amp;&amp;</span> <span class="nx">attrs</span><span class="p">.</span><span class="nx">length</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">attrs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">attr</span> <span class="o">=</span> <span class="nx">attrs</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">isIdentifier</span><span class="p">(</span><span class="nx">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">||</span> <span class="o">!</span><span class="nx">isLiteral</span><span class="p">(</span><span class="nx">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">value</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="k">typeof</span> <span class="nx">val</span> <span class="o">!==</span> <span class="s1">&#39;boolean&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">tag</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="nx">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span><span class="p">,</span> <span class="s2">&quot;=\&quot;&quot;</span><span class="p">,</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">value</span><span class="p">),</span> <span class="s2">&quot;\&quot;&quot;</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span> <span class="nx">val</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">tag</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="nx">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nx">tag</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot; /&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">tag</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">createCloseTag</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">isIdentifier</span><span class="p">(</span><span class="nx">statement</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;&lt;/&quot;</span><span class="p">,</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">value</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">createCommentTag</span><span class="p">(</span><span class="nx">statement</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;&lt;!--&quot;</span><span class="p">,</span> <span class="nx">statement</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">value</span><span class="p">,</span> <span class="s2">&quot;--&gt;&quot;</span><span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Exported Functions</p></div></div><div class="code"><div class="wrapper"><span class="nx">interpol</span><span class="p">.</span><span class="nx">compileModule</span> <span class="o">=</span> <span class="nx">exports</span><span class="p">.</span><span class="nx">compileModule</span> <span class="o">=</span> <span class="nx">compileModule</span><span class="p">;</span></div></div></div></div></body></html>